import { Injectable, EventEmitter, Output, Injector, Component, Input, NgModule, APP_INITIALIZER } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router, RouterModule } from '@angular/router';
import { map, catchError, timeout, finalize, switchMap, filter, take } from 'rxjs/operators';
import { HttpClient, HttpHeaders, HttpErrorResponse, HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { os, name, version } from 'platform';
import { Driver, NgForageConfig, NgForage, NgForageCache, InstanceFactory } from 'ngforage';
import { Subject, throwError, BehaviorSubject } from 'rxjs';
import firebase from 'firebase';

// @dynamic
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'ngforage';
import * as ɵngcc2 from '@angular/common/http';
import * as ɵngcc3 from '@angular/router';
import * as ɵngcc4 from '@angular/common';

const _c0 = function (a0, a1) { return { background: a0, color: a1 }; };
const _c1 = function () { return ["snackbar-layout", "customClass"]; };
const _c2 = ["*"];
const _c3 = function (a0) { return { color: a0 }; };
function SnackbarComponent_n_snack_1_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵlistener("click", function SnackbarComponent_n_snack_1_div_4_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r5); const snackbar_r1 = ɵngcc0.ɵɵnextContext().$implicit; return snackbar_r1.action.onClick(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const snackbar_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(2, _c3, snackbar_r1.action.color || ctx_r2.accent));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", snackbar_r1.action.text, " ");
} }
function SnackbarComponent_n_snack_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "n-snack", 2);
    ɵngcc0.ɵɵelementStart(1, "div", 3);
    ɵngcc0.ɵɵelementStart(2, "div", 4);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, SnackbarComponent_n_snack_1_div_4_Template, 2, 4, "div", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const snackbar_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("background", snackbar_r1.background || ctx_r0.background)("customClass", snackbar_r1.customClass || ctx_r0.customClass)("color", snackbar_r1.color || ctx_r0.color || ctx_r0.calcTextColor(snackbar_r1.background || ctx_r0.background));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", snackbar_r1.msg, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", snackbar_r1.action.text);
} }
const _c4 = ".snack-action[_ngcontent-%COMP%]{color:#2196f3;cursor:pointer;font-weight:700}.container[_ngcontent-%COMP%]{display:flex;flex-direction:row;flex-wrap:wrap}.child[_ngcontent-%COMP%]{flex:1 0;margin-right:.5em;width:60%}.snackbars.bottom-center[_ngcontent-%COMP%]{align-items:middle}.snackbars[_ngcontent-%COMP%]{display:flex;display:inline;font-family:Roboto;letter-spacing:1px;max-width:100%;position:fixed;word-wrap:break-word;z-index:99999}.snackbars.bottom-center[_ngcontent-%COMP%]{align-items:center;bottom:1px;left:50%;transform:translate(-50%)}.snack[_ngcontent-%COMP%]{border-radius:.3em;max-height:50vh;overflow:auto;padding:1em}";
class NSystemService {
    constructor() {
        this._deviceType = this.checkDevice();
    }
    static getInstance() {
        if (!this.instance) {
            this.instance = new NSystemService();
        }
        return this.instance;
    }
    /**
     * Seter and getter for the environments
     */
    // set environments(properties) {
    //   console.log(properties);
    //   NSystemService.envProperties = properties;
    //   this.properties = this.getVal('properties');
    // }
    // get environments() {
    //   return NSystemService.envProperties;
    // }
    /**
     * Returna 'mobile' or 'browser' based on the platform
     */
    checkDevice() {
        if (window['device'] && (window['device']['platform'] != 'browser' || window['device']['platform'] != 'Browser')) {
            return 'mobile';
        }
        else if (window['device'] && (window['device']['platform'] == 'browser' || window['device']['platform'] == 'Browser')) {
            return 'cordova_browser';
        }
        else {
            return 'browser';
        }
    }
    get deviceType() {
        return this._deviceType;
    }
    getVal(key) {
        if (!NSystemService.envProperties) {
            NSystemService.envProperties = window['neutrinos']['environments'];
            this.properties = NSystemService.envProperties.properties;
        }
        if (key == 'properties') {
            if (NSystemService.envProperties) {
                return NSystemService.envProperties.properties;
            }
            else {
                return undefined;
            }
        }
        else {
            if (NSystemService.envProperties && NSystemService.envProperties.properties) {
                return NSystemService.envProperties.properties[key];
            }
            else {
                return undefined;
            }
        }
    }
    isAndroid() {
        if (window['device'] && window['device']['platform'] == 'Android') {
            return true;
        }
        else {
            return false;
        }
    }
    isIOS() {
        if (window['device'] && window['device']['platform'] == 'iOS') {
            return true;
        }
        else {
            return false;
        }
    }
    getAndroidVersion() {
        if (this.isAndroid()) {
            return window['device']['version'];
        }
        else {
            return '';
        }
    }
    getAuthUrl() {
        // this.properties = this.getVal('properties');
        return this.properties.baseUrl + this.properties.tenantName + '/auth/';
    }
    getTenantUrl() {
        return this.properties.baseUrl + this.properties.tenantName + '/';
    }
    getAppUrl() {
        return this.properties.baseUrl + this.properties.tenantName + '/proxy/' + this.properties.appName + '/';
    }
    getProxyUrl() {
        return this.properties.baseUrl + this.properties.tenantName + '/proxy/';
    }
    getDataModelUrl() {
        return this.properties.baseUrl + this.properties.tenantName + '/datamodel/' + this.properties.appDataSource + '/' + this.properties.appName + '/';
    }
    getFileIOUrl() {
        return this.properties.baseUrl + this.properties.tenantName + '/fileio/' +
            this.properties.appDataSource + '/' + this.properties.appName + '/';
    }
    getPlatformDetails(type) {
        const pDetails = {
            platform: os.family,
            platformVersion: os.version,
        };
        if (type === 'browser') {
            return Object.assign(pDetails, {
                type: 'browser',
                browser: name,
                browserVersion: version,
            });
        }
        else if (type === 'mobile' || type === 'cordova_browser') {
            return Object.assign(pDetails, {
                type: 'mobile',
                model: window['device'].model,
                manufacturer: window['device'].manufacturer,
                isVirtual: window['device'].isVirtual
            });
        }
    }
}

class NSessionStorageService {
    constructor() {
        NSessionStorageService.sessionStorageCache = sessionStorage;
    }
    getSessionStorage() {
        return NSessionStorageService.sessionStorageCache;
    }
    setValue(key, value) {
        NSessionStorageService.sessionStorageCache[key] = value;
        sessionStorage.setItem(key, value);
    }
    getValue(key) {
        if (!NSessionStorageService.sessionStorageCache[key]) {
            return null;
        }
        try {
            const obj = NSessionStorageService.sessionStorageCache[key];
            return JSON.parse(obj);
        }
        catch (error) {
            return NSessionStorageService.sessionStorageCache[key];
        }
    }
    remove(key) {
        if (NSessionStorageService.sessionStorageCache.hasOwnProperty(key)) {
            delete NSessionStorageService.sessionStorageCache[key];
            sessionStorage.removeItem(key);
        }
    }
    clearSessionStorage() {
        NSessionStorageService.sessionStorageCache = {};
        sessionStorage.clear();
    }
}
NSessionStorageService.ɵfac = function NSessionStorageService_Factory(t) { return new (t || NSessionStorageService)(); };
NSessionStorageService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NSessionStorageService, factory: NSessionStorageService.ɵfac });
NSessionStorageService.sessionStorageCache = {};
NSessionStorageService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NSessionStorageService, [{
        type: Injectable
    }], function () { return []; }, null); })();

class NUtility {
    constructor() { }
    generateUUID() {
        return this.__s4() + this.__s4() + '-' + this.__s4() + '-' + this.__s4() + '-' + this.__s4() + '-' + this.__s4() + this.__s4() + this.__s4();
    }
    __s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
}

class NLocalStorageService {
    constructor(ngfConfig, ngf, ngfCache) {
        this.ngfConfig = ngfConfig;
        this.ngf = ngf;
        this.ngfCache = ngfCache;
        this.storageCache = {};
    }
    initStorage() {
        return new Promise((resolve, reject) => {
            if (window['cordova']) {
                this.initNgForage();
            }
            this.ngf.iterate((value, key, iteratonNumber) => {
                this.storageCache[key] = value;
            }).then(result => {
                this.checkDeviceId();
                return resolve('iteration is completed');
            }).catch(error => {
                return reject(error);
            });
        });
    }
    getStorage() {
        return this.storageCache;
    }
    setValue(key, value) {
        if (window['cordova']) {
            this.initNgForage();
        }
        this.storageCache[key] = value;
        return this.ngf.setItem(key, value).then(result => {
            return result;
        }, error => {
            console.log(error);
        });
    }
    getValue(key) {
        if (!this.storageCache[key]) {
            return null;
        }
        try {
            const obj = this.storageCache[key];
            return JSON.parse(obj);
        }
        catch (error) {
            return this.storageCache[key];
        }
    }
    remove(key) {
        delete this.storageCache[key];
        if (window['cordova']) {
            this.initNgForage();
        }
        this.ngf.removeItem(key).then(fulfilled => {
            delete this.ngf[key];
        }).catch(error => {
            console.error('Could not remove', key);
        });
    }
    clear() {
        this.storageCache = {};
        this.ngf.clear();
    }
    pluginCheck() {
        if (window['cordova'] && window['NativeStorage']) {
            this.nativeStorageI = window['NativeStorage'];
            // return true;
        }
        // this.initStorage();
    }
    getItemNs(key) {
        return new Promise((resolve, reject) => {
            if (window['cordova'] && window['NativeStorage']) {
                this.nativeStorageI.getItem(key, result => {
                    resolve(result);
                }, error => {
                    reject(error);
                });
            }
        });
    }
    setItemNs(key, value) {
        return new Promise((resolve, reject) => {
            if (window['cordova'] && window['NativeStorage']) {
                this.nativeStorageI.setItem(key, value, result => {
                    resolve(result);
                }, error => {
                    reject(error);
                });
            }
        });
    }
    removeItemNs(key) {
        return new Promise((resolve, reject) => {
            if (window['cordova'] && window['NativeStorage']) {
                this.nativeStorageI.remove(key, (result) => {
                    resolve(result);
                }, (error) => {
                    reject(error);
                });
            }
        });
    }
    clearNs() {
        return new Promise((resolve, reject) => {
            if (window['cordova'] && window['NativeStorage']) {
                this.nativeStorageI.clear(result => {
                    resolve(result);
                }, error => {
                    reject(error);
                });
            }
        });
    }
    initNgForage() {
        let driverType = window['neutrinos']['environments']['properties']['NGFORAGE_MOBILE_DRIVER'] ? window['neutrinos']['environments']['properties']['NGFORAGE_MOBILE_DRIVER'] : "INDEXED_DB";
        this.ngfConfig.configure({
            name: 'MyApp',
            driver: [
                Driver[driverType],
            ]
        });
    }
    promiseReflect(promise) {
        return promise.then(resolved => { return { v: resolved, status: 'resolved' }; }, error => { return { e: error, status: 'rejected' }; });
    }
    clearLocalStorage() {
        this.remove('userObj');
        this.remove('accessToken');
        this.remove('refreshToken');
        this.remove('registrationId');
    }
    /**
     * Due to timing issues and circular dependency checkDeviceId is moved from NSystemService
    */
    checkDeviceId() {
        if (NSystemService.getInstance().checkDevice() === 'browser') {
            this._deviceUUID = this.getValue('uuid');
            if (!this._deviceUUID) {
                this._deviceUUID = new NUtility().generateUUID();
                this.setValue('uuid', this._deviceUUID);
            }
        }
        else {
            window['plugins'].uniqueDeviceID.get((uuid) => {
                this._deviceUUID = uuid;
                this.setValue('uuid', this._deviceUUID);
            });
        }
        return this._deviceUUID;
    }
    get deviceUUID() {
        return this._deviceUUID;
    }
}
NLocalStorageService.ɵfac = function NLocalStorageService_Factory(t) { return new (t || NLocalStorageService)(ɵngcc0.ɵɵinject(ɵngcc1.NgForageConfig), ɵngcc0.ɵɵinject(ɵngcc1.NgForage), ɵngcc0.ɵɵinject(ɵngcc1.NgForageCache)); };
NLocalStorageService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NLocalStorageService, factory: NLocalStorageService.ɵfac });
NLocalStorageService.ctorParameters = () => [
    { type: NgForageConfig },
    { type: NgForage },
    { type: NgForageCache }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NLocalStorageService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.NgForageConfig }, { type: ɵngcc1.NgForage }, { type: ɵngcc1.NgForageCache }]; }, null); })();

class NTokenService {
    // nLocalStorageService: NLocalStorageService;
    constructor(nLocalStorageService) {
        this.nLocalStorageService = nLocalStorageService;
        this.nSessionStorage = new NSessionStorageService();
        // this.nLocalStorageService = new NLocalStorageService();
    }
    updateTokens(tokensObj, isRemember) {
        let userObj = this.decodeToken(tokensObj['accessToken']);
        this.nSessionStorage.setValue('accessToken', tokensObj['accessToken']);
        this.nSessionStorage.setValue('refreshToken', tokensObj['refreshToken']);
        this.nSessionStorage.setValue('userObj', JSON.stringify(userObj));
        if ((isRemember || this.nLocalStorageService.getValue('accessToken'))) {
            this.nLocalStorageService.setValue('accessToken', tokensObj['accessToken']);
            this.nLocalStorageService.setValue('refreshToken', tokensObj['refreshToken']);
            this.nLocalStorageService.setValue('userObj', JSON.stringify(userObj));
        }
    }
    updateSessionStorage() {
        this.updateTokens(this.nLocalStorageService.getStorage(), true);
    }
    urlBase64Decode(str) {
        let output = str.replace(/-/g, '+').replace(/_/g, '/');
        switch (output.length % 4) {
            case 0: {
                break;
            }
            case 2: {
                output += '==';
                break;
            }
            case 3: {
                output += '=';
                break;
            }
            default: {
                throw 'Illegal base64url string!';
            }
        }
        return this.b64DecodeUnicode(output);
    }
    // credits for decoder goes to https://github.com/atk
    b64decode(str) {
        let chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        let output = '';
        str = String(str).replace(/=+$/, '');
        if (str.length % 4 == 1) {
            throw new Error("'atob' failed: The string to be decoded is not correctly encoded.");
        }
        for (
        // initialize result and counters
        let bc = 0, bs, buffer, idx = 0; 
        // get next character
        buffer = str.charAt(idx++); 
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
            // and if not first of each 4 characters,
            // convert the first 8 bits to one ascii character
            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
            // try to find character in table (0-63, not found => -1)
            buffer = chars.indexOf(buffer);
        }
        return output;
    }
    // https://developer.mozilla.org/en/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem
    b64DecodeUnicode(str) {
        return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), (c) => {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
    }
    decodeToken(token) {
        let parts = token.split('.');
        if (parts.length !== 3) {
            throw new Error('JWT must have 3 parts');
        }
        let decoded = this.urlBase64Decode(parts[1]);
        if (!decoded) {
            throw new Error('Cannot decode the token');
        }
        return JSON.parse(decoded);
    }
    getTokenExpirationDate(token) {
        let decoded;
        decoded = this.decodeToken(token);
        if (!decoded.hasOwnProperty('exp')) {
            return null;
        }
        let date = new Date(0); // The 0 here is the key, which sets the date to the epoch
        date.setUTCSeconds(decoded.exp);
        return date;
    }
    isTokenExpired(token, offsetSeconds) {
        let date = this.getTokenExpirationDate(token);
        offsetSeconds = offsetSeconds || 0;
        if (date == null) {
            return false;
        }
        // Token expired?
        return !(date.valueOf() > (new Date().valueOf() + (offsetSeconds * 1000)));
    }
}
NTokenService.ɵfac = function NTokenService_Factory(t) { return new (t || NTokenService)(ɵngcc0.ɵɵinject(NLocalStorageService)); };
NTokenService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NTokenService, factory: NTokenService.ɵfac });
NTokenService.ctorParameters = () => [
    { type: NLocalStorageService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NTokenService, [{
        type: Injectable
    }], function () { return [{ type: NLocalStorageService }]; }, null); })();

const ServiceName = "PubSub Service";
class NPubSubService {
    constructor() {
        this.events = {};
    }
    $sub(event, callback, error, complete) {
        if (!event) {
            throw new Error(`[${ServiceName}] => Subscription method must get event name.`);
        }
        if (this.events[event] === undefined) {
            this.events[event] = new Subject();
        }
        if (typeof callback !== 'function') {
            return this.events[event].asObservable();
        }
        else {
            return this.events[event].asObservable().subscribe(callback, error, complete);
        }
    }
    $pub(event, eventObject) {
        if (!event) {
            throw new Error(`[${ServiceName}] => Publish method must get event name.`);
        }
        else if (!this.events[event]) {
            return;
        }
        this.events[event].next(eventObject);
    }
}
NPubSubService.ɵfac = function NPubSubService_Factory(t) { return new (t || NPubSubService)(); };
NPubSubService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NPubSubService, factory: NPubSubService.ɵfac });
NPubSubService.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NPubSubService, [{
        type: Injectable
    }], function () { return []; }, null); })();

class NLogoutService {
    // nLocalStorageService = new NLocalStorageService();
    constructor(nLocalStorageService) {
        this.nLocalStorageService = nLocalStorageService;
        this.nSessionStorage = new NSessionStorageService();
    }
    logout() {
        this.nSessionStorage.clearSessionStorage();
        this.nLocalStorageService.clearLocalStorage();
        return true;
    }
}
NLogoutService.ɵfac = function NLogoutService_Factory(t) { return new (t || NLogoutService)(ɵngcc0.ɵɵinject(NLocalStorageService)); };
NLogoutService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NLogoutService, factory: NLogoutService.ɵfac });
NLogoutService.ctorParameters = () => [
    { type: NLocalStorageService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NLogoutService, [{
        type: Injectable
    }], function () { return [{ type: NLocalStorageService }]; }, null); })();

// import { NSnackbarService } from './snackbar/service/snackbar.service';
class NHTTPLoaderService {
    constructor(nLogoutService, nPubSubService) {
        this.nLogoutService = nLogoutService;
        this.nPubSubService = nPubSubService;
        this.pendingRequests = 0;
        this.showLoading = false;
        this._isHTTPRequestInProgress = new Subject();
        this._isHTTPRequestInProgress$ = this._isHTTPRequestInProgress.asObservable();
    }
    isHTTPRequestInProgress(bool) {
        if (bool) {
            this.pendingRequests++;
            if (!this.showLoading) {
                this._isHTTPRequestInProgress.next(bool);
            }
            this.showLoading = true;
        }
        else {
            this.pendingRequests--;
            if (this.pendingRequests <= 0) {
                if (this.showLoading) {
                    this._isHTTPRequestInProgress.next(bool);
                }
                this.showLoading = false;
            }
        }
    }
    alertError(error) {
        if (error.status < 200 || error.status > 500) {
            if (error.status === 0) {
                this.nPubSubService.$pub('openSnackBar', 'Connectivity issue');
            }
            else {
                this.nPubSubService.$pub('openSnackBar', 'Response failure');
            }
        }
        else if (error.status === 401) {
            this.nLogoutService.logout();
            if (error.error) {
                this.nPubSubService.$pub('openSnackBar', error.error);
            }
            else {
                this.nPubSubService.$pub('openSnackBar', error);
            }
        }
        else if (error.error) {
            if (error.error instanceof Object) {
                this.nPubSubService.$pub('openSnackBar', error.error.message);
            }
            else {
                this.nPubSubService.$pub('openSnackBar', error.error);
            }
        }
        else {
            this.nPubSubService.$pub('openSnackBar', 'Response failure');
        }
    }
}
NHTTPLoaderService.ɵfac = function NHTTPLoaderService_Factory(t) { return new (t || NHTTPLoaderService)(ɵngcc0.ɵɵinject(NLogoutService), ɵngcc0.ɵɵinject(NPubSubService)); };
NHTTPLoaderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NHTTPLoaderService, factory: NHTTPLoaderService.ɵfac });
NHTTPLoaderService.ctorParameters = () => [
    { type: NLogoutService },
    { type: NPubSubService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NHTTPLoaderService, [{
        type: Injectable
    }], function () { return [{ type: NLogoutService }, { type: NPubSubService }]; }, null); })();

class NNotificationService {
    constructor(localStorageService, pubSubService, http, bHttpLoader) {
        this.localStorageService = localStorageService;
        this.pubSubService = pubSubService;
        this.http = http;
        this.bHttpLoader = bHttpLoader;
        // private static instance: NNotificationService;
        this.systemService = NSystemService.getInstance();
        this.possiblePushTypes = ['APNS', 'FCM'];
        this.firebaseSenderId = this.systemService.getVal('firebaseSenderId');
        this.isNotificationEnabled = this.systemService.getVal('isNotificationEnabled');
        this.appName = this.systemService.getVal('appName');
        this.deviceType = this.systemService.deviceType;
        this.sessionStorage = new NSessionStorageService();
        this.loginSubscribe = this.pubSubService.$sub('firebaseRegister', () => {
            this.enableNotification();
        });
    }
    ngOnInit() {
    }
    enableNotification() {
        let pushType = this.getPushType(this.systemService.getVal('pushType'));
        document.addEventListener('deviceready', event => {
            if (this.isNotificationEnabled) {
                if (this.deviceType && this.deviceType != 'browser') {
                    this.deviceType = this.systemService.deviceType;
                    this.checkPermission(pushType).then(res => {
                        if (res) {
                            this.initializeNotifications(pushType);
                        }
                    });
                }
            }
        });
        if (this.isNotificationEnabled && pushType !== 'APNS') {
            if (this.deviceType && this.deviceType == 'browser' && window['Notification']) {
                this.initialiseWebPush();
            }
        }
    }
    initialiseWebPush() {
        const __this = this;
        const messaging = firebase.messaging();
        Notification.requestPermission()
            .then(function () {
            return messaging.getToken();
        })
            .then(function (token) {
            if (token) {
                __this.sendRegDetails(token);
            }
        })
            .catch(function (err) {
            __this.bHttpLoader.alertError(err);
        });
        messaging.onMessage(function (payload) {
            if (payload['notification']) {
                let notificationObj = payload['notification'];
                let options = {
                    body: notificationObj.body,
                    icon: notificationObj.icon
                };
                // creating a native browser message
                let notificationUI = new Notification(notificationObj.title, options);
                notificationUI.onclick = function () {
                    window.focus(); // window is focused when the user clicks the notification using this
                };
            }
        });
    }
    checkPermission(pushType) {
        // Android & iOS only
        // Checks whether the push notification permission has been granted.
        return new Promise((resolve) => {
            pushType = this.getPushType(pushType);
            if ((this.deviceType === 'Android' || this.deviceType === 'iOS') && (pushType === 'FCM')) {
                PushNotification.hasPermission(function (data) {
                    return resolve(data.isEnabled);
                });
            }
            else if (this.deviceType === 'iOS' && pushType === 'APNS') {
                APNSPushNotification.hasPermission(function (data) {
                    return resolve(data.isEnabled);
                });
            }
            else {
                return resolve(true);
            }
        });
    }
    initializeNotifications(pushType) {
        //pushType = pushType ? pushType : 'FCM';
        pushType = this.getPushType(pushType);
        let push;
        // Default if for FCM
        if (pushType === 'FCM') {
            push = window['PushNotification'].init({
                android: {
                    senderID: this.firebaseSenderId
                },
                ios: {
                    alert: "true",
                    badge: "true",
                    sound: "true",
                    senderID: this.firebaseSenderId
                },
            });
        }
        // New APNS plugin init
        else if (pushType === 'APNS') {
            push = window['APNSPushNotification'].init({
                ios: {
                    alert: "true",
                    badge: "true",
                    sound: "true"
                }
            });
        }
        push.on('registration', (data) => {
            // data.registrationId
            this.sendRegDetails(data.registrationId);
        });
        // ToDo Christy get call back function from app user to change what happens once a notification arrives
        push.on('notification', (data) => {
            window['cordova'].plugins.notification.local.schedule({
                title: data.title,
                text: data.message,
                sound: data.sound,
                at: new Date().getTime()
            });
        });
        push.on('error', (e) => {
            // e.message
            console.error(e);
        });
    }
    sendRegDetails(registrationId) {
        this.localStorageService.setValue('registrationId', registrationId);
        var url = this.systemService.getTenantUrl() + 'notification/' + this.systemService.getVal('appName') + '/register';
        let pushType = this.getPushType(this.systemService.getVal('pushType'));
        this.http.post(url, {
            'key': this.sessionStorage.getValue('userObj')['userKey'],
            'uuid': this.localStorageService.getValue('uuid'),
            'fbregid': registrationId,
            'pushType': pushType
        }).subscribe(result => {
            // this.pubSubService.$pub('FBRegComp');
        }, error => {
            console.log(error);
        });
    }
    getPushType(currPushType) {
        let isValidPush = typeof currPushType !== 'undefined' && this.possiblePushTypes.includes(currPushType.toUpperCase());
        let pushType = isValidPush ? currPushType.toUpperCase() : 'FCM';
        return pushType;
    }
    ngOnDestroy() {
        this.loginSubscribe.unSubscribe();
    }
}
NNotificationService.ɵfac = function NNotificationService_Factory(t) { return new (t || NNotificationService)(ɵngcc0.ɵɵinject(NLocalStorageService), ɵngcc0.ɵɵinject(NPubSubService), ɵngcc0.ɵɵinject(ɵngcc2.HttpClient), ɵngcc0.ɵɵinject(NHTTPLoaderService)); };
NNotificationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NNotificationService, factory: NNotificationService.ɵfac });
NNotificationService.ctorParameters = () => [
    { type: NLocalStorageService },
    { type: NPubSubService },
    { type: HttpClient },
    { type: NHTTPLoaderService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NNotificationService, [{
        type: Injectable
    }], function () { return [{ type: NLocalStorageService }, { type: NPubSubService }, { type: ɵngcc2.HttpClient }, { type: NHTTPLoaderService }]; }, null); })();

class NLoginService {
    constructor(http, pubSubService, notificationService, nLocalStorageService, nTokenService) {
        this.http = http;
        this.pubSubService = pubSubService;
        this.notificationService = notificationService;
        this.nLocalStorageService = nLocalStorageService;
        this.nTokenService = nTokenService;
        this.loginCompleted = new EventEmitter();
        this.systemService = NSystemService.getInstance();
        // this.nTokenService = new NTokenService();
        this.nSessionStorage = new NSessionStorageService();
        // this.nLocalStorageService = new NLocalStorageService();
    }
    login(userName, password, isRemember) {
        this.appProperties = this.systemService.getVal('properties');
        this.loginUrl = this.systemService.getAuthUrl() + this.appProperties.appName;
        this.uuid = this.nLocalStorageService.getValue('uuid');
        if (!this.uuid) {
            this.uuid = this.nLocalStorageService.checkDeviceId();
        }
        this.details = {
            username: userName,
            password: password,
        };
        this.details.platformDetails = this.systemService.getPlatformDetails(this.systemService.checkDevice());
        this.details.platformDetails['uuid'] = this.uuid;
        return this.http.post(this.loginUrl, JSON.stringify(this.details)).pipe(map(result => {
            const tokensObj = result;
            if (tokensObj) {
                this.nTokenService.updateTokens(tokensObj, isRemember);
            }
            // TODO chris array of supported pushes currently only support APNS and Firebase
            if ((this.systemService.getVal('firebaseSenderId') != 'FIREBASE_SENDER_ID' && this.systemService.getVal('firebaseAuthKey') != 'FIREBASE_AUTH_KEY')
                || (this.systemService.getVal('pushType') === 'APNS' && this.systemService.isIOS())) {
                this.pubSubService.$pub('firebaseRegister');
            }
            this.pubSubService.$pub('loginComplete');
            return (result);
        }, error => {
            return (error);
        }));
    }
    isLoggedIn() {
        return this.nLocalStorageService.initStorage().then(result => {
            if (this.nSessionStorage.getValue('accessToken') && this.nSessionStorage.getValue('refreshToken') &&
                this.nSessionStorage.getValue('accessToken') != 'null' && this.nSessionStorage.getValue('refreshToken') != 'null') {
                return true;
            }
            return false;
        }).catch(error => {
            return false;
        });
    }
}
NLoginService.ɵfac = function NLoginService_Factory(t) { return new (t || NLoginService)(ɵngcc0.ɵɵinject(ɵngcc2.HttpClient), ɵngcc0.ɵɵinject(NPubSubService), ɵngcc0.ɵɵinject(NNotificationService), ɵngcc0.ɵɵinject(NLocalStorageService), ɵngcc0.ɵɵinject(NTokenService)); };
NLoginService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NLoginService, factory: NLoginService.ɵfac });
NLoginService.ctorParameters = () => [
    { type: HttpClient },
    { type: NPubSubService },
    { type: NNotificationService },
    { type: NLocalStorageService },
    { type: NTokenService }
];
NLoginService.propDecorators = {
    loginCompleted: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NLoginService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc2.HttpClient }, { type: NPubSubService }, { type: NNotificationService }, { type: NLocalStorageService }, { type: NTokenService }]; }, { loginCompleted: [{
            type: Output
        }] }); })();

class NAuthGuardService {
    constructor(nLoginService, router) {
        this.nLoginService = nLoginService;
        this.router = router;
    }
    canActivate() {
        return this.nLoginService.isLoggedIn().then(result => {
            if (result) {
                return true;
            }
            else {
                this.router.navigate(['unauthorized']);
                return false;
            }
        });
    }
}
NAuthGuardService.ɵfac = function NAuthGuardService_Factory(t) { return new (t || NAuthGuardService)(ɵngcc0.ɵɵinject(NLoginService), ɵngcc0.ɵɵinject(ɵngcc3.Router)); };
NAuthGuardService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NAuthGuardService, factory: NAuthGuardService.ɵfac });
NAuthGuardService.ctorParameters = () => [
    { type: NLoginService },
    { type: Router }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NAuthGuardService, [{
        type: Injectable
    }], function () { return [{ type: NLoginService }, { type: ɵngcc3.Router }]; }, null); })();

class NDataModelService {
    constructor(http) {
        this.http = http;
        this.invalidDataModelName = 'Invalid data model name.';
        this.invalidDataModelId = 'Invalid data model id.';
        this.invalidDataModelObj = 'Invalid data model object.';
        this.systemService = NSystemService.getInstance();
    }
    // GET /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}
    /**
     *
     * @param dataModelName
     * @param filter The filter query parameter allows to specify conditions on the documents to return.
     * The filter qparam value is any mongodb query… Defaults to {}
     * @param keys Projections to be applited on mongo db.
     * @param sort sort to be applied on the query results. Defaults to {}
     * @param pagenumber Page number for paginated queries. Defaults to 1
     * @param pagesize Size of each page to be returned. Defaults to 100.
     */
    get(dataModelName, filter, keys, sort, pagenumber, pagesize) {
        if (dataModelName) {
            // let modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}`;
            let modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName;
            if (this.checkIfValid(filter) || this.checkIfValid(keys) || this.checkIfValid(sort) ||
                this.checkIfValid(pagenumber) || this.checkIfValid(pagesize)) {
                let queryString = `${this.toQueryString({
                    'filter': filter,
                    'keys': keys,
                    'sort': sort,
                    'pagenumber': pagenumber,
                    'pagesize': pagesize
                })}`;
                if (queryString === '') {
                    queryString += '?filter={}';
                }
                else {
                    queryString = '?'.concat(queryString);
                }
                modelNameUrl += queryString;
            }
            return this.http.get(modelNameUrl).pipe(map((value, index) => {
                return value;
            }), catchError(error => {
                return throwError(error);
            }));
        }
        else {
            return throwError(new Error(`Could not get ${dataModelName}. ${this.invalidDataModelName}`));
        }
    }
    // PUT /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}
    /**
     *
     * @param dataModelName Data model name of the app
     * @param dataModelObj Data Model object which is to be inserted
     */
    put(dataModelName, dataModelObj) {
        if (dataModelName) {
            if (dataModelObj) {
                // const modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}`;
                const modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName;
                return this.http.put(modelNameUrl, dataModelObj).pipe(map((value, index) => {
                    return value;
                }), catchError(error => {
                    return throwError(error);
                }));
            }
            else {
                return throwError(new Error(`Could not put ${dataModelObj} in ${dataModelName}. ${this.invalidDataModelObj}`));
            }
        }
        else {
            return throwError(new Error(`Could not put ${dataModelObj} in ${dataModelName}. ${this.invalidDataModelName}`));
        }
    }
    // DELETE /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}
    /**
     *
     * @param dataModelName
     * @param filter
     */
    delete(dataModelName, filter) {
        let modelNameUrl;
        if (dataModelName) {
            // modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}`;
            modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName;
            if (this.checkIfValid(filter) && filter != '') {
                modelNameUrl += `?filter=${filter}`;
            }
            else {
                modelNameUrl += '?filter={}';
            }
            return this.http.delete(modelNameUrl).pipe(map((value, index) => {
                return value;
            }), catchError(error => {
                return throwError(error);
            }));
        }
        else {
            return throwError(new Error(`Could not delete ${dataModelName}. ${this.invalidDataModelName}`));
        }
    }
    // PATCH /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}
    /**
     *
     * @param dataModelName Data model name which is to be updated
     * @param dataModelObj New data model object
     */
    update(dataModelName, updateObject) {
        if (dataModelName && updateObject) {
            // const modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}`;
            const modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName;
            return this.http.patch(modelNameUrl, updateObject).pipe(map((value, index) => {
                return value;
            }), catchError(error => {
                return throwError(error);
            }));
        }
        else {
            return throwError(new Error(`Could not update ${dataModelName}. ${this.invalidDataModelName}`));
        }
    }
    // GET /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}/{dataModelId}
    /**
     *
     * @param dataModelName Data model name which is to be updated
     * @param dataModelId Data model id which is to be updated
     */
    getById(dataModelName, dataModelId) {
        if (dataModelName) {
            if (dataModelId) {
                // const modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}/${dataModelId}`;
                const modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName + "/" + dataModelId;
                return this.http.get(modelNameUrl).pipe(map((value, index) => {
                    return value;
                }), catchError(error => {
                    return throwError(error);
                }));
            }
            else {
                throwError(new Error(`Could not get ${dataModelName} by id ${dataModelId}. ${this.invalidDataModelId}`));
            }
        }
        else {
            throwError(new Error(`Could not get ${dataModelName} by id ${dataModelId}. ${this.invalidDataModelName}`));
        }
    }
    // DELETE /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}/{dataModelId}
    /**
     *
     * @param dataModelName Data model name which is to be deleted
     * @param dataModelId Data model id which is to be deleted
     */
    deleteById(dataModelName, dataModelId) {
        if (dataModelName) {
            if (dataModelId) {
                // const modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}/${dataModelId}`;
                const modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName + "/" + dataModelId;
                return this.http.delete(modelNameUrl).pipe(map((value, index) => {
                    return value;
                }), catchError(error => {
                    return throwError(error);
                }));
            }
            else {
                throwError(new Error(`Could not get ${dataModelName} by id ${dataModelId}. ${this.invalidDataModelId}`));
            }
        }
        else {
            return throwError(new Error(`Could not delete ${dataModelName} by id ${dataModelId}. ${this.invalidDataModelName}`));
        }
    }
    //PATCH /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}/{dataModelId}
    /**
     *
     * @param dataModelName Data model name which is to be update
     * @param dataModelId Data model id which is to be updated
     * @param dataModelObj Data Model object which is to be inserted
     */
    updateById(dataModelName, dataModelId, dataModelObj) {
        if (dataModelName) {
            if (dataModelId) {
                // const modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}/${dataModelId}`;
                const modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName + "/" + dataModelId;
                var dmObj = Object.assign({}, dataModelObj);
                delete dmObj['_id'];
                return this.http.patch(modelNameUrl, dmObj).pipe(map((value, index) => {
                    return value;
                }), catchError(error => {
                    return throwError(error);
                }));
            }
            else {
                throwError(new Error(`Could not get ${dataModelName} by id ${dataModelId}. ${this.invalidDataModelId}`));
            }
        }
        else {
            return throwError(new Error(`Could not delete ${dataModelName} by id ${dataModelId}. ${this.invalidDataModelName}`));
        }
    }
    toQueryString(obj) {
        const parts = [];
        for (const i in obj) {
            if (obj.hasOwnProperty(i) && this.checkIfValid(obj[i])) {
                parts.push((i) + '=' + JSON.stringify(obj[i]));
            }
        }
        return parts.join('&');
    }
    checkIfValid(value) {
        if (value === undefined || value == null) {
            return false;
        }
        else {
            return true;
        }
    }
    getDataSourceURL(dataModelName) {
        if (!this.dmDs) {
            this.dmDs = window['neutrinos']['dataSource'];
        }
        const dsDm = this.dmDs[dataModelName];
        const properties = this.systemService.properties;
        if (dsDm) {
            return properties.baseUrl + properties.tenantName + '/datamodel/' + dsDm + '/' + properties.appName + '/';
        }
        else {
            return this.systemService.getDataModelUrl();
        }
    }
}
NDataModelService.ɵfac = function NDataModelService_Factory(t) { return new (t || NDataModelService)(ɵngcc0.ɵɵinject(ɵngcc2.HttpClient)); };
NDataModelService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NDataModelService, factory: NDataModelService.ɵfac });
NDataModelService.ctorParameters = () => [
    { type: HttpClient }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NDataModelService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc2.HttpClient }]; }, null); })();

class NHttpService {
    constructor(nHTTPLoader, inj, nLocalStorageService, nTokenService) {
        this.nHTTPLoader = nHTTPLoader;
        this.inj = inj;
        this.nLocalStorageService = nLocalStorageService;
        this.nTokenService = nTokenService;
        this.timeout = 90000;
        this.isRefreshingToken = false;
        this.tokenSubject = new BehaviorSubject(null);
        this.systemService = NSystemService.getInstance();
        this.nSessionStorage = new NSessionStorageService();
        this.appProperties = this.systemService.getVal('properties');
        this.nPubSubService = new NPubSubService();
    }
    intercept(req, next) {
        this.requestInterceptor();
        // Pass on the cloned request instead of the original request.
        return next.handle(this.requestOptions(req))
            .pipe(timeout(this.timeout), catchError(error => this.onCatch(error, req, next)), finalize(() => {
            this.onFinally();
        }));
    }
    updateToken(error, req, next) {
        if (this.appProperties.appAuthenticationStrategy === 'activeDirectory' ||
            this.appProperties.appAuthenticationStrategy === 'localAuth') {
            if (!this.isRefreshingToken) {
                this.isRefreshingToken = true;
                // Reset here so that the following requests wait until the token
                // comes back from the refreshToken call.
                this.tokenSubject.next(null);
                return this.refreshToken()
                    .pipe(switchMap((tokensObj) => {
                    if (tokensObj) {
                        this.nTokenService.updateTokens(tokensObj);
                        const newToken = tokensObj['accessToken'];
                        this.tokenSubject.next(newToken);
                        return next.handle(this.requestOptions(req));
                    }
                    return throwError(new Error('Can\'t refresh the token'));
                }), catchError(err => this.onCatchError(err)), finalize(() => this.isRefreshingToken = false));
            }
            else {
                return this.tokenSubject.pipe(filter(token => token != null), take(1), switchMap(token => next.handle(this.requestOptions(req))));
            }
        }
        else {
            return this.onCatchError(error);
        }
    }
    refreshToken() {
        const http = this.inj.get(HttpClient);
        const appProperties = this.systemService.getVal('properties');
        const refreshUrl = this.systemService.getAuthUrl() + appProperties.appName + '/refresh';
        const body = {
            'platformDetails': this.systemService.getPlatformDetails(this.systemService.checkDevice()),
            'userKey': this.nSessionStorage.getValue('userObj')['userKey'],
            'refreshToken': this.nSessionStorage.getValue('refreshToken')
        };
        body.platformDetails['uuid'] = this.nLocalStorageService.getValue('uuid');
        return http.post(refreshUrl, body);
    }
    /**
     * Request options.
     * @param options
     * @returns HttpRequest
     */
    requestOptions(req) {
        let headers = req.headers;
        if (req.headers == null) {
            headers = new HttpHeaders();
        }
        req = req.clone({
            url: this.getFullUrl(req.url),
            headers: headers
        });
        const baseUrl = NSystemService.getInstance().getVal('baseUrl');
        const isArt = (baseUrl !== '' && req.url.includes(baseUrl));
        return isArt ? this.addDefaultHeaders(req) : req;
    }
    /**
    * Default options.
    * @param options
    * @returns HttpHeadedrs
    */
    addDefaultHeaders(req) {
        /**
         * TODO: Add all default Headers over here
         */
        if (!req.headers.has('Access-Control-Allow-Origin')) {
            req.headers = req.headers.set('Access-Control-Allow-Origin', '*');
        }
        if (!req.headers.has('Content-Type')) {
            req.headers = req.headers.set('Content-Type', 'application/json');
        }
        else if (req.headers.has('Content-Type') && (req.headers.get('Content-Type') === 'no-content')) {
            req.headers = req.headers.delete('Content-Type');
        }
        if (!req.headers.has('Accept')) {
            req.headers = req.headers.set('Accept', 'application/json');
        }
        if (!req.headers.has('Authorization')) {
            this.appProperties = this.systemService.getVal('properties');
            if (this.appProperties && this.appProperties.appAuthenticationStrategy === 'basicAuth') {
                let username, password;
                if (this.appProperties.basicAuthUser && this.appProperties.basicAuthPassword) {
                    username = this.appProperties.basicAuthUser;
                    password = this.appProperties.basicAuthPassword;
                }
                else {
                    username = "bhive-art-proxyuser";
                    password = "password";
                    console.warn("Authentication strategy: Basic Auth. basicAuthUser and basicAuthPassword are not configured in environment. Setting default values.");
                }
                req.headers = req.headers.set('Authorization', 'Basic ' + btoa(username + ":" + password));
            }
            else if (this.appProperties && (this.appProperties.appAuthenticationStrategy === 'activeDirectory' ||
                this.appProperties.appAuthenticationStrategy === 'localAuth')) {
                if (this.nSessionStorage.getValue('accessToken')) {
                    req.headers = req.headers.set('Authorization', 'Bearer ' + this.nSessionStorage.getValue('accessToken'));
                }
            }
        }
        return req;
    }
    /**
     * Build API url.
     * @param url
     * @returns string
     */
    getFullUrl(url) {
        // return full URL to API here
        return url;
    }
    /**
     * Request interceptor.
     */
    requestInterceptor() {
        this.nHTTPLoader.isHTTPRequestInProgress(true);
    }
    /**
     * Response interceptor.
     */
    responseInterceptor() {
        this.nHTTPLoader.isHTTPRequestInProgress(false);
    }
    /**
      * Error handler.
      * @param error
      * @param caught
      * @returns ErrorObservable
      */
    onCatch(error, req, next) {
        if (error instanceof HttpErrorResponse) {
            if (error.status === 403 && error.error.message === 'jwt expired') {
                return this.updateToken(error, req, next);
            }
            else {
                return this.onSubscribeError(error);
            }
        }
        else {
            return this.onSubscribeError(error);
        }
    }
    /**
     * onSubscribeError
     * @param error
     */
    onSubscribeError(err) {
        this.nHTTPLoader.alertError(err);
        return this.onCatchError(err);
    }
    /**
     * onFinally
     */
    onFinally() {
        this.responseInterceptor();
    }
    onCatchError(error) {
        return throwError(error);
    }
}
NHttpService.ɵfac = function NHttpService_Factory(t) { return new (t || NHttpService)(ɵngcc0.ɵɵinject(NHTTPLoaderService), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(NLocalStorageService), ɵngcc0.ɵɵinject(NTokenService)); };
NHttpService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NHttpService, factory: NHttpService.ɵfac });
NHttpService.ctorParameters = () => [
    { type: NHTTPLoaderService },
    { type: Injector },
    { type: NLocalStorageService },
    { type: NTokenService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NHttpService, [{
        type: Injectable
    }], function () { return [{ type: NHTTPLoaderService }, { type: ɵngcc0.Injector }, { type: NLocalStorageService }, { type: NTokenService }]; }, null); })();

class NSnackbarService {
    constructor(nPubSubService) {
        this.nPubSubService = nPubSubService;
        this.snackService = new Subject();
        if (NSystemService.getInstance().getVal('useDefaultExceptionUI')) {
            this.snackBarListner = this.nPubSubService.$sub('openSnackBar', (msg) => {
                this.openSnackBar(msg);
            });
        }
    }
    get() {
        return this.snackService.asObservable();
    }
    add(data) {
        this.snackService.next({
            action: 'add',
            data: data
        });
    }
    remove(id) {
        this.snackService.next({ action: 'remove', id: id });
    }
    clear() {
        this.snackService.next({ action: 'clear' });
    }
    openSnackBar(message, timeout) {
        this.add({
            msg: message,
            timeout: timeout || 5000,
            action: {
                text: 'Close',
                onClick: (snack) => {
                },
            },
            onAdd: (snack) => {
            },
            onRemove: (snack) => {
            }
        });
    }
}
NSnackbarService.ɵfac = function NSnackbarService_Factory(t) { return new (t || NSnackbarService)(ɵngcc0.ɵɵinject(NPubSubService)); };
NSnackbarService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NSnackbarService, factory: NSnackbarService.ɵfac });
NSnackbarService.ctorParameters = () => [
    { type: NPubSubService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NSnackbarService, [{
        type: Injectable
    }], function () { return [{ type: NPubSubService }]; }, null); })();

class SnackComponent {
}
SnackComponent.ɵfac = function SnackComponent_Factory(t) { return new (t || SnackComponent)(); };
SnackComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SnackComponent, selectors: [["n-snack"]], inputs: { background: "background", color: "color", customClass: "customClass" }, ngContentSelectors: _c2, decls: 2, vars: 6, consts: [[1, "snack", 3, "ngStyle", "ngClass"]], template: function SnackComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction2(2, _c0, ctx.background ? ctx.background : "#323232", ctx.color ? ctx.color : "#fff"))("ngClass", ɵngcc0.ɵɵpureFunction0(5, _c1));
    } }, directives: [ɵngcc4.NgStyle, ɵngcc4.NgClass], styles: [_c4] });
SnackComponent.propDecorators = {
    background: [{ type: Input }],
    color: [{ type: Input }],
    customClass: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SnackComponent, [{
        type: Component,
        args: [{
                selector: 'n-snack',
                template: `
     <div class="snack" [ngStyle]="{background: background ? background : '#323232' , color: color ? color : '#fff'}" [ngClass]=" ['snackbar-layout', 'customClass' ]">
          <ng-content></ng-content>
       </div> 
  `,
                styles: [".snack-action{color:#2196f3;cursor:pointer;font-weight:700}.container{display:flex;flex-direction:row;flex-wrap:wrap}.child{flex:1 0;margin-right:.5em;width:60%}.snackbars.bottom-center{align-items:middle}.snackbars{display:flex;display:inline;font-family:Roboto;letter-spacing:1px;max-width:100%;position:fixed;word-wrap:break-word;z-index:99999}.snackbars.bottom-center{align-items:center;bottom:1px;left:50%;transform:translate(-50%)}.snack{border-radius:.3em;max-height:50vh;overflow:auto;padding:1em}"]
            }]
    }], null, { background: [{
            type: Input
        }], color: [{
            type: Input
        }], customClass: [{
            type: Input
        }] }); })();

class SnackbarComponent {
    constructor(snackbarService) {
        this.snackbarService = snackbarService;
        this.max = 1;
        this.onAdd = new EventEmitter();
        this.onRemove = new EventEmitter();
        this.onClear = new EventEmitter();
        this.snacks = [];
        this.snackbarService.get()
            .subscribe(snack => {
            if (snack.action === 'add') {
                this.add(snack.data);
            }
            else if (snack.action === 'remove') {
                this.remove(snack.id);
            }
            else if (snack.action === 'clear') {
                this.clear();
            }
        });
    }
    add(snack) {
        let timeout;
        const id = this.uuid();
        if (this.max && this.max > 0 && this.snacks.length === this.max) {
            this.remove(this.snacks[0].id);
        }
        if (snack.timeout || this.timeout) {
            timeout = setTimeout(() => {
                this.remove(id);
            }, snack.timeout || this.timeout);
        }
        const data = Object.assign({ id: id, timeoutObj: timeout }, snack);
        if (snack.action) {
            const that = this;
            const fcn = snack.action.onClick || new Function();
            snack.action.onClick = () => {
                fcn(data);
                that.remove(id);
            };
        }
        if (snack.onAdd) {
            snack.onAdd(data);
        }
        if (this.onAdd) {
            this.onAdd.emit(data);
        }
        this.snacks.push(data);
    }
    remove(id) {
        const snack = this.snacks.find(obj => obj.id === id);
        if (snack) {
            if (snack.onRemove) {
                snack.onRemove(snack);
            }
            if (this.onRemove) {
                this.onRemove.emit(snack);
            }
            if (snack.timeoutObj) {
                clearTimeout(snack.timeoutObj);
            }
        }
        this.snacks = this.snacks.filter(obj => obj.id !== id);
    }
    clear() {
        // this.snacks.forEach(snack => {
        //   this.remove(snack.id);
        // });
        this.snacks = [];
        if (this.onClear) {
            this.onClear.emit(true);
        }
    }
    uuid() {
        // tslint:disable:no-bitwise
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
        // tslint:enable:no-bitwise
    }
    calcTextColor(background) {
        if (!background) {
            return null;
        }
        function hexToRgb(hex) {
            const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, (m, r, g, b) => {
                return r + r + g + g + b + b;
            });
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        const rgb = hexToRgb(background);
        if (!rgb) {
            return null;
        }
        const color = [rgb.r / 255, rgb.g / 255, rgb.b / 255];
        for (let i = 0; i < color.length; ++i) {
            if (color[i] <= 0.03928) {
                color[i] = color[i] / 12.92;
            }
            else {
                color[i] = Math.pow((color[i] + 0.055) / 1.055, 2.4);
            }
        }
        const l = 0.2126 * color[0] + 0.7152 * color[1] + 0.0722 * color[2];
        if (l > 0.179) {
            return '#000';
        }
        else {
            return '#fff';
        }
    }
}
SnackbarComponent.ɵfac = function SnackbarComponent_Factory(t) { return new (t || SnackbarComponent)(ɵngcc0.ɵɵdirectiveInject(NSnackbarService)); };
SnackbarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SnackbarComponent, selectors: [["n-snackbar"]], inputs: { max: "max", position: "position", background: "background", accent: "accent", color: "color", customClass: "customClass", timeout: "timeout" }, outputs: { onAdd: "onAdd", onRemove: "onRemove", onClear: "onClear" }, decls: 2, vars: 2, consts: [[1, "snackbars", 3, "ngClass"], [3, "background", "customClass", "color", 4, "ngFor", "ngForOf"], [3, "background", "customClass", "color"], [1, "container"], [1, "snack-text", "child"], ["class", "snack-action", 3, "ngStyle", "click", 4, "ngIf"], [1, "snack-action", 3, "ngStyle", "click"]], template: function SnackbarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, SnackbarComponent_n_snack_1_Template, 5, 5, "n-snack", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.position || "bottom-center");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.snacks);
    } }, directives: [ɵngcc4.NgClass, ɵngcc4.NgForOf, SnackComponent, ɵngcc4.NgIf, ɵngcc4.NgStyle], styles: [_c4] });
SnackbarComponent.ctorParameters = () => [
    { type: NSnackbarService }
];
SnackbarComponent.propDecorators = {
    position: [{ type: Input }],
    max: [{ type: Input }],
    background: [{ type: Input }],
    accent: [{ type: Input }],
    color: [{ type: Input }],
    customClass: [{ type: Input }],
    timeout: [{ type: Input }],
    onAdd: [{ type: Output }],
    onRemove: [{ type: Output }],
    onClear: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SnackbarComponent, [{
        type: Component,
        args: [{
                selector: 'n-snackbar',
                template: `
      <div class="snackbars" [ngClass]="position || 'bottom-center'">
          <n-snack   *ngFor="let snackbar of snacks" [background]="snackbar.background || background"
                        [customClass]="snackbar.customClass || customClass"
                        [color]="snackbar.color || color || calcTextColor(snackbar.background || background)">
              <div class="container">
              <div class="snack-text child" >
                  {{snackbar.msg}}
              </div>
              <div *ngIf="snackbar.action.text" class="snack-action" (click)="snackbar.action.onClick()"
                   [ngStyle]="{color: snackbar.action.color || accent}">
                  {{snackbar.action.text}}
              </div>
              </div>
          </n-snack>
      </div>
  `,
                styles: [".snack-action{color:#2196f3;cursor:pointer;font-weight:700}.container{display:flex;flex-direction:row;flex-wrap:wrap}.child{flex:1 0;margin-right:.5em;width:60%}.snackbars.bottom-center{align-items:middle}.snackbars{display:flex;display:inline;font-family:Roboto;letter-spacing:1px;max-width:100%;position:fixed;word-wrap:break-word;z-index:99999}.snackbars.bottom-center{align-items:center;bottom:1px;left:50%;transform:translate(-50%)}.snack{border-radius:.3em;max-height:50vh;overflow:auto;padding:1em}"]
            }]
    }], function () { return [{ type: NSnackbarService }]; }, { max: [{
            type: Input
        }], onAdd: [{
            type: Output
        }], onRemove: [{
            type: Output
        }], onClear: [{
            type: Output
        }], position: [{
            type: Input
        }], background: [{
            type: Input
        }], accent: [{
            type: Input
        }], color: [{
            type: Input
        }], customClass: [{
            type: Input
        }], timeout: [{
            type: Input
        }] }); })();

function startupServiceFactory(startupService) {
    const res = () => {
        // console.log('module before initstorage call');
        return startupService.initStorage();
    };
    return res;
}
function NgForageFactory(ngForageConfig) {
    // @ts-ignore
    return new NgForage({}, new InstanceFactory(ngForageConfig));
}
class NeutrinosSeedServicesModule {
}
NeutrinosSeedServicesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NeutrinosSeedServicesModule });
NeutrinosSeedServicesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NeutrinosSeedServicesModule_Factory(t) { return new (t || NeutrinosSeedServicesModule)(); }, providers: [
        {
            provide: HTTP_INTERCEPTORS,
            useClass: NHttpService,
            multi: true
        },
        {
            // Provider for APP_INITIALIZER
            provide: APP_INITIALIZER,
            useFactory: startupServiceFactory,
            deps: [NLocalStorageService],
            multi: true
        },
        {
            provide: NgForage,
            useFactory: NgForageFactory,
            deps: [
                NgForageConfig
            ]
        },
        NAuthGuardService,
        NDataModelService,
        NHttpService,
        NHTTPLoaderService,
        NLocalStorageService,
        NLoginService,
        NLogoutService,
        NNotificationService,
        NSnackbarService,
        NPubSubService,
        NSessionStorageService,
        NTokenService
    ], imports: [[
            CommonModule,
            HttpClientModule,
            RouterModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NeutrinosSeedServicesModule, { declarations: function () { return [SnackComponent, SnackbarComponent]; }, imports: function () { return [CommonModule,
        HttpClientModule,
        RouterModule]; }, exports: function () { return [SnackComponent, SnackbarComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NeutrinosSeedServicesModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    HttpClientModule,
                    RouterModule
                ],
                providers: [
                    {
                        provide: HTTP_INTERCEPTORS,
                        useClass: NHttpService,
                        multi: true
                    },
                    {
                        // Provider for APP_INITIALIZER
                        provide: APP_INITIALIZER,
                        useFactory: startupServiceFactory,
                        deps: [NLocalStorageService],
                        multi: true
                    },
                    {
                        provide: NgForage,
                        useFactory: NgForageFactory,
                        deps: [
                            NgForageConfig
                        ]
                    },
                    NAuthGuardService,
                    NDataModelService,
                    NHttpService,
                    NHTTPLoaderService,
                    NLocalStorageService,
                    NLoginService,
                    NLogoutService,
                    NNotificationService,
                    NSnackbarService,
                    NPubSubService,
                    NSessionStorageService,
                    NTokenService
                ],
                declarations: [
                    SnackComponent,
                    SnackbarComponent
                ],
                exports: [
                    SnackComponent,
                    SnackbarComponent
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { NAuthGuardService, NDataModelService, NHTTPLoaderService, NHttpService, NLocalStorageService, NLoginService, NLogoutService, NNotificationService, NPubSubService, NSessionStorageService, NSnackbarService, NSystemService, NTokenService, NUtility, NeutrinosSeedServicesModule, NgForageFactory, SnackComponent, SnackbarComponent, startupServiceFactory };

//# sourceMappingURL=neutrinos-seed-services.js.map