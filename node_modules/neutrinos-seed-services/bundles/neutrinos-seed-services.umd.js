(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/router'), require('rxjs/operators'), require('@angular/common/http'), require('platform'), require('ngforage'), require('rxjs'), require('firebase')) :
    typeof define === 'function' && define.amd ? define('neutrinos-seed-services', ['exports', '@angular/core', '@angular/common', '@angular/router', 'rxjs/operators', '@angular/common/http', 'platform', 'ngforage', 'rxjs', 'firebase'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['neutrinos-seed-services'] = {}, global.ng.core, global.ng.common, global.ng.router, global.rxjs.operators, global.ng.common.http, global.platform, global.ngforage, global.rxjs, global.firebase));
}(this, (function (exports, core, common, router, operators, http, platform, ngforage, rxjs, firebase) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var firebase__default = /*#__PURE__*/_interopDefaultLegacy(firebase);

    // @dynamic
    var NSystemService = /** @class */ (function () {
        function NSystemService() {
            this._deviceType = this.checkDevice();
        }
        NSystemService.getInstance = function () {
            if (!this.instance) {
                this.instance = new NSystemService();
            }
            return this.instance;
        };
        /**
         * Seter and getter for the environments
         */
        // set environments(properties) {
        //   console.log(properties);
        //   NSystemService.envProperties = properties;
        //   this.properties = this.getVal('properties');
        // }
        // get environments() {
        //   return NSystemService.envProperties;
        // }
        /**
         * Returna 'mobile' or 'browser' based on the platform
         */
        NSystemService.prototype.checkDevice = function () {
            if (window['device'] && (window['device']['platform'] != 'browser' || window['device']['platform'] != 'Browser')) {
                return 'mobile';
            }
            else if (window['device'] && (window['device']['platform'] == 'browser' || window['device']['platform'] == 'Browser')) {
                return 'cordova_browser';
            }
            else {
                return 'browser';
            }
        };
        Object.defineProperty(NSystemService.prototype, "deviceType", {
            get: function () {
                return this._deviceType;
            },
            enumerable: false,
            configurable: true
        });
        NSystemService.prototype.getVal = function (key) {
            if (!NSystemService.envProperties) {
                NSystemService.envProperties = window['neutrinos']['environments'];
                this.properties = NSystemService.envProperties.properties;
            }
            if (key == 'properties') {
                if (NSystemService.envProperties) {
                    return NSystemService.envProperties.properties;
                }
                else {
                    return undefined;
                }
            }
            else {
                if (NSystemService.envProperties && NSystemService.envProperties.properties) {
                    return NSystemService.envProperties.properties[key];
                }
                else {
                    return undefined;
                }
            }
        };
        NSystemService.prototype.isAndroid = function () {
            if (window['device'] && window['device']['platform'] == 'Android') {
                return true;
            }
            else {
                return false;
            }
        };
        NSystemService.prototype.isIOS = function () {
            if (window['device'] && window['device']['platform'] == 'iOS') {
                return true;
            }
            else {
                return false;
            }
        };
        NSystemService.prototype.getAndroidVersion = function () {
            if (this.isAndroid()) {
                return window['device']['version'];
            }
            else {
                return '';
            }
        };
        NSystemService.prototype.getAuthUrl = function () {
            // this.properties = this.getVal('properties');
            return this.properties.baseUrl + this.properties.tenantName + '/auth/';
        };
        NSystemService.prototype.getTenantUrl = function () {
            return this.properties.baseUrl + this.properties.tenantName + '/';
        };
        NSystemService.prototype.getAppUrl = function () {
            return this.properties.baseUrl + this.properties.tenantName + '/proxy/' + this.properties.appName + '/';
        };
        NSystemService.prototype.getProxyUrl = function () {
            return this.properties.baseUrl + this.properties.tenantName + '/proxy/';
        };
        NSystemService.prototype.getDataModelUrl = function () {
            return this.properties.baseUrl + this.properties.tenantName + '/datamodel/' + this.properties.appDataSource + '/' + this.properties.appName + '/';
        };
        NSystemService.prototype.getFileIOUrl = function () {
            return this.properties.baseUrl + this.properties.tenantName + '/fileio/' +
                this.properties.appDataSource + '/' + this.properties.appName + '/';
        };
        NSystemService.prototype.getPlatformDetails = function (type) {
            var pDetails = {
                platform: platform.os.family,
                platformVersion: platform.os.version,
            };
            if (type === 'browser') {
                return Object.assign(pDetails, {
                    type: 'browser',
                    browser: platform.name,
                    browserVersion: platform.version,
                });
            }
            else if (type === 'mobile' || type === 'cordova_browser') {
                return Object.assign(pDetails, {
                    type: 'mobile',
                    model: window['device'].model,
                    manufacturer: window['device'].manufacturer,
                    isVirtual: window['device'].isVirtual
                });
            }
        };
        return NSystemService;
    }());

    var NSessionStorageService = /** @class */ (function () {
        function NSessionStorageService() {
            NSessionStorageService.sessionStorageCache = sessionStorage;
        }
        NSessionStorageService.prototype.getSessionStorage = function () {
            return NSessionStorageService.sessionStorageCache;
        };
        NSessionStorageService.prototype.setValue = function (key, value) {
            NSessionStorageService.sessionStorageCache[key] = value;
            sessionStorage.setItem(key, value);
        };
        NSessionStorageService.prototype.getValue = function (key) {
            if (!NSessionStorageService.sessionStorageCache[key]) {
                return null;
            }
            try {
                var obj = NSessionStorageService.sessionStorageCache[key];
                return JSON.parse(obj);
            }
            catch (error) {
                return NSessionStorageService.sessionStorageCache[key];
            }
        };
        NSessionStorageService.prototype.remove = function (key) {
            if (NSessionStorageService.sessionStorageCache.hasOwnProperty(key)) {
                delete NSessionStorageService.sessionStorageCache[key];
                sessionStorage.removeItem(key);
            }
        };
        NSessionStorageService.prototype.clearSessionStorage = function () {
            NSessionStorageService.sessionStorageCache = {};
            sessionStorage.clear();
        };
        return NSessionStorageService;
    }());
    NSessionStorageService.sessionStorageCache = {};
    NSessionStorageService.decorators = [
        { type: core.Injectable }
    ];
    NSessionStorageService.ctorParameters = function () { return []; };

    var NUtility = /** @class */ (function () {
        function NUtility() {
        }
        NUtility.prototype.generateUUID = function () {
            return this.__s4() + this.__s4() + '-' + this.__s4() + '-' + this.__s4() + '-' + this.__s4() + '-' + this.__s4() + this.__s4() + this.__s4();
        };
        NUtility.prototype.__s4 = function () {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        };
        return NUtility;
    }());

    var NLocalStorageService = /** @class */ (function () {
        function NLocalStorageService(ngfConfig, ngf, ngfCache) {
            this.ngfConfig = ngfConfig;
            this.ngf = ngf;
            this.ngfCache = ngfCache;
            this.storageCache = {};
        }
        NLocalStorageService.prototype.initStorage = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (window['cordova']) {
                    _this.initNgForage();
                }
                _this.ngf.iterate(function (value, key, iteratonNumber) {
                    _this.storageCache[key] = value;
                }).then(function (result) {
                    _this.checkDeviceId();
                    return resolve('iteration is completed');
                }).catch(function (error) {
                    return reject(error);
                });
            });
        };
        NLocalStorageService.prototype.getStorage = function () {
            return this.storageCache;
        };
        NLocalStorageService.prototype.setValue = function (key, value) {
            if (window['cordova']) {
                this.initNgForage();
            }
            this.storageCache[key] = value;
            return this.ngf.setItem(key, value).then(function (result) {
                return result;
            }, function (error) {
                console.log(error);
            });
        };
        NLocalStorageService.prototype.getValue = function (key) {
            if (!this.storageCache[key]) {
                return null;
            }
            try {
                var obj = this.storageCache[key];
                return JSON.parse(obj);
            }
            catch (error) {
                return this.storageCache[key];
            }
        };
        NLocalStorageService.prototype.remove = function (key) {
            var _this = this;
            delete this.storageCache[key];
            if (window['cordova']) {
                this.initNgForage();
            }
            this.ngf.removeItem(key).then(function (fulfilled) {
                delete _this.ngf[key];
            }).catch(function (error) {
                console.error('Could not remove', key);
            });
        };
        NLocalStorageService.prototype.clear = function () {
            this.storageCache = {};
            this.ngf.clear();
        };
        NLocalStorageService.prototype.pluginCheck = function () {
            if (window['cordova'] && window['NativeStorage']) {
                this.nativeStorageI = window['NativeStorage'];
                // return true;
            }
            // this.initStorage();
        };
        NLocalStorageService.prototype.getItemNs = function (key) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (window['cordova'] && window['NativeStorage']) {
                    _this.nativeStorageI.getItem(key, function (result) {
                        resolve(result);
                    }, function (error) {
                        reject(error);
                    });
                }
            });
        };
        NLocalStorageService.prototype.setItemNs = function (key, value) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (window['cordova'] && window['NativeStorage']) {
                    _this.nativeStorageI.setItem(key, value, function (result) {
                        resolve(result);
                    }, function (error) {
                        reject(error);
                    });
                }
            });
        };
        NLocalStorageService.prototype.removeItemNs = function (key) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (window['cordova'] && window['NativeStorage']) {
                    _this.nativeStorageI.remove(key, function (result) {
                        resolve(result);
                    }, function (error) {
                        reject(error);
                    });
                }
            });
        };
        NLocalStorageService.prototype.clearNs = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                if (window['cordova'] && window['NativeStorage']) {
                    _this.nativeStorageI.clear(function (result) {
                        resolve(result);
                    }, function (error) {
                        reject(error);
                    });
                }
            });
        };
        NLocalStorageService.prototype.initNgForage = function () {
            var driverType = window['neutrinos']['environments']['properties']['NGFORAGE_MOBILE_DRIVER'] ? window['neutrinos']['environments']['properties']['NGFORAGE_MOBILE_DRIVER'] : "INDEXED_DB";
            this.ngfConfig.configure({
                name: 'MyApp',
                driver: [
                    ngforage.Driver[driverType],
                ]
            });
        };
        NLocalStorageService.prototype.promiseReflect = function (promise) {
            return promise.then(function (resolved) { return { v: resolved, status: 'resolved' }; }, function (error) { return { e: error, status: 'rejected' }; });
        };
        NLocalStorageService.prototype.clearLocalStorage = function () {
            this.remove('userObj');
            this.remove('accessToken');
            this.remove('refreshToken');
            this.remove('registrationId');
        };
        /**
         * Due to timing issues and circular dependency checkDeviceId is moved from NSystemService
        */
        NLocalStorageService.prototype.checkDeviceId = function () {
            var _this = this;
            if (NSystemService.getInstance().checkDevice() === 'browser') {
                this._deviceUUID = this.getValue('uuid');
                if (!this._deviceUUID) {
                    this._deviceUUID = new NUtility().generateUUID();
                    this.setValue('uuid', this._deviceUUID);
                }
            }
            else {
                window['plugins'].uniqueDeviceID.get(function (uuid) {
                    _this._deviceUUID = uuid;
                    _this.setValue('uuid', _this._deviceUUID);
                });
            }
            return this._deviceUUID;
        };
        Object.defineProperty(NLocalStorageService.prototype, "deviceUUID", {
            get: function () {
                return this._deviceUUID;
            },
            enumerable: false,
            configurable: true
        });
        return NLocalStorageService;
    }());
    NLocalStorageService.decorators = [
        { type: core.Injectable }
    ];
    NLocalStorageService.ctorParameters = function () { return [
        { type: ngforage.NgForageConfig },
        { type: ngforage.NgForage },
        { type: ngforage.NgForageCache }
    ]; };

    var NTokenService = /** @class */ (function () {
        // nLocalStorageService: NLocalStorageService;
        function NTokenService(nLocalStorageService) {
            this.nLocalStorageService = nLocalStorageService;
            this.nSessionStorage = new NSessionStorageService();
            // this.nLocalStorageService = new NLocalStorageService();
        }
        NTokenService.prototype.updateTokens = function (tokensObj, isRemember) {
            var userObj = this.decodeToken(tokensObj['accessToken']);
            this.nSessionStorage.setValue('accessToken', tokensObj['accessToken']);
            this.nSessionStorage.setValue('refreshToken', tokensObj['refreshToken']);
            this.nSessionStorage.setValue('userObj', JSON.stringify(userObj));
            if ((isRemember || this.nLocalStorageService.getValue('accessToken'))) {
                this.nLocalStorageService.setValue('accessToken', tokensObj['accessToken']);
                this.nLocalStorageService.setValue('refreshToken', tokensObj['refreshToken']);
                this.nLocalStorageService.setValue('userObj', JSON.stringify(userObj));
            }
        };
        NTokenService.prototype.updateSessionStorage = function () {
            this.updateTokens(this.nLocalStorageService.getStorage(), true);
        };
        NTokenService.prototype.urlBase64Decode = function (str) {
            var output = str.replace(/-/g, '+').replace(/_/g, '/');
            switch (output.length % 4) {
                case 0: {
                    break;
                }
                case 2: {
                    output += '==';
                    break;
                }
                case 3: {
                    output += '=';
                    break;
                }
                default: {
                    throw 'Illegal base64url string!';
                }
            }
            return this.b64DecodeUnicode(output);
        };
        // credits for decoder goes to https://github.com/atk
        NTokenService.prototype.b64decode = function (str) {
            var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var output = '';
            str = String(str).replace(/=+$/, '');
            if (str.length % 4 == 1) {
                throw new Error("'atob' failed: The string to be decoded is not correctly encoded.");
            }
            for (
            // initialize result and counters
            var bc = 0, bs = void 0, buffer = void 0, idx = 0; 
            // get next character
            buffer = str.charAt(idx++); 
            // character found in table? initialize bit storage and add its ascii value;
            ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
                // and if not first of each 4 characters,
                // convert the first 8 bits to one ascii character
                bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
                // try to find character in table (0-63, not found => -1)
                buffer = chars.indexOf(buffer);
            }
            return output;
        };
        // https://developer.mozilla.org/en/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem
        NTokenService.prototype.b64DecodeUnicode = function (str) {
            return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), function (c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
        };
        NTokenService.prototype.decodeToken = function (token) {
            var parts = token.split('.');
            if (parts.length !== 3) {
                throw new Error('JWT must have 3 parts');
            }
            var decoded = this.urlBase64Decode(parts[1]);
            if (!decoded) {
                throw new Error('Cannot decode the token');
            }
            return JSON.parse(decoded);
        };
        NTokenService.prototype.getTokenExpirationDate = function (token) {
            var decoded;
            decoded = this.decodeToken(token);
            if (!decoded.hasOwnProperty('exp')) {
                return null;
            }
            var date = new Date(0); // The 0 here is the key, which sets the date to the epoch
            date.setUTCSeconds(decoded.exp);
            return date;
        };
        NTokenService.prototype.isTokenExpired = function (token, offsetSeconds) {
            var date = this.getTokenExpirationDate(token);
            offsetSeconds = offsetSeconds || 0;
            if (date == null) {
                return false;
            }
            // Token expired?
            return !(date.valueOf() > (new Date().valueOf() + (offsetSeconds * 1000)));
        };
        return NTokenService;
    }());
    NTokenService.decorators = [
        { type: core.Injectable }
    ];
    NTokenService.ctorParameters = function () { return [
        { type: NLocalStorageService }
    ]; };

    var ServiceName = "PubSub Service";
    var NPubSubService = /** @class */ (function () {
        function NPubSubService() {
            this.events = {};
        }
        NPubSubService.prototype.$sub = function (event, callback, error, complete) {
            if (!event) {
                throw new Error("[" + ServiceName + "] => Subscription method must get event name.");
            }
            if (this.events[event] === undefined) {
                this.events[event] = new rxjs.Subject();
            }
            if (typeof callback !== 'function') {
                return this.events[event].asObservable();
            }
            else {
                return this.events[event].asObservable().subscribe(callback, error, complete);
            }
        };
        NPubSubService.prototype.$pub = function (event, eventObject) {
            if (!event) {
                throw new Error("[" + ServiceName + "] => Publish method must get event name.");
            }
            else if (!this.events[event]) {
                return;
            }
            this.events[event].next(eventObject);
        };
        return NPubSubService;
    }());
    NPubSubService.decorators = [
        { type: core.Injectable }
    ];
    NPubSubService.ctorParameters = function () { return []; };

    var NLogoutService = /** @class */ (function () {
        // nLocalStorageService = new NLocalStorageService();
        function NLogoutService(nLocalStorageService) {
            this.nLocalStorageService = nLocalStorageService;
            this.nSessionStorage = new NSessionStorageService();
        }
        NLogoutService.prototype.logout = function () {
            this.nSessionStorage.clearSessionStorage();
            this.nLocalStorageService.clearLocalStorage();
            return true;
        };
        return NLogoutService;
    }());
    NLogoutService.decorators = [
        { type: core.Injectable }
    ];
    NLogoutService.ctorParameters = function () { return [
        { type: NLocalStorageService }
    ]; };

    // import { NSnackbarService } from './snackbar/service/snackbar.service';
    var NHTTPLoaderService = /** @class */ (function () {
        function NHTTPLoaderService(nLogoutService, nPubSubService) {
            this.nLogoutService = nLogoutService;
            this.nPubSubService = nPubSubService;
            this.pendingRequests = 0;
            this.showLoading = false;
            this._isHTTPRequestInProgress = new rxjs.Subject();
            this._isHTTPRequestInProgress$ = this._isHTTPRequestInProgress.asObservable();
        }
        NHTTPLoaderService.prototype.isHTTPRequestInProgress = function (bool) {
            if (bool) {
                this.pendingRequests++;
                if (!this.showLoading) {
                    this._isHTTPRequestInProgress.next(bool);
                }
                this.showLoading = true;
            }
            else {
                this.pendingRequests--;
                if (this.pendingRequests <= 0) {
                    if (this.showLoading) {
                        this._isHTTPRequestInProgress.next(bool);
                    }
                    this.showLoading = false;
                }
            }
        };
        NHTTPLoaderService.prototype.alertError = function (error) {
            if (error.status < 200 || error.status > 500) {
                if (error.status === 0) {
                    this.nPubSubService.$pub('openSnackBar', 'Connectivity issue');
                }
                else {
                    this.nPubSubService.$pub('openSnackBar', 'Response failure');
                }
            }
            else if (error.status === 401) {
                this.nLogoutService.logout();
                if (error.error) {
                    this.nPubSubService.$pub('openSnackBar', error.error);
                }
                else {
                    this.nPubSubService.$pub('openSnackBar', error);
                }
            }
            else if (error.error) {
                if (error.error instanceof Object) {
                    this.nPubSubService.$pub('openSnackBar', error.error.message);
                }
                else {
                    this.nPubSubService.$pub('openSnackBar', error.error);
                }
            }
            else {
                this.nPubSubService.$pub('openSnackBar', 'Response failure');
            }
        };
        return NHTTPLoaderService;
    }());
    NHTTPLoaderService.decorators = [
        { type: core.Injectable }
    ];
    NHTTPLoaderService.ctorParameters = function () { return [
        { type: NLogoutService },
        { type: NPubSubService }
    ]; };

    var NNotificationService = /** @class */ (function () {
        function NNotificationService(localStorageService, pubSubService, http, bHttpLoader) {
            var _this = this;
            this.localStorageService = localStorageService;
            this.pubSubService = pubSubService;
            this.http = http;
            this.bHttpLoader = bHttpLoader;
            // private static instance: NNotificationService;
            this.systemService = NSystemService.getInstance();
            this.possiblePushTypes = ['APNS', 'FCM'];
            this.firebaseSenderId = this.systemService.getVal('firebaseSenderId');
            this.isNotificationEnabled = this.systemService.getVal('isNotificationEnabled');
            this.appName = this.systemService.getVal('appName');
            this.deviceType = this.systemService.deviceType;
            this.sessionStorage = new NSessionStorageService();
            this.loginSubscribe = this.pubSubService.$sub('firebaseRegister', function () {
                _this.enableNotification();
            });
        }
        NNotificationService.prototype.ngOnInit = function () {
        };
        NNotificationService.prototype.enableNotification = function () {
            var _this = this;
            var pushType = this.getPushType(this.systemService.getVal('pushType'));
            document.addEventListener('deviceready', function (event) {
                if (_this.isNotificationEnabled) {
                    if (_this.deviceType && _this.deviceType != 'browser') {
                        _this.deviceType = _this.systemService.deviceType;
                        _this.checkPermission(pushType).then(function (res) {
                            if (res) {
                                _this.initializeNotifications(pushType);
                            }
                        });
                    }
                }
            });
            if (this.isNotificationEnabled && pushType !== 'APNS') {
                if (this.deviceType && this.deviceType == 'browser' && window['Notification']) {
                    this.initialiseWebPush();
                }
            }
        };
        NNotificationService.prototype.initialiseWebPush = function () {
            var __this = this;
            var messaging = firebase__default['default'].messaging();
            Notification.requestPermission()
                .then(function () {
                return messaging.getToken();
            })
                .then(function (token) {
                if (token) {
                    __this.sendRegDetails(token);
                }
            })
                .catch(function (err) {
                __this.bHttpLoader.alertError(err);
            });
            messaging.onMessage(function (payload) {
                if (payload['notification']) {
                    var notificationObj = payload['notification'];
                    var options = {
                        body: notificationObj.body,
                        icon: notificationObj.icon
                    };
                    // creating a native browser message
                    var notificationUI = new Notification(notificationObj.title, options);
                    notificationUI.onclick = function () {
                        window.focus(); // window is focused when the user clicks the notification using this
                    };
                }
            });
        };
        NNotificationService.prototype.checkPermission = function (pushType) {
            var _this = this;
            // Android & iOS only
            // Checks whether the push notification permission has been granted.
            return new Promise(function (resolve) {
                pushType = _this.getPushType(pushType);
                if ((_this.deviceType === 'Android' || _this.deviceType === 'iOS') && (pushType === 'FCM')) {
                    PushNotification.hasPermission(function (data) {
                        return resolve(data.isEnabled);
                    });
                }
                else if (_this.deviceType === 'iOS' && pushType === 'APNS') {
                    APNSPushNotification.hasPermission(function (data) {
                        return resolve(data.isEnabled);
                    });
                }
                else {
                    return resolve(true);
                }
            });
        };
        NNotificationService.prototype.initializeNotifications = function (pushType) {
            var _this = this;
            //pushType = pushType ? pushType : 'FCM';
            pushType = this.getPushType(pushType);
            var push;
            // Default if for FCM
            if (pushType === 'FCM') {
                push = window['PushNotification'].init({
                    android: {
                        senderID: this.firebaseSenderId
                    },
                    ios: {
                        alert: "true",
                        badge: "true",
                        sound: "true",
                        senderID: this.firebaseSenderId
                    },
                });
            }
            // New APNS plugin init
            else if (pushType === 'APNS') {
                push = window['APNSPushNotification'].init({
                    ios: {
                        alert: "true",
                        badge: "true",
                        sound: "true"
                    }
                });
            }
            push.on('registration', function (data) {
                // data.registrationId
                _this.sendRegDetails(data.registrationId);
            });
            // ToDo Christy get call back function from app user to change what happens once a notification arrives
            push.on('notification', function (data) {
                window['cordova'].plugins.notification.local.schedule({
                    title: data.title,
                    text: data.message,
                    sound: data.sound,
                    at: new Date().getTime()
                });
            });
            push.on('error', function (e) {
                // e.message
                console.error(e);
            });
        };
        NNotificationService.prototype.sendRegDetails = function (registrationId) {
            this.localStorageService.setValue('registrationId', registrationId);
            var url = this.systemService.getTenantUrl() + 'notification/' + this.systemService.getVal('appName') + '/register';
            var pushType = this.getPushType(this.systemService.getVal('pushType'));
            this.http.post(url, {
                'key': this.sessionStorage.getValue('userObj')['userKey'],
                'uuid': this.localStorageService.getValue('uuid'),
                'fbregid': registrationId,
                'pushType': pushType
            }).subscribe(function (result) {
                // this.pubSubService.$pub('FBRegComp');
            }, function (error) {
                console.log(error);
            });
        };
        NNotificationService.prototype.getPushType = function (currPushType) {
            var isValidPush = typeof currPushType !== 'undefined' && this.possiblePushTypes.includes(currPushType.toUpperCase());
            var pushType = isValidPush ? currPushType.toUpperCase() : 'FCM';
            return pushType;
        };
        NNotificationService.prototype.ngOnDestroy = function () {
            this.loginSubscribe.unSubscribe();
        };
        return NNotificationService;
    }());
    NNotificationService.decorators = [
        { type: core.Injectable }
    ];
    NNotificationService.ctorParameters = function () { return [
        { type: NLocalStorageService },
        { type: NPubSubService },
        { type: http.HttpClient },
        { type: NHTTPLoaderService }
    ]; };

    var NLoginService = /** @class */ (function () {
        function NLoginService(http, pubSubService, notificationService, nLocalStorageService, nTokenService) {
            this.http = http;
            this.pubSubService = pubSubService;
            this.notificationService = notificationService;
            this.nLocalStorageService = nLocalStorageService;
            this.nTokenService = nTokenService;
            this.loginCompleted = new core.EventEmitter();
            this.systemService = NSystemService.getInstance();
            // this.nTokenService = new NTokenService();
            this.nSessionStorage = new NSessionStorageService();
            // this.nLocalStorageService = new NLocalStorageService();
        }
        NLoginService.prototype.login = function (userName, password, isRemember) {
            var _this = this;
            this.appProperties = this.systemService.getVal('properties');
            this.loginUrl = this.systemService.getAuthUrl() + this.appProperties.appName;
            this.uuid = this.nLocalStorageService.getValue('uuid');
            if (!this.uuid) {
                this.uuid = this.nLocalStorageService.checkDeviceId();
            }
            this.details = {
                username: userName,
                password: password,
            };
            this.details.platformDetails = this.systemService.getPlatformDetails(this.systemService.checkDevice());
            this.details.platformDetails['uuid'] = this.uuid;
            return this.http.post(this.loginUrl, JSON.stringify(this.details)).pipe(operators.map(function (result) {
                var tokensObj = result;
                if (tokensObj) {
                    _this.nTokenService.updateTokens(tokensObj, isRemember);
                }
                // TODO chris array of supported pushes currently only support APNS and Firebase
                if ((_this.systemService.getVal('firebaseSenderId') != 'FIREBASE_SENDER_ID' && _this.systemService.getVal('firebaseAuthKey') != 'FIREBASE_AUTH_KEY')
                    || (_this.systemService.getVal('pushType') === 'APNS' && _this.systemService.isIOS())) {
                    _this.pubSubService.$pub('firebaseRegister');
                }
                _this.pubSubService.$pub('loginComplete');
                return (result);
            }, function (error) {
                return (error);
            }));
        };
        NLoginService.prototype.isLoggedIn = function () {
            var _this = this;
            return this.nLocalStorageService.initStorage().then(function (result) {
                if (_this.nSessionStorage.getValue('accessToken') && _this.nSessionStorage.getValue('refreshToken') &&
                    _this.nSessionStorage.getValue('accessToken') != 'null' && _this.nSessionStorage.getValue('refreshToken') != 'null') {
                    return true;
                }
                return false;
            }).catch(function (error) {
                return false;
            });
        };
        return NLoginService;
    }());
    NLoginService.decorators = [
        { type: core.Injectable }
    ];
    NLoginService.ctorParameters = function () { return [
        { type: http.HttpClient },
        { type: NPubSubService },
        { type: NNotificationService },
        { type: NLocalStorageService },
        { type: NTokenService }
    ]; };
    NLoginService.propDecorators = {
        loginCompleted: [{ type: core.Output }]
    };

    var NAuthGuardService = /** @class */ (function () {
        function NAuthGuardService(nLoginService, router) {
            this.nLoginService = nLoginService;
            this.router = router;
        }
        NAuthGuardService.prototype.canActivate = function () {
            var _this = this;
            return this.nLoginService.isLoggedIn().then(function (result) {
                if (result) {
                    return true;
                }
                else {
                    _this.router.navigate(['unauthorized']);
                    return false;
                }
            });
        };
        return NAuthGuardService;
    }());
    NAuthGuardService.decorators = [
        { type: core.Injectable }
    ];
    NAuthGuardService.ctorParameters = function () { return [
        { type: NLoginService },
        { type: router.Router }
    ]; };

    var NDataModelService = /** @class */ (function () {
        function NDataModelService(http) {
            this.http = http;
            this.invalidDataModelName = 'Invalid data model name.';
            this.invalidDataModelId = 'Invalid data model id.';
            this.invalidDataModelObj = 'Invalid data model object.';
            this.systemService = NSystemService.getInstance();
        }
        // GET /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}
        /**
         *
         * @param dataModelName
         * @param filter The filter query parameter allows to specify conditions on the documents to return.
         * The filter qparam value is any mongodb query… Defaults to {}
         * @param keys Projections to be applited on mongo db.
         * @param sort sort to be applied on the query results. Defaults to {}
         * @param pagenumber Page number for paginated queries. Defaults to 1
         * @param pagesize Size of each page to be returned. Defaults to 100.
         */
        NDataModelService.prototype.get = function (dataModelName, filter, keys, sort, pagenumber, pagesize) {
            if (dataModelName) {
                // let modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}`;
                var modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName;
                if (this.checkIfValid(filter) || this.checkIfValid(keys) || this.checkIfValid(sort) ||
                    this.checkIfValid(pagenumber) || this.checkIfValid(pagesize)) {
                    var queryString = "" + this.toQueryString({
                        'filter': filter,
                        'keys': keys,
                        'sort': sort,
                        'pagenumber': pagenumber,
                        'pagesize': pagesize
                    });
                    if (queryString === '') {
                        queryString += '?filter={}';
                    }
                    else {
                        queryString = '?'.concat(queryString);
                    }
                    modelNameUrl += queryString;
                }
                return this.http.get(modelNameUrl).pipe(operators.map(function (value, index) {
                    return value;
                }), operators.catchError(function (error) {
                    return rxjs.throwError(error);
                }));
            }
            else {
                return rxjs.throwError(new Error("Could not get " + dataModelName + ". " + this.invalidDataModelName));
            }
        };
        // PUT /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}
        /**
         *
         * @param dataModelName Data model name of the app
         * @param dataModelObj Data Model object which is to be inserted
         */
        NDataModelService.prototype.put = function (dataModelName, dataModelObj) {
            if (dataModelName) {
                if (dataModelObj) {
                    // const modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}`;
                    var modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName;
                    return this.http.put(modelNameUrl, dataModelObj).pipe(operators.map(function (value, index) {
                        return value;
                    }), operators.catchError(function (error) {
                        return rxjs.throwError(error);
                    }));
                }
                else {
                    return rxjs.throwError(new Error("Could not put " + dataModelObj + " in " + dataModelName + ". " + this.invalidDataModelObj));
                }
            }
            else {
                return rxjs.throwError(new Error("Could not put " + dataModelObj + " in " + dataModelName + ". " + this.invalidDataModelName));
            }
        };
        // DELETE /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}
        /**
         *
         * @param dataModelName
         * @param filter
         */
        NDataModelService.prototype.delete = function (dataModelName, filter) {
            var modelNameUrl;
            if (dataModelName) {
                // modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}`;
                modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName;
                if (this.checkIfValid(filter) && filter != '') {
                    modelNameUrl += "?filter=" + filter;
                }
                else {
                    modelNameUrl += '?filter={}';
                }
                return this.http.delete(modelNameUrl).pipe(operators.map(function (value, index) {
                    return value;
                }), operators.catchError(function (error) {
                    return rxjs.throwError(error);
                }));
            }
            else {
                return rxjs.throwError(new Error("Could not delete " + dataModelName + ". " + this.invalidDataModelName));
            }
        };
        // PATCH /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}
        /**
         *
         * @param dataModelName Data model name which is to be updated
         * @param dataModelObj New data model object
         */
        NDataModelService.prototype.update = function (dataModelName, updateObject) {
            if (dataModelName && updateObject) {
                // const modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}`;
                var modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName;
                return this.http.patch(modelNameUrl, updateObject).pipe(operators.map(function (value, index) {
                    return value;
                }), operators.catchError(function (error) {
                    return rxjs.throwError(error);
                }));
            }
            else {
                return rxjs.throwError(new Error("Could not update " + dataModelName + ". " + this.invalidDataModelName));
            }
        };
        // GET /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}/{dataModelId}
        /**
         *
         * @param dataModelName Data model name which is to be updated
         * @param dataModelId Data model id which is to be updated
         */
        NDataModelService.prototype.getById = function (dataModelName, dataModelId) {
            if (dataModelName) {
                if (dataModelId) {
                    // const modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}/${dataModelId}`;
                    var modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName + "/" + dataModelId;
                    return this.http.get(modelNameUrl).pipe(operators.map(function (value, index) {
                        return value;
                    }), operators.catchError(function (error) {
                        return rxjs.throwError(error);
                    }));
                }
                else {
                    rxjs.throwError(new Error("Could not get " + dataModelName + " by id " + dataModelId + ". " + this.invalidDataModelId));
                }
            }
            else {
                rxjs.throwError(new Error("Could not get " + dataModelName + " by id " + dataModelId + ". " + this.invalidDataModelName));
            }
        };
        // DELETE /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}/{dataModelId}
        /**
         *
         * @param dataModelName Data model name which is to be deleted
         * @param dataModelId Data model id which is to be deleted
         */
        NDataModelService.prototype.deleteById = function (dataModelName, dataModelId) {
            if (dataModelName) {
                if (dataModelId) {
                    // const modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}/${dataModelId}`;
                    var modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName + "/" + dataModelId;
                    return this.http.delete(modelNameUrl).pipe(operators.map(function (value, index) {
                        return value;
                    }), operators.catchError(function (error) {
                        return rxjs.throwError(error);
                    }));
                }
                else {
                    rxjs.throwError(new Error("Could not get " + dataModelName + " by id " + dataModelId + ". " + this.invalidDataModelId));
                }
            }
            else {
                return rxjs.throwError(new Error("Could not delete " + dataModelName + " by id " + dataModelId + ". " + this.invalidDataModelName));
            }
        };
        //PATCH /{tenantName}/datamodel/{datasource}/{appName}/{dataModelName}/{dataModelId}
        /**
         *
         * @param dataModelName Data model name which is to be update
         * @param dataModelId Data model id which is to be updated
         * @param dataModelObj Data Model object which is to be inserted
         */
        NDataModelService.prototype.updateById = function (dataModelName, dataModelId, dataModelObj) {
            if (dataModelName) {
                if (dataModelId) {
                    // const modelNameUrl = `${this.getDataSourceURL(dataModelName)}${dataModelName}/${dataModelId}`;
                    var modelNameUrl = this.getDataSourceURL(dataModelName) + dataModelName + "/" + dataModelId;
                    var dmObj = Object.assign({}, dataModelObj);
                    delete dmObj['_id'];
                    return this.http.patch(modelNameUrl, dmObj).pipe(operators.map(function (value, index) {
                        return value;
                    }), operators.catchError(function (error) {
                        return rxjs.throwError(error);
                    }));
                }
                else {
                    rxjs.throwError(new Error("Could not get " + dataModelName + " by id " + dataModelId + ". " + this.invalidDataModelId));
                }
            }
            else {
                return rxjs.throwError(new Error("Could not delete " + dataModelName + " by id " + dataModelId + ". " + this.invalidDataModelName));
            }
        };
        NDataModelService.prototype.toQueryString = function (obj) {
            var parts = [];
            for (var i in obj) {
                if (obj.hasOwnProperty(i) && this.checkIfValid(obj[i])) {
                    parts.push((i) + '=' + JSON.stringify(obj[i]));
                }
            }
            return parts.join('&');
        };
        NDataModelService.prototype.checkIfValid = function (value) {
            if (value === undefined || value == null) {
                return false;
            }
            else {
                return true;
            }
        };
        NDataModelService.prototype.getDataSourceURL = function (dataModelName) {
            if (!this.dmDs) {
                this.dmDs = window['neutrinos']['dataSource'];
            }
            var dsDm = this.dmDs[dataModelName];
            var properties = this.systemService.properties;
            if (dsDm) {
                return properties.baseUrl + properties.tenantName + '/datamodel/' + dsDm + '/' + properties.appName + '/';
            }
            else {
                return this.systemService.getDataModelUrl();
            }
        };
        return NDataModelService;
    }());
    NDataModelService.decorators = [
        { type: core.Injectable }
    ];
    NDataModelService.ctorParameters = function () { return [
        { type: http.HttpClient }
    ]; };

    var NHttpService = /** @class */ (function () {
        function NHttpService(nHTTPLoader, inj, nLocalStorageService, nTokenService) {
            this.nHTTPLoader = nHTTPLoader;
            this.inj = inj;
            this.nLocalStorageService = nLocalStorageService;
            this.nTokenService = nTokenService;
            this.timeout = 90000;
            this.isRefreshingToken = false;
            this.tokenSubject = new rxjs.BehaviorSubject(null);
            this.systemService = NSystemService.getInstance();
            this.nSessionStorage = new NSessionStorageService();
            this.appProperties = this.systemService.getVal('properties');
            this.nPubSubService = new NPubSubService();
        }
        NHttpService.prototype.intercept = function (req, next) {
            var _this = this;
            this.requestInterceptor();
            // Pass on the cloned request instead of the original request.
            return next.handle(this.requestOptions(req))
                .pipe(operators.timeout(this.timeout), operators.catchError(function (error) { return _this.onCatch(error, req, next); }), operators.finalize(function () {
                _this.onFinally();
            }));
        };
        NHttpService.prototype.updateToken = function (error, req, next) {
            var _this = this;
            if (this.appProperties.appAuthenticationStrategy === 'activeDirectory' ||
                this.appProperties.appAuthenticationStrategy === 'localAuth') {
                if (!this.isRefreshingToken) {
                    this.isRefreshingToken = true;
                    // Reset here so that the following requests wait until the token
                    // comes back from the refreshToken call.
                    this.tokenSubject.next(null);
                    return this.refreshToken()
                        .pipe(operators.switchMap(function (tokensObj) {
                        if (tokensObj) {
                            _this.nTokenService.updateTokens(tokensObj);
                            var newToken = tokensObj['accessToken'];
                            _this.tokenSubject.next(newToken);
                            return next.handle(_this.requestOptions(req));
                        }
                        return rxjs.throwError(new Error('Can\'t refresh the token'));
                    }), operators.catchError(function (err) { return _this.onCatchError(err); }), operators.finalize(function () { return _this.isRefreshingToken = false; }));
                }
                else {
                    return this.tokenSubject.pipe(operators.filter(function (token) { return token != null; }), operators.take(1), operators.switchMap(function (token) { return next.handle(_this.requestOptions(req)); }));
                }
            }
            else {
                return this.onCatchError(error);
            }
        };
        NHttpService.prototype.refreshToken = function () {
            var http$1 = this.inj.get(http.HttpClient);
            var appProperties = this.systemService.getVal('properties');
            var refreshUrl = this.systemService.getAuthUrl() + appProperties.appName + '/refresh';
            var body = {
                'platformDetails': this.systemService.getPlatformDetails(this.systemService.checkDevice()),
                'userKey': this.nSessionStorage.getValue('userObj')['userKey'],
                'refreshToken': this.nSessionStorage.getValue('refreshToken')
            };
            body.platformDetails['uuid'] = this.nLocalStorageService.getValue('uuid');
            return http$1.post(refreshUrl, body);
        };
        /**
         * Request options.
         * @param options
         * @returns HttpRequest
         */
        NHttpService.prototype.requestOptions = function (req) {
            var headers = req.headers;
            if (req.headers == null) {
                headers = new http.HttpHeaders();
            }
            req = req.clone({
                url: this.getFullUrl(req.url),
                headers: headers
            });
            var baseUrl = NSystemService.getInstance().getVal('baseUrl');
            var isArt = (baseUrl !== '' && req.url.includes(baseUrl));
            return isArt ? this.addDefaultHeaders(req) : req;
        };
        /**
        * Default options.
        * @param options
        * @returns HttpHeadedrs
        */
        NHttpService.prototype.addDefaultHeaders = function (req) {
            /**
             * TODO: Add all default Headers over here
             */
            if (!req.headers.has('Access-Control-Allow-Origin')) {
                req.headers = req.headers.set('Access-Control-Allow-Origin', '*');
            }
            if (!req.headers.has('Content-Type')) {
                req.headers = req.headers.set('Content-Type', 'application/json');
            }
            else if (req.headers.has('Content-Type') && (req.headers.get('Content-Type') === 'no-content')) {
                req.headers = req.headers.delete('Content-Type');
            }
            if (!req.headers.has('Accept')) {
                req.headers = req.headers.set('Accept', 'application/json');
            }
            if (!req.headers.has('Authorization')) {
                this.appProperties = this.systemService.getVal('properties');
                if (this.appProperties && this.appProperties.appAuthenticationStrategy === 'basicAuth') {
                    var username = void 0, password = void 0;
                    if (this.appProperties.basicAuthUser && this.appProperties.basicAuthPassword) {
                        username = this.appProperties.basicAuthUser;
                        password = this.appProperties.basicAuthPassword;
                    }
                    else {
                        username = "bhive-art-proxyuser";
                        password = "password";
                        console.warn("Authentication strategy: Basic Auth. basicAuthUser and basicAuthPassword are not configured in environment. Setting default values.");
                    }
                    req.headers = req.headers.set('Authorization', 'Basic ' + btoa(username + ":" + password));
                }
                else if (this.appProperties && (this.appProperties.appAuthenticationStrategy === 'activeDirectory' ||
                    this.appProperties.appAuthenticationStrategy === 'localAuth')) {
                    if (this.nSessionStorage.getValue('accessToken')) {
                        req.headers = req.headers.set('Authorization', 'Bearer ' + this.nSessionStorage.getValue('accessToken'));
                    }
                }
            }
            return req;
        };
        /**
         * Build API url.
         * @param url
         * @returns string
         */
        NHttpService.prototype.getFullUrl = function (url) {
            // return full URL to API here
            return url;
        };
        /**
         * Request interceptor.
         */
        NHttpService.prototype.requestInterceptor = function () {
            this.nHTTPLoader.isHTTPRequestInProgress(true);
        };
        /**
         * Response interceptor.
         */
        NHttpService.prototype.responseInterceptor = function () {
            this.nHTTPLoader.isHTTPRequestInProgress(false);
        };
        /**
          * Error handler.
          * @param error
          * @param caught
          * @returns ErrorObservable
          */
        NHttpService.prototype.onCatch = function (error, req, next) {
            if (error instanceof http.HttpErrorResponse) {
                if (error.status === 403 && error.error.message === 'jwt expired') {
                    return this.updateToken(error, req, next);
                }
                else {
                    return this.onSubscribeError(error);
                }
            }
            else {
                return this.onSubscribeError(error);
            }
        };
        /**
         * onSubscribeError
         * @param error
         */
        NHttpService.prototype.onSubscribeError = function (err) {
            this.nHTTPLoader.alertError(err);
            return this.onCatchError(err);
        };
        /**
         * onFinally
         */
        NHttpService.prototype.onFinally = function () {
            this.responseInterceptor();
        };
        NHttpService.prototype.onCatchError = function (error) {
            return rxjs.throwError(error);
        };
        return NHttpService;
    }());
    NHttpService.decorators = [
        { type: core.Injectable }
    ];
    NHttpService.ctorParameters = function () { return [
        { type: NHTTPLoaderService },
        { type: core.Injector },
        { type: NLocalStorageService },
        { type: NTokenService }
    ]; };

    var NSnackbarService = /** @class */ (function () {
        function NSnackbarService(nPubSubService) {
            var _this = this;
            this.nPubSubService = nPubSubService;
            this.snackService = new rxjs.Subject();
            if (NSystemService.getInstance().getVal('useDefaultExceptionUI')) {
                this.snackBarListner = this.nPubSubService.$sub('openSnackBar', function (msg) {
                    _this.openSnackBar(msg);
                });
            }
        }
        NSnackbarService.prototype.get = function () {
            return this.snackService.asObservable();
        };
        NSnackbarService.prototype.add = function (data) {
            this.snackService.next({
                action: 'add',
                data: data
            });
        };
        NSnackbarService.prototype.remove = function (id) {
            this.snackService.next({ action: 'remove', id: id });
        };
        NSnackbarService.prototype.clear = function () {
            this.snackService.next({ action: 'clear' });
        };
        NSnackbarService.prototype.openSnackBar = function (message, timeout) {
            this.add({
                msg: message,
                timeout: timeout || 5000,
                action: {
                    text: 'Close',
                    onClick: function (snack) {
                    },
                },
                onAdd: function (snack) {
                },
                onRemove: function (snack) {
                }
            });
        };
        return NSnackbarService;
    }());
    NSnackbarService.decorators = [
        { type: core.Injectable }
    ];
    NSnackbarService.ctorParameters = function () { return [
        { type: NPubSubService }
    ]; };

    var SnackComponent = /** @class */ (function () {
        function SnackComponent() {
        }
        return SnackComponent;
    }());
    SnackComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'n-snack',
                    template: "\n     <div class=\"snack\" [ngStyle]=\"{background: background ? background : '#323232' , color: color ? color : '#fff'}\" [ngClass]=\" ['snackbar-layout', 'customClass' ]\">\n          <ng-content></ng-content>\n       </div> \n  ",
                    styles: [".snack-action{color:#2196f3;cursor:pointer;font-weight:700}.container{display:flex;flex-direction:row;flex-wrap:wrap}.child{flex:1 0;margin-right:.5em;width:60%}.snackbars.bottom-center{align-items:middle}.snackbars{display:flex;display:inline;font-family:Roboto;letter-spacing:1px;max-width:100%;position:fixed;word-wrap:break-word;z-index:99999}.snackbars.bottom-center{align-items:center;bottom:1px;left:50%;transform:translate(-50%)}.snack{border-radius:.3em;max-height:50vh;overflow:auto;padding:1em}"]
                },] }
    ];
    SnackComponent.propDecorators = {
        background: [{ type: core.Input }],
        color: [{ type: core.Input }],
        customClass: [{ type: core.Input }]
    };

    var SnackbarComponent = /** @class */ (function () {
        function SnackbarComponent(snackbarService) {
            var _this = this;
            this.snackbarService = snackbarService;
            this.max = 1;
            this.onAdd = new core.EventEmitter();
            this.onRemove = new core.EventEmitter();
            this.onClear = new core.EventEmitter();
            this.snacks = [];
            this.snackbarService.get()
                .subscribe(function (snack) {
                if (snack.action === 'add') {
                    _this.add(snack.data);
                }
                else if (snack.action === 'remove') {
                    _this.remove(snack.id);
                }
                else if (snack.action === 'clear') {
                    _this.clear();
                }
            });
        }
        SnackbarComponent.prototype.add = function (snack) {
            var _this = this;
            var timeout;
            var id = this.uuid();
            if (this.max && this.max > 0 && this.snacks.length === this.max) {
                this.remove(this.snacks[0].id);
            }
            if (snack.timeout || this.timeout) {
                timeout = setTimeout(function () {
                    _this.remove(id);
                }, snack.timeout || this.timeout);
            }
            var data = Object.assign({ id: id, timeoutObj: timeout }, snack);
            if (snack.action) {
                var that_1 = this;
                var fcn_1 = snack.action.onClick || new Function();
                snack.action.onClick = function () {
                    fcn_1(data);
                    that_1.remove(id);
                };
            }
            if (snack.onAdd) {
                snack.onAdd(data);
            }
            if (this.onAdd) {
                this.onAdd.emit(data);
            }
            this.snacks.push(data);
        };
        SnackbarComponent.prototype.remove = function (id) {
            var snack = this.snacks.find(function (obj) { return obj.id === id; });
            if (snack) {
                if (snack.onRemove) {
                    snack.onRemove(snack);
                }
                if (this.onRemove) {
                    this.onRemove.emit(snack);
                }
                if (snack.timeoutObj) {
                    clearTimeout(snack.timeoutObj);
                }
            }
            this.snacks = this.snacks.filter(function (obj) { return obj.id !== id; });
        };
        SnackbarComponent.prototype.clear = function () {
            // this.snacks.forEach(snack => {
            //   this.remove(snack.id);
            // });
            this.snacks = [];
            if (this.onClear) {
                this.onClear.emit(true);
            }
        };
        SnackbarComponent.prototype.uuid = function () {
            // tslint:disable:no-bitwise
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
            // tslint:enable:no-bitwise
        };
        SnackbarComponent.prototype.calcTextColor = function (background) {
            if (!background) {
                return null;
            }
            function hexToRgb(hex) {
                var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                    return r + r + g + g + b + b;
                });
                var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }
            var rgb = hexToRgb(background);
            if (!rgb) {
                return null;
            }
            var color = [rgb.r / 255, rgb.g / 255, rgb.b / 255];
            for (var i = 0; i < color.length; ++i) {
                if (color[i] <= 0.03928) {
                    color[i] = color[i] / 12.92;
                }
                else {
                    color[i] = Math.pow((color[i] + 0.055) / 1.055, 2.4);
                }
            }
            var l = 0.2126 * color[0] + 0.7152 * color[1] + 0.0722 * color[2];
            if (l > 0.179) {
                return '#000';
            }
            else {
                return '#fff';
            }
        };
        return SnackbarComponent;
    }());
    SnackbarComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'n-snackbar',
                    template: "\n      <div class=\"snackbars\" [ngClass]=\"position || 'bottom-center'\">\n          <n-snack   *ngFor=\"let snackbar of snacks\" [background]=\"snackbar.background || background\"\n                        [customClass]=\"snackbar.customClass || customClass\"\n                        [color]=\"snackbar.color || color || calcTextColor(snackbar.background || background)\">\n              <div class=\"container\">\n              <div class=\"snack-text child\" >\n                  {{snackbar.msg}}\n              </div>\n              <div *ngIf=\"snackbar.action.text\" class=\"snack-action\" (click)=\"snackbar.action.onClick()\"\n                   [ngStyle]=\"{color: snackbar.action.color || accent}\">\n                  {{snackbar.action.text}}\n              </div>\n              </div>\n          </n-snack>\n      </div>\n  ",
                    styles: [".snack-action{color:#2196f3;cursor:pointer;font-weight:700}.container{display:flex;flex-direction:row;flex-wrap:wrap}.child{flex:1 0;margin-right:.5em;width:60%}.snackbars.bottom-center{align-items:middle}.snackbars{display:flex;display:inline;font-family:Roboto;letter-spacing:1px;max-width:100%;position:fixed;word-wrap:break-word;z-index:99999}.snackbars.bottom-center{align-items:center;bottom:1px;left:50%;transform:translate(-50%)}.snack{border-radius:.3em;max-height:50vh;overflow:auto;padding:1em}"]
                },] }
    ];
    SnackbarComponent.ctorParameters = function () { return [
        { type: NSnackbarService }
    ]; };
    SnackbarComponent.propDecorators = {
        position: [{ type: core.Input }],
        max: [{ type: core.Input }],
        background: [{ type: core.Input }],
        accent: [{ type: core.Input }],
        color: [{ type: core.Input }],
        customClass: [{ type: core.Input }],
        timeout: [{ type: core.Input }],
        onAdd: [{ type: core.Output }],
        onRemove: [{ type: core.Output }],
        onClear: [{ type: core.Output }]
    };

    function startupServiceFactory(startupService) {
        var res = function () {
            // console.log('module before initstorage call');
            return startupService.initStorage();
        };
        return res;
    }
    function NgForageFactory(ngForageConfig) {
        // @ts-ignore
        return new ngforage.NgForage({}, new ngforage.InstanceFactory(ngForageConfig));
    }
    var NeutrinosSeedServicesModule = /** @class */ (function () {
        function NeutrinosSeedServicesModule() {
        }
        return NeutrinosSeedServicesModule;
    }());
    NeutrinosSeedServicesModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        http.HttpClientModule,
                        router.RouterModule
                    ],
                    providers: [
                        {
                            provide: http.HTTP_INTERCEPTORS,
                            useClass: NHttpService,
                            multi: true
                        },
                        {
                            // Provider for APP_INITIALIZER
                            provide: core.APP_INITIALIZER,
                            useFactory: startupServiceFactory,
                            deps: [NLocalStorageService],
                            multi: true
                        },
                        {
                            provide: ngforage.NgForage,
                            useFactory: NgForageFactory,
                            deps: [
                                ngforage.NgForageConfig
                            ]
                        },
                        NAuthGuardService,
                        NDataModelService,
                        NHttpService,
                        NHTTPLoaderService,
                        NLocalStorageService,
                        NLoginService,
                        NLogoutService,
                        NNotificationService,
                        NSnackbarService,
                        NPubSubService,
                        NSessionStorageService,
                        NTokenService
                    ],
                    declarations: [
                        SnackComponent,
                        SnackbarComponent
                    ],
                    exports: [
                        SnackComponent,
                        SnackbarComponent
                    ]
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.NAuthGuardService = NAuthGuardService;
    exports.NDataModelService = NDataModelService;
    exports.NHTTPLoaderService = NHTTPLoaderService;
    exports.NHttpService = NHttpService;
    exports.NLocalStorageService = NLocalStorageService;
    exports.NLoginService = NLoginService;
    exports.NLogoutService = NLogoutService;
    exports.NNotificationService = NNotificationService;
    exports.NPubSubService = NPubSubService;
    exports.NSessionStorageService = NSessionStorageService;
    exports.NSnackbarService = NSnackbarService;
    exports.NSystemService = NSystemService;
    exports.NTokenService = NTokenService;
    exports.NUtility = NUtility;
    exports.NeutrinosSeedServicesModule = NeutrinosSeedServicesModule;
    exports.NgForageFactory = NgForageFactory;
    exports.SnackComponent = SnackComponent;
    exports.SnackbarComponent = SnackbarComponent;
    exports.startupServiceFactory = startupServiceFactory;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=neutrinos-seed-services.umd.js.map
