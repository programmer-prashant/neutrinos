{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/10016/neutrinos-studio/assignment-1/app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:/Users/10016/neutrinos-studio/assignment-1/app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/10016/neutrinos-studio/assignment-1/app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*!\n * Signature Pad v3.0.0-beta.4 | https://github.com/szimek/signature_pad\n * (c) 2020 Szymon Nowak | Released under the MIT license\n */\nvar Point = /*#__PURE__*/function () {\n  function Point(x, y, time) {\n    _classCallCheck(this, Point);\n\n    this.x = x;\n    this.y = y;\n    this.time = time || Date.now();\n  }\n\n  _createClass(Point, [{\n    key: \"distanceTo\",\n    value: function distanceTo(start) {\n      return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.x === other.x && this.y === other.y && this.time === other.time;\n    }\n  }, {\n    key: \"velocityFrom\",\n    value: function velocityFrom(start) {\n      return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 0;\n    }\n  }]);\n\n  return Point;\n}();\n\nvar Bezier = /*#__PURE__*/function () {\n  function Bezier(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n    _classCallCheck(this, Bezier);\n\n    this.startPoint = startPoint;\n    this.control2 = control2;\n    this.control1 = control1;\n    this.endPoint = endPoint;\n    this.startWidth = startWidth;\n    this.endWidth = endWidth;\n  }\n\n  _createClass(Bezier, [{\n    key: \"length\",\n    value: function length() {\n      var steps = 10;\n      var length = 0;\n      var px;\n      var py;\n\n      for (var i = 0; i <= steps; i += 1) {\n        var t = i / steps;\n        var cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n        var cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n\n        if (i > 0) {\n          var xdiff = cx - px;\n          var ydiff = cy - py;\n          length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n        }\n\n        px = cx;\n        py = cy;\n      }\n\n      return length;\n    }\n  }, {\n    key: \"point\",\n    value: function point(t, start, c1, c2, end) {\n      return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;\n    }\n  }], [{\n    key: \"fromPoints\",\n    value: function fromPoints(points, widths) {\n      var c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n      var c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n      return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n    }\n  }, {\n    key: \"calculateControlPoints\",\n    value: function calculateControlPoints(s1, s2, s3) {\n      var dx1 = s1.x - s2.x;\n      var dy1 = s1.y - s2.y;\n      var dx2 = s2.x - s3.x;\n      var dy2 = s2.y - s3.y;\n      var m1 = {\n        x: (s1.x + s2.x) / 2.0,\n        y: (s1.y + s2.y) / 2.0\n      };\n      var m2 = {\n        x: (s2.x + s3.x) / 2.0,\n        y: (s2.y + s3.y) / 2.0\n      };\n      var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n      var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n      var dxm = m1.x - m2.x;\n      var dym = m1.y - m2.y;\n      var k = l2 / (l1 + l2);\n      var cm = {\n        x: m2.x + dxm * k,\n        y: m2.y + dym * k\n      };\n      var tx = s2.x - cm.x;\n      var ty = s2.y - cm.y;\n      return {\n        c1: new Point(m1.x + tx, m1.y + ty),\n        c2: new Point(m2.x + tx, m2.y + ty)\n      };\n    }\n  }]);\n\n  return Bezier;\n}();\n\nfunction throttle(fn) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;\n  var previous = 0;\n  var timeout = null;\n  var result;\n  var storedContext;\n  var storedArgs;\n\n  var later = function later() {\n    previous = Date.now();\n    timeout = null;\n    result = fn.apply(storedContext, storedArgs);\n\n    if (!timeout) {\n      storedContext = null;\n      storedArgs = [];\n    }\n  };\n\n  return function wrapper() {\n    var now = Date.now();\n    var remaining = wait - (now - previous);\n    storedContext = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    storedArgs = args;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      previous = now;\n      result = fn.apply(storedContext, storedArgs);\n\n      if (!timeout) {\n        storedContext = null;\n        storedArgs = [];\n      }\n    } else if (!timeout) {\n      timeout = window.setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n\nvar SignaturePad = /*#__PURE__*/function () {\n  function SignaturePad(canvas) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, SignaturePad);\n\n    this.canvas = canvas;\n    this.options = options;\n\n    this._handleMouseDown = function (event) {\n      if (event.which === 1) {\n        _this._mouseButtonDown = true;\n\n        _this._strokeBegin(event);\n      }\n    };\n\n    this._handleMouseMove = function (event) {\n      if (_this._mouseButtonDown) {\n        _this._strokeMoveUpdate(event);\n      }\n    };\n\n    this._handleMouseUp = function (event) {\n      if (event.which === 1 && _this._mouseButtonDown) {\n        _this._mouseButtonDown = false;\n\n        _this._strokeEnd(event);\n      }\n    };\n\n    this._handleTouchStart = function (event) {\n      event.preventDefault();\n\n      if (event.targetTouches.length === 1) {\n        var touch = event.changedTouches[0];\n\n        _this._strokeBegin(touch);\n      }\n    };\n\n    this._handleTouchMove = function (event) {\n      event.preventDefault();\n      var touch = event.targetTouches[0];\n\n      _this._strokeMoveUpdate(touch);\n    };\n\n    this._handleTouchEnd = function (event) {\n      var wasCanvasTouched = event.target === _this.canvas;\n\n      if (wasCanvasTouched) {\n        event.preventDefault();\n        var touch = event.changedTouches[0];\n\n        _this._strokeEnd(touch);\n      }\n    };\n\n    this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n    this.minWidth = options.minWidth || 0.5;\n    this.maxWidth = options.maxWidth || 2.5;\n    this.throttle = 'throttle' in options ? options.throttle : 16;\n    this.minDistance = 'minDistance' in options ? options.minDistance : 5;\n\n    this.dotSize = options.dotSize || function dotSize() {\n      return (this.minWidth + this.maxWidth) / 2;\n    };\n\n    this.penColor = options.penColor || 'black';\n    this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n    this.onBegin = options.onBegin;\n    this.onEnd = options.onEnd;\n    this._strokeMoveUpdate = this.throttle ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle) : SignaturePad.prototype._strokeUpdate;\n    this._ctx = canvas.getContext('2d');\n    this.clear();\n    this.on();\n  }\n\n  _createClass(SignaturePad, [{\n    key: \"clear\",\n    value: function clear() {\n      var ctx = this._ctx,\n          canvas = this.canvas;\n      ctx.fillStyle = this.backgroundColor;\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      this._data = [];\n\n      this._reset();\n\n      this._isEmpty = true;\n    }\n  }, {\n    key: \"fromDataURL\",\n    value: function fromDataURL(dataUrl) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\n      var image = new Image();\n      var ratio = options.ratio || window.devicePixelRatio || 1;\n      var width = options.width || this.canvas.width / ratio;\n      var height = options.height || this.canvas.height / ratio;\n\n      this._reset();\n\n      image.onload = function () {\n        _this2._ctx.drawImage(image, 0, 0, width, height);\n\n        if (callback) {\n          callback();\n        }\n      };\n\n      image.onerror = function (error) {\n        if (callback) {\n          callback(error);\n        }\n      };\n\n      image.src = dataUrl;\n      this._isEmpty = false;\n    }\n  }, {\n    key: \"toDataURL\",\n    value: function toDataURL() {\n      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';\n      var encoderOptions = arguments.length > 1 ? arguments[1] : undefined;\n\n      switch (type) {\n        case 'image/svg+xml':\n          return this._toSVG();\n\n        default:\n          return this.canvas.toDataURL(type, encoderOptions);\n      }\n    }\n  }, {\n    key: \"on\",\n    value: function on() {\n      this.canvas.style.touchAction = 'none';\n      this.canvas.style.msTouchAction = 'none';\n\n      if (window.PointerEvent) {\n        this._handlePointerEvents();\n      } else {\n        this._handleMouseEvents();\n\n        if ('ontouchstart' in window) {\n          this._handleTouchEvents();\n        }\n      }\n    }\n  }, {\n    key: \"off\",\n    value: function off() {\n      this.canvas.style.touchAction = 'auto';\n      this.canvas.style.msTouchAction = 'auto';\n      this.canvas.removeEventListener('pointerdown', this._handleMouseDown);\n      this.canvas.removeEventListener('pointermove', this._handleMouseMove);\n      document.removeEventListener('pointerup', this._handleMouseUp);\n      this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n      this.canvas.removeEventListener('mousemove', this._handleMouseMove);\n      document.removeEventListener('mouseup', this._handleMouseUp);\n      this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n      this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n      this.canvas.removeEventListener('touchend', this._handleTouchEnd);\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._isEmpty;\n    }\n  }, {\n    key: \"fromData\",\n    value: function fromData(pointGroups) {\n      var _this3 = this;\n\n      this.clear();\n\n      this._fromData(pointGroups, function (_ref) {\n        var color = _ref.color,\n            curve = _ref.curve;\n        return _this3._drawCurve({\n          color: color,\n          curve: curve\n        });\n      }, function (_ref2) {\n        var color = _ref2.color,\n            point = _ref2.point;\n        return _this3._drawDot({\n          color: color,\n          point: point\n        });\n      });\n\n      this._data = pointGroups;\n    }\n  }, {\n    key: \"toData\",\n    value: function toData() {\n      return this._data;\n    }\n  }, {\n    key: \"_strokeBegin\",\n    value: function _strokeBegin(event) {\n      var newPointGroup = {\n        color: this.penColor,\n        points: []\n      };\n\n      if (typeof this.onBegin === 'function') {\n        this.onBegin(event);\n      }\n\n      this._data.push(newPointGroup);\n\n      this._reset();\n\n      this._strokeUpdate(event);\n    }\n  }, {\n    key: \"_strokeUpdate\",\n    value: function _strokeUpdate(event) {\n      if (this._data.length === 0) {\n        this._strokeBegin(event);\n\n        return;\n      }\n\n      var x = event.clientX;\n      var y = event.clientY;\n\n      var point = this._createPoint(x, y);\n\n      var lastPointGroup = this._data[this._data.length - 1];\n      var lastPoints = lastPointGroup.points;\n      var lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n      var isLastPointTooClose = lastPoint ? point.distanceTo(lastPoint) <= this.minDistance : false;\n      var color = lastPointGroup.color;\n\n      if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n        var curve = this._addPoint(point);\n\n        if (!lastPoint) {\n          this._drawDot({\n            color: color,\n            point: point\n          });\n        } else if (curve) {\n          this._drawCurve({\n            color: color,\n            curve: curve\n          });\n        }\n\n        lastPoints.push({\n          time: point.time,\n          x: point.x,\n          y: point.y\n        });\n      }\n    }\n  }, {\n    key: \"_strokeEnd\",\n    value: function _strokeEnd(event) {\n      this._strokeUpdate(event);\n\n      if (typeof this.onEnd === 'function') {\n        this.onEnd(event);\n      }\n    }\n  }, {\n    key: \"_handlePointerEvents\",\n    value: function _handlePointerEvents() {\n      this._mouseButtonDown = false;\n      this.canvas.addEventListener('pointerdown', this._handleMouseDown);\n      this.canvas.addEventListener('pointermove', this._handleMouseMove);\n      document.addEventListener('pointerup', this._handleMouseUp);\n    }\n  }, {\n    key: \"_handleMouseEvents\",\n    value: function _handleMouseEvents() {\n      this._mouseButtonDown = false;\n      this.canvas.addEventListener('mousedown', this._handleMouseDown);\n      this.canvas.addEventListener('mousemove', this._handleMouseMove);\n      document.addEventListener('mouseup', this._handleMouseUp);\n    }\n  }, {\n    key: \"_handleTouchEvents\",\n    value: function _handleTouchEvents() {\n      this.canvas.addEventListener('touchstart', this._handleTouchStart);\n      this.canvas.addEventListener('touchmove', this._handleTouchMove);\n      this.canvas.addEventListener('touchend', this._handleTouchEnd);\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this._lastPoints = [];\n      this._lastVelocity = 0;\n      this._lastWidth = (this.minWidth + this.maxWidth) / 2;\n      this._ctx.fillStyle = this.penColor;\n    }\n  }, {\n    key: \"_createPoint\",\n    value: function _createPoint(x, y) {\n      var rect = this.canvas.getBoundingClientRect();\n      return new Point(x - rect.left, y - rect.top, new Date().getTime());\n    }\n  }, {\n    key: \"_addPoint\",\n    value: function _addPoint(point) {\n      var _lastPoints = this._lastPoints;\n\n      _lastPoints.push(point);\n\n      if (_lastPoints.length > 2) {\n        if (_lastPoints.length === 3) {\n          _lastPoints.unshift(_lastPoints[0]);\n        }\n\n        var widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2]);\n\n        var curve = Bezier.fromPoints(_lastPoints, widths);\n\n        _lastPoints.shift();\n\n        return curve;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_calculateCurveWidths\",\n    value: function _calculateCurveWidths(startPoint, endPoint) {\n      var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - this.velocityFilterWeight) * this._lastVelocity;\n\n      var newWidth = this._strokeWidth(velocity);\n\n      var widths = {\n        end: newWidth,\n        start: this._lastWidth\n      };\n      this._lastVelocity = velocity;\n      this._lastWidth = newWidth;\n      return widths;\n    }\n  }, {\n    key: \"_strokeWidth\",\n    value: function _strokeWidth(velocity) {\n      return Math.max(this.maxWidth / (velocity + 1), this.minWidth);\n    }\n  }, {\n    key: \"_drawCurveSegment\",\n    value: function _drawCurveSegment(x, y, width) {\n      var ctx = this._ctx;\n      ctx.moveTo(x, y);\n      ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n      this._isEmpty = false;\n    }\n  }, {\n    key: \"_drawCurve\",\n    value: function _drawCurve(_ref3) {\n      var color = _ref3.color,\n          curve = _ref3.curve;\n      var ctx = this._ctx;\n      var widthDelta = curve.endWidth - curve.startWidth;\n      var drawSteps = Math.floor(curve.length()) * 2;\n      ctx.beginPath();\n      ctx.fillStyle = color;\n\n      for (var i = 0; i < drawSteps; i += 1) {\n        var t = i / drawSteps;\n        var tt = t * t;\n        var ttt = tt * t;\n        var u = 1 - t;\n        var uu = u * u;\n        var uuu = uu * u;\n        var x = uuu * curve.startPoint.x;\n        x += 3 * uu * t * curve.control1.x;\n        x += 3 * u * tt * curve.control2.x;\n        x += ttt * curve.endPoint.x;\n        var y = uuu * curve.startPoint.y;\n        y += 3 * uu * t * curve.control1.y;\n        y += 3 * u * tt * curve.control2.y;\n        y += ttt * curve.endPoint.y;\n        var width = Math.min(curve.startWidth + ttt * widthDelta, this.maxWidth);\n\n        this._drawCurveSegment(x, y, width);\n      }\n\n      ctx.closePath();\n      ctx.fill();\n    }\n  }, {\n    key: \"_drawDot\",\n    value: function _drawDot(_ref4) {\n      var color = _ref4.color,\n          point = _ref4.point;\n      var ctx = this._ctx;\n      var width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;\n      ctx.beginPath();\n\n      this._drawCurveSegment(point.x, point.y, width);\n\n      ctx.closePath();\n      ctx.fillStyle = color;\n      ctx.fill();\n    }\n  }, {\n    key: \"_fromData\",\n    value: function _fromData(pointGroups, drawCurve, drawDot) {\n      var _iterator = _createForOfIteratorHelper(pointGroups),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var group = _step.value;\n          var color = group.color,\n              points = group.points;\n\n          if (points.length > 1) {\n            for (var j = 0; j < points.length; j += 1) {\n              var basicPoint = points[j];\n              var point = new Point(basicPoint.x, basicPoint.y, basicPoint.time);\n              this.penColor = color;\n\n              if (j === 0) {\n                this._reset();\n              }\n\n              var curve = this._addPoint(point);\n\n              if (curve) {\n                drawCurve({\n                  color: color,\n                  curve: curve\n                });\n              }\n            }\n          } else {\n            this._reset();\n\n            drawDot({\n              color: color,\n              point: points[0]\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"_toSVG\",\n    value: function _toSVG() {\n      var _this4 = this;\n\n      var pointGroups = this._data;\n      var ratio = Math.max(window.devicePixelRatio || 1, 1);\n      var minX = 0;\n      var minY = 0;\n      var maxX = this.canvas.width / ratio;\n      var maxY = this.canvas.height / ratio;\n      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      svg.setAttribute('width', this.canvas.width.toString());\n      svg.setAttribute('height', this.canvas.height.toString());\n\n      this._fromData(pointGroups, function (_ref5) {\n        var color = _ref5.color,\n            curve = _ref5.curve;\n        var path = document.createElement('path');\n\n        if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {\n          var attr = \"M \".concat(curve.startPoint.x.toFixed(3), \",\").concat(curve.startPoint.y.toFixed(3), \" \") + \"C \".concat(curve.control1.x.toFixed(3), \",\").concat(curve.control1.y.toFixed(3), \" \") + \"\".concat(curve.control2.x.toFixed(3), \",\").concat(curve.control2.y.toFixed(3), \" \") + \"\".concat(curve.endPoint.x.toFixed(3), \",\").concat(curve.endPoint.y.toFixed(3));\n          path.setAttribute('d', attr);\n          path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n          path.setAttribute('stroke', color);\n          path.setAttribute('fill', 'none');\n          path.setAttribute('stroke-linecap', 'round');\n          svg.appendChild(path);\n        }\n      }, function (_ref6) {\n        var color = _ref6.color,\n            point = _ref6.point;\n        var circle = document.createElement('circle');\n        var dotSize = typeof _this4.dotSize === 'function' ? _this4.dotSize() : _this4.dotSize;\n        circle.setAttribute('r', dotSize.toString());\n        circle.setAttribute('cx', point.x.toString());\n        circle.setAttribute('cy', point.y.toString());\n        circle.setAttribute('fill', color);\n        svg.appendChild(circle);\n      });\n\n      var prefix = 'data:image/svg+xml;base64,';\n      var header = '<svg' + ' xmlns=\"http://www.w3.org/2000/svg\"' + ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"' + \" viewBox=\\\"\".concat(minX, \" \").concat(minY, \" \").concat(maxX, \" \").concat(maxY, \"\\\"\") + \" width=\\\"\".concat(maxX, \"\\\"\") + \" height=\\\"\".concat(maxY, \"\\\"\") + '>';\n      var body = svg.innerHTML;\n\n      if (body === undefined) {\n        var dummy = document.createElement('dummy');\n        var nodes = svg.childNodes;\n        dummy.innerHTML = '';\n\n        for (var i = 0; i < nodes.length; i += 1) {\n          dummy.appendChild(nodes[i].cloneNode(true));\n        }\n\n        body = dummy.innerHTML;\n      }\n\n      var footer = '</svg>';\n      var data = header + body + footer;\n      return prefix + btoa(data);\n    }\n  }]);\n\n  return SignaturePad;\n}();\n\nexport default SignaturePad;","map":{"version":3,"sources":["../src/point.ts","../src/bezier.ts","../src/throttle.ts","../src/signature_pad.ts"],"names":[],"mappings":";;;;;;;;IAOa,K;AAGX,iBAAmB,CAAnB,EAAqC,CAArC,EAAgD,IAAhD,EAA6D;AAAA;;AAA1C,SAAA,CAAA,GAAA,CAAA;AAAkB,SAAA,CAAA,GAAA,CAAA;AACnC,SAAK,IAAL,GAAY,IAAI,IAAI,IAAI,CAAC,GAAL,EAApB;AACD;;;;WAEM,oBAAW,KAAX,EAA4B;AACjC,aAAO,IAAI,CAAC,IAAL,CACL,IAAI,CAAC,GAAL,CAAS,KAAK,CAAL,GAAS,KAAK,CAAC,CAAxB,EAA2B,CAA3B,IAAgC,IAAI,CAAC,GAAL,CAAS,KAAK,CAAL,GAAS,KAAK,CAAC,CAAxB,EAA2B,CAA3B,CAD3B,CAAP;AAGD;;;WAEM,gBAAO,KAAP,EAAwB;AAC7B,aAAO,KAAK,CAAL,KAAW,KAAK,CAAC,CAAjB,IAAsB,KAAK,CAAL,KAAW,KAAK,CAAC,CAAvC,IAA4C,KAAK,IAAL,KAAc,KAAK,CAAC,IAAvE;AACD;;;WAEM,sBAAa,KAAb,EAA8B;AACnC,aAAO,KAAK,IAAL,KAAc,KAAK,CAAC,IAApB,GACH,KAAK,UAAL,CAAgB,KAAhB,KAA0B,KAAK,IAAL,GAAY,KAAK,CAAC,IAA5C,CADG,GAEH,CAFJ;AAGD;;;;;;IC1BU,M;AA6CX,kBACS,UADT,EAES,QAFT,EAGS,QAHT,EAIS,QAJT,EAKS,UALT,EAMS,QANT,EAMyB;AAAA;;AALhB,SAAA,UAAA,GAAA,UAAA;AACA,SAAA,QAAA,GAAA,QAAA;AACA,SAAA,QAAA,GAAA,QAAA;AACA,SAAA,QAAA,GAAA,QAAA;AACA,SAAA,UAAA,GAAA,UAAA;AACA,SAAA,QAAA,GAAA,QAAA;AACL;;;;WAGG,kBAAM;AACX,UAAM,KAAK,GAAG,EAAd;AACA,UAAI,MAAM,GAAG,CAAb;AACA,UAAI,EAAJ;AACA,UAAI,EAAJ;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,IAAI,KAArB,EAA4B,CAAC,IAAI,CAAjC,EAAoC;AAClC,YAAM,CAAC,GAAG,CAAC,GAAG,KAAd;AACA,YAAM,EAAE,GAAG,KAAK,KAAL,CACT,CADS,EAET,KAAK,UAAL,CAAgB,CAFP,EAGT,KAAK,QAAL,CAAc,CAHL,EAIT,KAAK,QAAL,CAAc,CAJL,EAKT,KAAK,QAAL,CAAc,CALL,CAAX;AAOA,YAAM,EAAE,GAAG,KAAK,KAAL,CACT,CADS,EAET,KAAK,UAAL,CAAgB,CAFP,EAGT,KAAK,QAAL,CAAc,CAHL,EAIT,KAAK,QAAL,CAAc,CAJL,EAKT,KAAK,QAAL,CAAc,CALL,CAAX;;AAQA,YAAI,CAAC,GAAG,CAAR,EAAW;AACT,cAAM,KAAK,GAAG,EAAE,GAAI,EAApB;AACA,cAAM,KAAK,GAAG,EAAE,GAAI,EAApB;AAEA,UAAA,MAAM,IAAI,IAAI,CAAC,IAAL,CAAU,KAAK,GAAG,KAAR,GAAgB,KAAK,GAAG,KAAlC,CAAV;AACD;;AAED,QAAA,EAAE,GAAG,EAAL;AACA,QAAA,EAAE,GAAG,EAAL;AACD;;AAED,aAAO,MAAP;AACD;;;WAGO,eACN,CADM,EAEN,KAFM,EAGN,EAHM,EAIN,EAJM,EAKN,GALM,EAKK;AAGX,aAAe,KAAK,IAAI,MAAM,CAAV,CAAL,IAAqB,MAAM,CAA3B,KAAkC,MAAM,CAAxC,CAAR,GACC,MAAO,EAAP,IAAgB,MAAM,CAAtB,KAA4B,MAAM,CAAlC,IAAwC,CADzC,GAEC,MAAO,EAAP,IAAgB,MAAM,CAAtB,IAA2B,CAA3B,GAAwC,CAFzC,GAGQ,GAAG,GAAK,CAAR,GAAoB,CAApB,GAAiC,CAHhD;AAID;;;WAxGM,oBACL,MADK,EAEL,MAFK,EAEiC;AAEtC,UAAM,EAAE,GAAG,KAAK,sBAAL,CAA4B,MAAM,CAAC,CAAD,CAAlC,EAAuC,MAAM,CAAC,CAAD,CAA7C,EAAkD,MAAM,CAAC,CAAD,CAAxD,EAA6D,EAAxE;AACA,UAAM,EAAE,GAAG,KAAK,sBAAL,CAA4B,MAAM,CAAC,CAAD,CAAlC,EAAuC,MAAM,CAAC,CAAD,CAA7C,EAAkD,MAAM,CAAC,CAAD,CAAxD,EAA6D,EAAxE;AAEA,aAAO,IAAI,MAAJ,CAAW,MAAM,CAAC,CAAD,CAAjB,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,MAAM,CAAC,CAAD,CAApC,EAAyC,MAAM,CAAC,KAAhD,EAAuD,MAAM,CAAC,GAA9D,CAAP;AACD;;;WAEO,gCACN,EADM,EAEN,EAFM,EAGN,EAHM,EAGQ;AAKd,UAAM,GAAG,GAAG,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAtB;AACA,UAAM,GAAG,GAAG,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAtB;AACA,UAAM,GAAG,GAAG,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAtB;AACA,UAAM,GAAG,GAAG,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAtB;AAEA,UAAM,EAAE,GAAG;AAAE,QAAA,CAAC,EAAE,CAAC,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAX,IAAgB,GAArB;AAA0B,QAAA,CAAC,EAAE,CAAC,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAX,IAAgB;AAA7C,OAAX;AACA,UAAM,EAAE,GAAG;AAAE,QAAA,CAAC,EAAE,CAAC,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAX,IAAgB,GAArB;AAA0B,QAAA,CAAC,EAAE,CAAC,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAX,IAAgB;AAA7C,OAAX;AAEA,UAAM,EAAE,GAAG,IAAI,CAAC,IAAL,CAAU,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAA5B,CAAX;AACA,UAAM,EAAE,GAAG,IAAI,CAAC,IAAL,CAAU,GAAG,GAAG,GAAN,GAAY,GAAG,GAAG,GAA5B,CAAX;AAEA,UAAM,GAAG,GAAG,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAtB;AACA,UAAM,GAAG,GAAG,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAAtB;AAEA,UAAM,CAAC,GAAG,EAAE,IAAI,EAAE,GAAG,EAAT,CAAZ;AACA,UAAM,EAAE,GAAG;AAAE,QAAA,CAAC,EAAE,EAAE,CAAC,CAAH,GAAO,GAAG,GAAG,CAAlB;AAAqB,QAAA,CAAC,EAAE,EAAE,CAAC,CAAH,GAAO,GAAG,GAAG;AAArC,OAAX;AAEA,UAAM,EAAE,GAAG,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAArB;AACA,UAAM,EAAE,GAAG,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,CAArB;AAEA,aAAO;AACL,QAAA,EAAE,EAAE,IAAI,KAAJ,CAAU,EAAE,CAAC,CAAH,GAAO,EAAjB,EAAqB,EAAE,CAAC,CAAH,GAAO,EAA5B,CADC;AAEL,QAAA,EAAE,EAAE,IAAI,KAAJ,CAAU,EAAE,CAAC,CAAH,GAAO,EAAjB,EAAqB,EAAE,CAAC,CAAH,GAAO,EAA5B;AAFC,OAAP;AAID;;;;;;SC1Ca,Q,CACd,E,EACU;AAAA,MAAV,IAAU,uEAAH,GAAG;AAEV,MAAI,QAAQ,GAAG,CAAf;AACA,MAAI,OAAO,GAAkB,IAA7B;AACA,MAAI,MAAJ;AACA,MAAI,aAAJ;AACA,MAAI,UAAJ;;AAEA,MAAM,KAAK,GAAG,SAAR,KAAQ,GAAA;AACZ,IAAA,QAAQ,GAAG,IAAI,CAAC,GAAL,EAAX;AACA,IAAA,OAAO,GAAG,IAAV;AACA,IAAA,MAAM,GAAG,EAAE,CAAC,KAAH,CAAS,aAAT,EAAwB,UAAxB,CAAT;;AAEA,QAAI,CAAC,OAAL,EAAc;AACZ,MAAA,aAAa,GAAG,IAAhB;AACA,MAAA,UAAU,GAAG,EAAb;AACD;AACF,GATD;;AAWA,SAAO,SAAS,OAAT,GAA0C;AAC/C,QAAM,GAAG,GAAG,IAAI,CAAC,GAAL,EAAZ;AACA,QAAM,SAAS,GAAG,IAAI,IAAI,GAAG,GAAG,QAAV,CAAtB;AAEA,IAAA,aAAa,GAAG,IAAhB;;AAJ+C,sCAAX,IAAW;AAAX,MAAA,IAAW;AAAA;;AAK/C,IAAA,UAAU,GAAG,IAAb;;AAEA,QAAI,SAAS,IAAI,CAAb,IAAkB,SAAS,GAAG,IAAlC,EAAwC;AACtC,UAAI,OAAJ,EAAa;AACX,QAAA,YAAY,CAAC,OAAD,CAAZ;AACA,QAAA,OAAO,GAAG,IAAV;AACD;;AAED,MAAA,QAAQ,GAAG,GAAX;AACA,MAAA,MAAM,GAAG,EAAE,CAAC,KAAH,CAAS,aAAT,EAAwB,UAAxB,CAAT;;AAEA,UAAI,CAAC,OAAL,EAAc;AACZ,QAAA,aAAa,GAAG,IAAhB;AACA,QAAA,UAAU,GAAG,EAAb;AACD;AACF,KAbD,MAaO,IAAI,CAAC,OAAL,EAAc;AACnB,MAAA,OAAO,GAAG,MAAM,CAAC,UAAP,CAAkB,KAAlB,EAAyB,SAAzB,CAAV;AACD;;AAED,WAAO,MAAP;AACD,GAzBD;AA0BF;;ICXqB,Y;AAyBnB,wBACU,MADV,EAE+B;AAAA;;AAAA,QAArB,OAAqB,uEAAF,EAAE;;AAAA;;AADrB,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,OAAA,GAAA,OAAA;;AAuIF,SAAA,gBAAA,GAAmB,UAAC,KAAD,EAAkB;AAC3C,UAAI,KAAK,CAAC,KAAN,KAAgB,CAApB,EAAuB;AACrB,QAAA,KAAI,CAAC,gBAAL,GAAwB,IAAxB;;AACA,QAAA,KAAI,CAAC,YAAL,CAAkB,KAAlB;AACD;AACF,KALO;;AAOA,SAAA,gBAAA,GAAmB,UAAC,KAAD,EAAkB;AAC3C,UAAI,KAAI,CAAC,gBAAT,EAA2B;AACzB,QAAA,KAAI,CAAC,iBAAL,CAAuB,KAAvB;AACD;AACF,KAJO;;AAMA,SAAA,cAAA,GAAiB,UAAC,KAAD,EAAkB;AACzC,UAAI,KAAK,CAAC,KAAN,KAAgB,CAAhB,IAAqB,KAAI,CAAC,gBAA9B,EAAgD;AAC9C,QAAA,KAAI,CAAC,gBAAL,GAAwB,KAAxB;;AACA,QAAA,KAAI,CAAC,UAAL,CAAgB,KAAhB;AACD;AACF,KALO;;AAOA,SAAA,iBAAA,GAAoB,UAAC,KAAD,EAAkB;AAE5C,MAAA,KAAK,CAAC,cAAN;;AAEA,UAAI,KAAK,CAAC,aAAN,CAAoB,MAApB,KAA+B,CAAnC,EAAsC;AACpC,YAAM,KAAK,GAAG,KAAK,CAAC,cAAN,CAAqB,CAArB,CAAd;;AACA,QAAA,KAAI,CAAC,YAAL,CAAkB,KAAlB;AACD;AACF,KARO;;AAUA,SAAA,gBAAA,GAAmB,UAAC,KAAD,EAAkB;AAE3C,MAAA,KAAK,CAAC,cAAN;AAEA,UAAM,KAAK,GAAG,KAAK,CAAC,aAAN,CAAoB,CAApB,CAAd;;AACA,MAAA,KAAI,CAAC,iBAAL,CAAuB,KAAvB;AACD,KANO;;AAQA,SAAA,eAAA,GAAkB,UAAC,KAAD,EAAkB;AAC1C,UAAM,gBAAgB,GAAG,KAAK,CAAC,MAAN,KAAiB,KAAI,CAAC,MAA/C;;AACA,UAAI,gBAAJ,EAAsB;AACpB,QAAA,KAAK,CAAC,cAAN;AAEA,YAAM,KAAK,GAAG,KAAK,CAAC,cAAN,CAAqB,CAArB,CAAd;;AACA,QAAA,KAAI,CAAC,UAAL,CAAgB,KAAhB;AACD;AACF,KARO;;AA3KN,SAAK,oBAAL,GAA4B,OAAO,CAAC,oBAAR,IAAgC,GAA5D;AACA,SAAK,QAAL,GAAgB,OAAO,CAAC,QAAR,IAAoB,GAApC;AACA,SAAK,QAAL,GAAgB,OAAO,CAAC,QAAR,IAAoB,GAApC;AACA,SAAK,QAAL,GAAiB,cAAc,OAAd,GAAwB,OAAO,CAAC,QAAhC,GAA2C,EAA5D;AACA,SAAK,WAAL,GAAoB,iBAAiB,OAAjB,GAChB,OAAO,CAAC,WADQ,GAEhB,CAFJ;;AAGA,SAAK,OAAL,GACE,OAAO,CAAC,OAAR,IACA,SAAS,OAAT,GAAgB;AACd,aAAO,CAAC,KAAK,QAAL,GAAgB,KAAK,QAAtB,IAAkC,CAAzC;AACD,KAJH;;AAKA,SAAK,QAAL,GAAgB,OAAO,CAAC,QAAR,IAAoB,OAApC;AACA,SAAK,eAAL,GAAuB,OAAO,CAAC,eAAR,IAA2B,eAAlD;AACA,SAAK,OAAL,GAAe,OAAO,CAAC,OAAvB;AACA,SAAK,KAAL,GAAa,OAAO,CAAC,KAArB;AAEA,SAAK,iBAAL,GAAyB,KAAK,QAAL,GACrB,QAAQ,CAAC,YAAY,CAAC,SAAb,CAAuB,aAAxB,EAAuC,KAAK,QAA5C,CADa,GAErB,YAAY,CAAC,SAAb,CAAuB,aAF3B;AAGA,SAAK,IAAL,GAAY,MAAM,CAAC,UAAP,CAAkB,IAAlB,CAAZ;AAEA,SAAK,KAAL;AAGA,SAAK,EAAL;AACD;;;;WAEM,iBAAK;AACV,UAAc,GAAd,GAA8B,IAA9B,CAAQ,IAAR;AAAA,UAAmB,MAAnB,GAA8B,IAA9B,CAAmB,MAAnB;AAGA,MAAA,GAAG,CAAC,SAAJ,GAAgB,KAAK,eAArB;AACA,MAAA,GAAG,CAAC,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,MAAM,CAAC,KAA3B,EAAkC,MAAM,CAAC,MAAzC;AACA,MAAA,GAAG,CAAC,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmB,MAAM,CAAC,KAA1B,EAAiC,MAAM,CAAC,MAAxC;AAEA,WAAK,KAAL,GAAa,EAAb;;AACA,WAAK,MAAL;;AACA,WAAK,QAAL,GAAgB,IAAhB;AACD;;;WAEM,qBACL,OADK,EAGsC;AAAA;;AAAA,UAD3C,OAC2C,uEADoB,EACpB;AAAA,UAA3C,QAA2C;AAE3C,UAAM,KAAK,GAAG,IAAI,KAAJ,EAAd;AACA,UAAM,KAAK,GAAG,OAAO,CAAC,KAAR,IAAiB,MAAM,CAAC,gBAAxB,IAA4C,CAA1D;AACA,UAAM,KAAK,GAAG,OAAO,CAAC,KAAR,IAAiB,KAAK,MAAL,CAAY,KAAZ,GAAoB,KAAnD;AACA,UAAM,MAAM,GAAG,OAAO,CAAC,MAAR,IAAkB,KAAK,MAAL,CAAY,MAAZ,GAAqB,KAAtD;;AAEA,WAAK,MAAL;;AAEA,MAAA,KAAK,CAAC,MAAN,GAAe,YAAA;AACb,QAAA,MAAI,CAAC,IAAL,CAAU,SAAV,CAAoB,KAApB,EAA2B,CAA3B,EAA8B,CAA9B,EAAiC,KAAjC,EAAwC,MAAxC;;AACA,YAAI,QAAJ,EAAc;AACZ,UAAA,QAAQ;AACT;AACF,OALD;;AAMA,MAAA,KAAK,CAAC,OAAN,GAAgB,UAAC,KAAD,EAAM;AACpB,YAAI,QAAJ,EAAc;AACZ,UAAA,QAAQ,CAAC,KAAD,CAAR;AACD;AACF,OAJD;;AAKA,MAAA,KAAK,CAAC,GAAN,GAAY,OAAZ;AAEA,WAAK,QAAL,GAAgB,KAAhB;AACD;;;WAEM,qBAAqD;AAAA,UAA3C,IAA2C,uEAApC,WAAoC;AAAA,UAAvB,cAAuB;;AAC1D,cAAQ,IAAR;AACE,aAAK,eAAL;AACE,iBAAO,KAAK,MAAL,EAAP;;AACF;AACE,iBAAO,KAAK,MAAL,CAAY,SAAZ,CAAsB,IAAtB,EAA4B,cAA5B,CAAP;AAJJ;AAMD;;;WAEM,cAAE;AAEP,WAAK,MAAL,CAAY,KAAZ,CAAkB,WAAlB,GAAgC,MAAhC;AACA,WAAK,MAAL,CAAY,KAAZ,CAAkB,aAAlB,GAAkC,MAAlC;;AAEA,UAAI,MAAM,CAAC,YAAX,EAAyB;AACvB,aAAK,oBAAL;AACD,OAFD,MAEO;AACL,aAAK,kBAAL;;AAEA,YAAI,kBAAkB,MAAtB,EAA8B;AAC5B,eAAK,kBAAL;AACD;AACF;AACF;;;WAEM,eAAG;AAER,WAAK,MAAL,CAAY,KAAZ,CAAkB,WAAlB,GAAgC,MAAhC;AACA,WAAK,MAAL,CAAY,KAAZ,CAAkB,aAAlB,GAAkC,MAAlC;AAEA,WAAK,MAAL,CAAY,mBAAZ,CAAgC,aAAhC,EAA+C,KAAK,gBAApD;AACA,WAAK,MAAL,CAAY,mBAAZ,CAAgC,aAAhC,EAA+C,KAAK,gBAApD;AACA,MAAA,QAAQ,CAAC,mBAAT,CAA6B,WAA7B,EAA0C,KAAK,cAA/C;AAEA,WAAK,MAAL,CAAY,mBAAZ,CAAgC,WAAhC,EAA6C,KAAK,gBAAlD;AACA,WAAK,MAAL,CAAY,mBAAZ,CAAgC,WAAhC,EAA6C,KAAK,gBAAlD;AACA,MAAA,QAAQ,CAAC,mBAAT,CAA6B,SAA7B,EAAwC,KAAK,cAA7C;AAEA,WAAK,MAAL,CAAY,mBAAZ,CAAgC,YAAhC,EAA8C,KAAK,iBAAnD;AACA,WAAK,MAAL,CAAY,mBAAZ,CAAgC,WAAhC,EAA6C,KAAK,gBAAlD;AACA,WAAK,MAAL,CAAY,mBAAZ,CAAgC,UAAhC,EAA4C,KAAK,eAAjD;AACD;;;WAEM,mBAAO;AACZ,aAAO,KAAK,QAAZ;AACD;;;WAEM,kBAAS,WAAT,EAAkC;AAAA;;AACvC,WAAK,KAAL;;AAEA,WAAK,SAAL,CACE,WADF,EAEE;AAAA,YAAG,KAAH,QAAG,KAAH;AAAA,YAAU,KAAV,QAAU,KAAV;AAAA,eAAsB,MAAI,CAAC,UAAL,CAAgB;AAAE,UAAA,KAAK,EAAL,KAAF;AAAS,UAAA,KAAK,EAAL;AAAT,SAAhB,CAAtB;AAAA,OAFF,EAGE;AAAA,YAAG,KAAH,SAAG,KAAH;AAAA,YAAU,KAAV,SAAU,KAAV;AAAA,eAAsB,MAAI,CAAC,QAAL,CAAc;AAAE,UAAA,KAAK,EAAL,KAAF;AAAS,UAAA,KAAK,EAAL;AAAT,SAAd,CAAtB;AAAA,OAHF;;AAMA,WAAK,KAAL,GAAa,WAAb;AACD;;;WAEM,kBAAM;AACX,aAAO,KAAK,KAAZ;AACD;;;WAoDO,sBAAa,KAAb,EAAsC;AAC5C,UAAM,aAAa,GAAG;AACpB,QAAA,KAAK,EAAE,KAAK,QADQ;AAEpB,QAAA,MAAM,EAAE;AAFY,OAAtB;;AAKA,UAAI,OAAO,KAAK,OAAZ,KAAwB,UAA5B,EAAwC;AACtC,aAAK,OAAL,CAAa,KAAb;AACD;;AAED,WAAK,KAAL,CAAW,IAAX,CAAgB,aAAhB;;AACA,WAAK,MAAL;;AACA,WAAK,aAAL,CAAmB,KAAnB;AACD;;;WAEO,uBAAc,KAAd,EAAuC;AAC7C,UAAI,KAAK,KAAL,CAAW,MAAX,KAAsB,CAA1B,EAA6B;AAG3B,aAAK,YAAL,CAAkB,KAAlB;;AACA;AACD;;AAED,UAAM,CAAC,GAAG,KAAK,CAAC,OAAhB;AACA,UAAM,CAAC,GAAG,KAAK,CAAC,OAAhB;;AAEA,UAAM,KAAK,GAAG,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,CAAd;;AACA,UAAM,cAAc,GAAG,KAAK,KAAL,CAAW,KAAK,KAAL,CAAW,MAAX,GAAoB,CAA/B,CAAvB;AACA,UAAM,UAAU,GAAG,cAAc,CAAC,MAAlC;AACA,UAAM,SAAS,GACb,UAAU,CAAC,MAAX,GAAoB,CAApB,IAAyB,UAAU,CAAC,UAAU,CAAC,MAAX,GAAoB,CAArB,CADrC;AAEA,UAAM,mBAAmB,GAAG,SAAS,GACjC,KAAK,CAAC,UAAN,CAAiB,SAAjB,KAA+B,KAAK,WADH,GAEjC,KAFJ;AAGA,UAAM,KAAK,GAAG,cAAc,CAAC,KAA7B;;AAGA,UAAI,CAAC,SAAD,IAAc,EAAE,SAAS,IAAI,mBAAf,CAAlB,EAAuD;AACrD,YAAM,KAAK,GAAG,KAAK,SAAL,CAAe,KAAf,CAAd;;AAEA,YAAI,CAAC,SAAL,EAAgB;AACd,eAAK,QAAL,CAAc;AAAE,YAAA,KAAK,EAAL,KAAF;AAAS,YAAA,KAAK,EAAL;AAAT,WAAd;AACD,SAFD,MAEO,IAAI,KAAJ,EAAW;AAChB,eAAK,UAAL,CAAgB;AAAE,YAAA,KAAK,EAAL,KAAF;AAAS,YAAA,KAAK,EAAL;AAAT,WAAhB;AACD;;AAED,QAAA,UAAU,CAAC,IAAX,CAAgB;AACd,UAAA,IAAI,EAAE,KAAK,CAAC,IADE;AAEd,UAAA,CAAC,EAAE,KAAK,CAAC,CAFK;AAGd,UAAA,CAAC,EAAE,KAAK,CAAC;AAHK,SAAhB;AAKD;AACF;;;WAEO,oBAAW,KAAX,EAAoC;AAC1C,WAAK,aAAL,CAAmB,KAAnB;;AAEA,UAAI,OAAO,KAAK,KAAZ,KAAsB,UAA1B,EAAsC;AACpC,aAAK,KAAL,CAAW,KAAX;AACD;AACF;;;WAEO,gCAAoB;AAC1B,WAAK,gBAAL,GAAwB,KAAxB;AAEA,WAAK,MAAL,CAAY,gBAAZ,CAA6B,aAA7B,EAA4C,KAAK,gBAAjD;AACA,WAAK,MAAL,CAAY,gBAAZ,CAA6B,aAA7B,EAA4C,KAAK,gBAAjD;AACA,MAAA,QAAQ,CAAC,gBAAT,CAA0B,WAA1B,EAAuC,KAAK,cAA5C;AACD;;;WAEO,8BAAkB;AACxB,WAAK,gBAAL,GAAwB,KAAxB;AAEA,WAAK,MAAL,CAAY,gBAAZ,CAA6B,WAA7B,EAA0C,KAAK,gBAA/C;AACA,WAAK,MAAL,CAAY,gBAAZ,CAA6B,WAA7B,EAA0C,KAAK,gBAA/C;AACA,MAAA,QAAQ,CAAC,gBAAT,CAA0B,SAA1B,EAAqC,KAAK,cAA1C;AACD;;;WAEO,8BAAkB;AACxB,WAAK,MAAL,CAAY,gBAAZ,CAA6B,YAA7B,EAA2C,KAAK,iBAAhD;AACA,WAAK,MAAL,CAAY,gBAAZ,CAA6B,WAA7B,EAA0C,KAAK,gBAA/C;AACA,WAAK,MAAL,CAAY,gBAAZ,CAA6B,UAA7B,EAAyC,KAAK,eAA9C;AACD;;;WAGO,kBAAM;AACZ,WAAK,WAAL,GAAmB,EAAnB;AACA,WAAK,aAAL,GAAqB,CAArB;AACA,WAAK,UAAL,GAAkB,CAAC,KAAK,QAAL,GAAgB,KAAK,QAAtB,IAAkC,CAApD;AACA,WAAK,IAAL,CAAU,SAAV,GAAsB,KAAK,QAA3B;AACD;;;WAEO,sBAAa,CAAb,EAAwB,CAAxB,EAAiC;AACvC,UAAM,IAAI,GAAG,KAAK,MAAL,CAAY,qBAAZ,EAAb;AAEA,aAAO,IAAI,KAAJ,CAAU,CAAC,GAAG,IAAI,CAAC,IAAnB,EAAyB,CAAC,GAAG,IAAI,CAAC,GAAlC,EAAuC,IAAI,IAAJ,GAAW,OAAX,EAAvC,CAAP;AACD;;;WAGO,mBAAU,KAAV,EAAsB;AAC5B,UAAQ,WAAR,GAAwB,IAAxB,CAAQ,WAAR;;AAEA,MAAA,WAAW,CAAC,IAAZ,CAAiB,KAAjB;;AAEA,UAAI,WAAW,CAAC,MAAZ,GAAqB,CAAzB,EAA4B;AAG1B,YAAI,WAAW,CAAC,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B,UAAA,WAAW,CAAC,OAAZ,CAAoB,WAAW,CAAC,CAAD,CAA/B;AACD;;AAGD,YAAM,MAAM,GAAG,KAAK,qBAAL,CAA2B,WAAW,CAAC,CAAD,CAAtC,EAA2C,WAAW,CAAC,CAAD,CAAtD,CAAf;;AACA,YAAM,KAAK,GAAG,MAAM,CAAC,UAAP,CAAkB,WAAlB,EAA+B,MAA/B,CAAd;;AAGA,QAAA,WAAW,CAAC,KAAZ;;AAEA,eAAO,KAAP;AACD;;AAED,aAAO,IAAP;AACD;;;WAEO,+BACN,UADM,EAEN,QAFM,EAES;AAEf,UAAM,QAAQ,GACZ,KAAK,oBAAL,GAA4B,QAAQ,CAAC,YAAT,CAAsB,UAAtB,CAA5B,GACA,CAAC,IAAI,KAAK,oBAAV,IAAkC,KAAK,aAFzC;;AAIA,UAAM,QAAQ,GAAG,KAAK,YAAL,CAAkB,QAAlB,CAAjB;;AAEA,UAAM,MAAM,GAAG;AACb,QAAA,GAAG,EAAE,QADQ;AAEb,QAAA,KAAK,EAAE,KAAK;AAFC,OAAf;AAKA,WAAK,aAAL,GAAqB,QAArB;AACA,WAAK,UAAL,GAAkB,QAAlB;AAEA,aAAO,MAAP;AACD;;;WAEO,sBAAa,QAAb,EAA6B;AACnC,aAAO,IAAI,CAAC,GAAL,CAAS,KAAK,QAAL,IAAiB,QAAQ,GAAG,CAA5B,CAAT,EAAyC,KAAK,QAA9C,CAAP;AACD;;;WAEO,2BAAkB,CAAlB,EAA6B,CAA7B,EAAwC,KAAxC,EAAqD;AAC3D,UAAM,GAAG,GAAG,KAAK,IAAjB;AAEA,MAAA,GAAG,CAAC,MAAJ,CAAW,CAAX,EAAc,CAAd;AACA,MAAA,GAAG,CAAC,GAAJ,CAAQ,CAAR,EAAW,CAAX,EAAc,KAAd,EAAqB,CAArB,EAAwB,IAAI,IAAI,CAAC,EAAjC,EAAqC,KAArC;AACA,WAAK,QAAL,GAAgB,KAAhB;AACD;;;WAEO,2BAA6D;AAAA,UAAhD,KAAgD,SAAhD,KAAgD;AAAA,UAAzC,KAAyC,SAAzC,KAAyC;AACnE,UAAM,GAAG,GAAG,KAAK,IAAjB;AACA,UAAM,UAAU,GAAG,KAAK,CAAC,QAAN,GAAiB,KAAK,CAAC,UAA1C;AAGA,UAAM,SAAS,GAAG,IAAI,CAAC,KAAL,CAAW,KAAK,CAAC,MAAN,EAAX,IAA6B,CAA/C;AAEA,MAAA,GAAG,CAAC,SAAJ;AACA,MAAA,GAAG,CAAC,SAAJ,GAAgB,KAAhB;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAApB,EAA+B,CAAC,IAAI,CAApC,EAAuC;AAErC,YAAM,CAAC,GAAG,CAAC,GAAG,SAAd;AACA,YAAM,EAAE,GAAG,CAAC,GAAG,CAAf;AACA,YAAM,GAAG,GAAG,EAAE,GAAG,CAAjB;AACA,YAAM,CAAC,GAAG,IAAI,CAAd;AACA,YAAM,EAAE,GAAG,CAAC,GAAG,CAAf;AACA,YAAM,GAAG,GAAG,EAAE,GAAG,CAAjB;AAEA,YAAI,CAAC,GAAG,GAAG,GAAG,KAAK,CAAC,UAAN,CAAiB,CAA/B;AACA,QAAA,CAAC,IAAI,IAAI,EAAJ,GAAS,CAAT,GAAa,KAAK,CAAC,QAAN,CAAe,CAAjC;AACA,QAAA,CAAC,IAAI,IAAI,CAAJ,GAAQ,EAAR,GAAa,KAAK,CAAC,QAAN,CAAe,CAAjC;AACA,QAAA,CAAC,IAAI,GAAG,GAAG,KAAK,CAAC,QAAN,CAAe,CAA1B;AAEA,YAAI,CAAC,GAAG,GAAG,GAAG,KAAK,CAAC,UAAN,CAAiB,CAA/B;AACA,QAAA,CAAC,IAAI,IAAI,EAAJ,GAAS,CAAT,GAAa,KAAK,CAAC,QAAN,CAAe,CAAjC;AACA,QAAA,CAAC,IAAI,IAAI,CAAJ,GAAQ,EAAR,GAAa,KAAK,CAAC,QAAN,CAAe,CAAjC;AACA,QAAA,CAAC,IAAI,GAAG,GAAG,KAAK,CAAC,QAAN,CAAe,CAA1B;AAEA,YAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CACZ,KAAK,CAAC,UAAN,GAAmB,GAAG,GAAG,UADb,EAEZ,KAAK,QAFO,CAAd;;AAIA,aAAK,iBAAL,CAAuB,CAAvB,EAA0B,CAA1B,EAA6B,KAA7B;AACD;;AAED,MAAA,GAAG,CAAC,SAAJ;AACA,MAAA,GAAG,CAAC,IAAJ;AACD;;;WAEO,yBAMP;AAAA,UALC,KAKD,SALC,KAKD;AAAA,UAJC,KAID,SAJC,KAID;AACC,UAAM,GAAG,GAAG,KAAK,IAAjB;AACA,UAAM,KAAK,GACT,OAAO,KAAK,OAAZ,KAAwB,UAAxB,GAAqC,KAAK,OAAL,EAArC,GAAsD,KAAK,OAD7D;AAGA,MAAA,GAAG,CAAC,SAAJ;;AACA,WAAK,iBAAL,CAAuB,KAAK,CAAC,CAA7B,EAAgC,KAAK,CAAC,CAAtC,EAAyC,KAAzC;;AACA,MAAA,GAAG,CAAC,SAAJ;AACA,MAAA,GAAG,CAAC,SAAJ,GAAgB,KAAhB;AACA,MAAA,GAAG,CAAC,IAAJ;AACD;;;WAEO,mBACN,WADM,EAEN,SAFM,EAGN,OAHM,EAG2B;AAAA,iDAEb,WAFa;AAAA;;AAAA;AAEjC,4DAAiC;AAAA,cAAtB,KAAsB;AAC/B,cAAQ,KAAR,GAA0B,KAA1B,CAAQ,KAAR;AAAA,cAAe,MAAf,GAA0B,KAA1B,CAAe,MAAf;;AAEA,cAAI,MAAM,CAAC,MAAP,GAAgB,CAApB,EAAuB;AACrB,iBAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,IAAI,CAAxC,EAA2C;AACzC,kBAAM,UAAU,GAAG,MAAM,CAAC,CAAD,CAAzB;AACA,kBAAM,KAAK,GAAG,IAAI,KAAJ,CAAU,UAAU,CAAC,CAArB,EAAwB,UAAU,CAAC,CAAnC,EAAsC,UAAU,CAAC,IAAjD,CAAd;AAIA,mBAAK,QAAL,GAAgB,KAAhB;;AAEA,kBAAI,CAAC,KAAK,CAAV,EAAa;AACX,qBAAK,MAAL;AACD;;AAED,kBAAM,KAAK,GAAG,KAAK,SAAL,CAAe,KAAf,CAAd;;AAEA,kBAAI,KAAJ,EAAW;AACT,gBAAA,SAAS,CAAC;AAAE,kBAAA,KAAK,EAAL,KAAF;AAAS,kBAAA,KAAK,EAAL;AAAT,iBAAD,CAAT;AACD;AACF;AACF,WAnBD,MAmBO;AACL,iBAAK,MAAL;;AAEA,YAAA,OAAO,CAAC;AACN,cAAA,KAAK,EAAL,KADM;AAEN,cAAA,KAAK,EAAE,MAAM,CAAC,CAAD;AAFP,aAAD,CAAP;AAID;AACF;AAhCgC;AAAA;AAAA;AAAA;AAAA;AAiClC;;;WAEO,kBAAM;AAAA;;AACZ,UAAM,WAAW,GAAG,KAAK,KAAzB;AACA,UAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,gBAAP,IAA2B,CAApC,EAAuC,CAAvC,CAAd;AACA,UAAM,IAAI,GAAG,CAAb;AACA,UAAM,IAAI,GAAG,CAAb;AACA,UAAM,IAAI,GAAG,KAAK,MAAL,CAAY,KAAZ,GAAoB,KAAjC;AACA,UAAM,IAAI,GAAG,KAAK,MAAL,CAAY,MAAZ,GAAqB,KAAlC;AACA,UAAM,GAAG,GAAG,QAAQ,CAAC,eAAT,CAAyB,4BAAzB,EAAuD,KAAvD,CAAZ;AAEA,MAAA,GAAG,CAAC,YAAJ,CAAiB,OAAjB,EAA0B,KAAK,MAAL,CAAY,KAAZ,CAAkB,QAAlB,EAA1B;AACA,MAAA,GAAG,CAAC,YAAJ,CAAiB,QAAjB,EAA2B,KAAK,MAAL,CAAY,MAAZ,CAAmB,QAAnB,EAA3B;;AAEA,WAAK,SAAL,CACE,WADF,EAGE,iBAAmD;AAAA,YAAhD,KAAgD,SAAhD,KAAgD;AAAA,YAAzC,KAAyC,SAAzC,KAAyC;AACjD,YAAM,IAAI,GAAG,QAAQ,CAAC,aAAT,CAAuB,MAAvB,CAAb;;AAMA,YACE,CAAC,KAAK,CAAC,KAAK,CAAC,QAAN,CAAe,CAAhB,CAAN,IACA,CAAC,KAAK,CAAC,KAAK,CAAC,QAAN,CAAe,CAAhB,CADN,IAEA,CAAC,KAAK,CAAC,KAAK,CAAC,QAAN,CAAe,CAAhB,CAFN,IAGA,CAAC,KAAK,CAAC,KAAK,CAAC,QAAN,CAAe,CAAhB,CAJR,EAKE;AACA,cAAM,IAAI,GACR,YAAK,KAAK,CAAC,UAAN,CAAiB,CAAjB,CAAmB,OAAnB,CAA2B,CAA3B,CAAL,cAAsC,KAAK,CAAC,UAAN,CAAiB,CAAjB,CAAmB,OAAnB,CACpC,CADoC,CAAtC,qBAGK,KAAK,CAAC,QAAN,CAAe,CAAf,CAAiB,OAAjB,CAAyB,CAAzB,CAHL,cAGoC,KAAK,CAAC,QAAN,CAAe,CAAf,CAAiB,OAAjB,CAAyB,CAAzB,CAHpC,mBAIG,KAAK,CAAC,QAAN,CAAe,CAAf,CAAiB,OAAjB,CAAyB,CAAzB,CAJH,cAIkC,KAAK,CAAC,QAAN,CAAe,CAAf,CAAiB,OAAjB,CAAyB,CAAzB,CAJlC,mBAKG,KAAK,CAAC,QAAN,CAAe,CAAf,CAAiB,OAAjB,CAAyB,CAAzB,CALH,cAKkC,KAAK,CAAC,QAAN,CAAe,CAAf,CAAiB,OAAjB,CAAyB,CAAzB,CALlC,CADF;AAOA,UAAA,IAAI,CAAC,YAAL,CAAkB,GAAlB,EAAuB,IAAvB;AACA,UAAA,IAAI,CAAC,YAAL,CAAkB,cAAlB,EAAkC,CAAC,KAAK,CAAC,QAAN,GAAiB,IAAlB,EAAwB,OAAxB,CAAgC,CAAhC,CAAlC;AACA,UAAA,IAAI,CAAC,YAAL,CAAkB,QAAlB,EAA4B,KAA5B;AACA,UAAA,IAAI,CAAC,YAAL,CAAkB,MAAlB,EAA0B,MAA1B;AACA,UAAA,IAAI,CAAC,YAAL,CAAkB,gBAAlB,EAAoC,OAApC;AAEA,UAAA,GAAG,CAAC,WAAJ,CAAgB,IAAhB;AACD;AAEF,OAhCH,EAkCE,iBAAuD;AAAA,YAApD,KAAoD,SAApD,KAAoD;AAAA,YAA7C,KAA6C,SAA7C,KAA6C;AACrD,YAAM,MAAM,GAAG,QAAQ,CAAC,aAAT,CAAuB,QAAvB,CAAf;AACA,YAAM,OAAO,GACX,OAAO,MAAI,CAAC,OAAZ,KAAwB,UAAxB,GAAqC,MAAI,CAAC,OAAL,EAArC,GAAsD,MAAI,CAAC,OAD7D;AAEA,QAAA,MAAM,CAAC,YAAP,CAAoB,GAApB,EAAyB,OAAO,CAAC,QAAR,EAAzB;AACA,QAAA,MAAM,CAAC,YAAP,CAAoB,IAApB,EAA0B,KAAK,CAAC,CAAN,CAAQ,QAAR,EAA1B;AACA,QAAA,MAAM,CAAC,YAAP,CAAoB,IAApB,EAA0B,KAAK,CAAC,CAAN,CAAQ,QAAR,EAA1B;AACA,QAAA,MAAM,CAAC,YAAP,CAAoB,MAApB,EAA4B,KAA5B;AAEA,QAAA,GAAG,CAAC,WAAJ,CAAgB,MAAhB;AACD,OA5CH;;AA+CA,UAAM,MAAM,GAAG,4BAAf;AACA,UAAM,MAAM,GACV,SACA,qCADA,GAEA,6CAFA,wBAGa,IAHb,cAGqB,IAHrB,cAG6B,IAH7B,cAGqC,IAHrC,6BAIW,IAJX,8BAKY,IALZ,UAMA,GAPF;AAQA,UAAI,IAAI,GAAG,GAAG,CAAC,SAAf;;AAGA,UAAI,IAAI,KAAK,SAAb,EAAwB;AACtB,YAAM,KAAK,GAAG,QAAQ,CAAC,aAAT,CAAuB,OAAvB,CAAd;AACA,YAAM,KAAK,GAAG,GAAG,CAAC,UAAlB;AACA,QAAA,KAAK,CAAC,SAAN,GAAkB,EAAlB;;AAGA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,IAAI,CAAvC,EAA0C;AACxC,UAAA,KAAK,CAAC,WAAN,CAAkB,KAAK,CAAC,CAAD,CAAL,CAAS,SAAT,CAAmB,IAAnB,CAAlB;AACD;;AAED,QAAA,IAAI,GAAG,KAAK,CAAC,SAAb;AACD;;AAED,UAAM,MAAM,GAAG,QAAf;AACA,UAAM,IAAI,GAAG,MAAM,GAAG,IAAT,GAAgB,MAA7B;AAEA,aAAO,MAAM,GAAG,IAAI,CAAC,IAAD,CAApB;AACD","sourcesContent":["/*!\n * Signature Pad v3.0.0-beta.4 | https://github.com/szimek/signature_pad\n * (c) 2020 Szymon Nowak | Released under the MIT license\n */\n\nclass Point {\n    constructor(x, y, time) {\n        this.x = x;\n        this.y = y;\n        this.time = time || Date.now();\n    }\n    distanceTo(start) {\n        return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y && this.time === other.time;\n    }\n    velocityFrom(start) {\n        return this.time !== start.time\n            ? this.distanceTo(start) / (this.time - start.time)\n            : 0;\n    }\n}\n\nclass Bezier {\n    constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n        this.startPoint = startPoint;\n        this.control2 = control2;\n        this.control1 = control1;\n        this.endPoint = endPoint;\n        this.startWidth = startWidth;\n        this.endWidth = endWidth;\n    }\n    static fromPoints(points, widths) {\n        const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n        const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n        return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n    }\n    static calculateControlPoints(s1, s2, s3) {\n        const dx1 = s1.x - s2.x;\n        const dy1 = s1.y - s2.y;\n        const dx2 = s2.x - s3.x;\n        const dy2 = s2.y - s3.y;\n        const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n        const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n        const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n        const dxm = m1.x - m2.x;\n        const dym = m1.y - m2.y;\n        const k = l2 / (l1 + l2);\n        const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n        const tx = s2.x - cm.x;\n        const ty = s2.y - cm.y;\n        return {\n            c1: new Point(m1.x + tx, m1.y + ty),\n            c2: new Point(m2.x + tx, m2.y + ty),\n        };\n    }\n    length() {\n        const steps = 10;\n        let length = 0;\n        let px;\n        let py;\n        for (let i = 0; i <= steps; i += 1) {\n            const t = i / steps;\n            const cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n            const cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n            if (i > 0) {\n                const xdiff = cx - px;\n                const ydiff = cy - py;\n                length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n            }\n            px = cx;\n            py = cy;\n        }\n        return length;\n    }\n    point(t, start, c1, c2, end) {\n        return (start * (1.0 - t) * (1.0 - t) * (1.0 - t))\n            + (3.0 * c1 * (1.0 - t) * (1.0 - t) * t)\n            + (3.0 * c2 * (1.0 - t) * t * t)\n            + (end * t * t * t);\n    }\n}\n\nfunction throttle(fn, wait = 250) {\n    let previous = 0;\n    let timeout = null;\n    let result;\n    let storedContext;\n    let storedArgs;\n    const later = () => {\n        previous = Date.now();\n        timeout = null;\n        result = fn.apply(storedContext, storedArgs);\n        if (!timeout) {\n            storedContext = null;\n            storedArgs = [];\n        }\n    };\n    return function wrapper(...args) {\n        const now = Date.now();\n        const remaining = wait - (now - previous);\n        storedContext = this;\n        storedArgs = args;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            result = fn.apply(storedContext, storedArgs);\n            if (!timeout) {\n                storedContext = null;\n                storedArgs = [];\n            }\n        }\n        else if (!timeout) {\n            timeout = window.setTimeout(later, remaining);\n        }\n        return result;\n    };\n}\n\nclass SignaturePad {\n    constructor(canvas, options = {}) {\n        this.canvas = canvas;\n        this.options = options;\n        this._handleMouseDown = (event) => {\n            if (event.which === 1) {\n                this._mouseButtonDown = true;\n                this._strokeBegin(event);\n            }\n        };\n        this._handleMouseMove = (event) => {\n            if (this._mouseButtonDown) {\n                this._strokeMoveUpdate(event);\n            }\n        };\n        this._handleMouseUp = (event) => {\n            if (event.which === 1 && this._mouseButtonDown) {\n                this._mouseButtonDown = false;\n                this._strokeEnd(event);\n            }\n        };\n        this._handleTouchStart = (event) => {\n            event.preventDefault();\n            if (event.targetTouches.length === 1) {\n                const touch = event.changedTouches[0];\n                this._strokeBegin(touch);\n            }\n        };\n        this._handleTouchMove = (event) => {\n            event.preventDefault();\n            const touch = event.targetTouches[0];\n            this._strokeMoveUpdate(touch);\n        };\n        this._handleTouchEnd = (event) => {\n            const wasCanvasTouched = event.target === this.canvas;\n            if (wasCanvasTouched) {\n                event.preventDefault();\n                const touch = event.changedTouches[0];\n                this._strokeEnd(touch);\n            }\n        };\n        this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n        this.minWidth = options.minWidth || 0.5;\n        this.maxWidth = options.maxWidth || 2.5;\n        this.throttle = ('throttle' in options ? options.throttle : 16);\n        this.minDistance = ('minDistance' in options\n            ? options.minDistance\n            : 5);\n        this.dotSize =\n            options.dotSize ||\n                function dotSize() {\n                    return (this.minWidth + this.maxWidth) / 2;\n                };\n        this.penColor = options.penColor || 'black';\n        this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n        this.onBegin = options.onBegin;\n        this.onEnd = options.onEnd;\n        this._strokeMoveUpdate = this.throttle\n            ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)\n            : SignaturePad.prototype._strokeUpdate;\n        this._ctx = canvas.getContext('2d');\n        this.clear();\n        this.on();\n    }\n    clear() {\n        const { _ctx: ctx, canvas } = this;\n        ctx.fillStyle = this.backgroundColor;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        this._data = [];\n        this._reset();\n        this._isEmpty = true;\n    }\n    fromDataURL(dataUrl, options = {}, callback) {\n        const image = new Image();\n        const ratio = options.ratio || window.devicePixelRatio || 1;\n        const width = options.width || this.canvas.width / ratio;\n        const height = options.height || this.canvas.height / ratio;\n        this._reset();\n        image.onload = () => {\n            this._ctx.drawImage(image, 0, 0, width, height);\n            if (callback) {\n                callback();\n            }\n        };\n        image.onerror = (error) => {\n            if (callback) {\n                callback(error);\n            }\n        };\n        image.src = dataUrl;\n        this._isEmpty = false;\n    }\n    toDataURL(type = 'image/png', encoderOptions) {\n        switch (type) {\n            case 'image/svg+xml':\n                return this._toSVG();\n            default:\n                return this.canvas.toDataURL(type, encoderOptions);\n        }\n    }\n    on() {\n        this.canvas.style.touchAction = 'none';\n        this.canvas.style.msTouchAction = 'none';\n        if (window.PointerEvent) {\n            this._handlePointerEvents();\n        }\n        else {\n            this._handleMouseEvents();\n            if ('ontouchstart' in window) {\n                this._handleTouchEvents();\n            }\n        }\n    }\n    off() {\n        this.canvas.style.touchAction = 'auto';\n        this.canvas.style.msTouchAction = 'auto';\n        this.canvas.removeEventListener('pointerdown', this._handleMouseDown);\n        this.canvas.removeEventListener('pointermove', this._handleMouseMove);\n        document.removeEventListener('pointerup', this._handleMouseUp);\n        this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n        this.canvas.removeEventListener('mousemove', this._handleMouseMove);\n        document.removeEventListener('mouseup', this._handleMouseUp);\n        this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n        this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n        this.canvas.removeEventListener('touchend', this._handleTouchEnd);\n    }\n    isEmpty() {\n        return this._isEmpty;\n    }\n    fromData(pointGroups) {\n        this.clear();\n        this._fromData(pointGroups, ({ color, curve }) => this._drawCurve({ color, curve }), ({ color, point }) => this._drawDot({ color, point }));\n        this._data = pointGroups;\n    }\n    toData() {\n        return this._data;\n    }\n    _strokeBegin(event) {\n        const newPointGroup = {\n            color: this.penColor,\n            points: [],\n        };\n        if (typeof this.onBegin === 'function') {\n            this.onBegin(event);\n        }\n        this._data.push(newPointGroup);\n        this._reset();\n        this._strokeUpdate(event);\n    }\n    _strokeUpdate(event) {\n        if (this._data.length === 0) {\n            this._strokeBegin(event);\n            return;\n        }\n        const x = event.clientX;\n        const y = event.clientY;\n        const point = this._createPoint(x, y);\n        const lastPointGroup = this._data[this._data.length - 1];\n        const lastPoints = lastPointGroup.points;\n        const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n        const isLastPointTooClose = lastPoint\n            ? point.distanceTo(lastPoint) <= this.minDistance\n            : false;\n        const color = lastPointGroup.color;\n        if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n            const curve = this._addPoint(point);\n            if (!lastPoint) {\n                this._drawDot({ color, point });\n            }\n            else if (curve) {\n                this._drawCurve({ color, curve });\n            }\n            lastPoints.push({\n                time: point.time,\n                x: point.x,\n                y: point.y,\n            });\n        }\n    }\n    _strokeEnd(event) {\n        this._strokeUpdate(event);\n        if (typeof this.onEnd === 'function') {\n            this.onEnd(event);\n        }\n    }\n    _handlePointerEvents() {\n        this._mouseButtonDown = false;\n        this.canvas.addEventListener('pointerdown', this._handleMouseDown);\n        this.canvas.addEventListener('pointermove', this._handleMouseMove);\n        document.addEventListener('pointerup', this._handleMouseUp);\n    }\n    _handleMouseEvents() {\n        this._mouseButtonDown = false;\n        this.canvas.addEventListener('mousedown', this._handleMouseDown);\n        this.canvas.addEventListener('mousemove', this._handleMouseMove);\n        document.addEventListener('mouseup', this._handleMouseUp);\n    }\n    _handleTouchEvents() {\n        this.canvas.addEventListener('touchstart', this._handleTouchStart);\n        this.canvas.addEventListener('touchmove', this._handleTouchMove);\n        this.canvas.addEventListener('touchend', this._handleTouchEnd);\n    }\n    _reset() {\n        this._lastPoints = [];\n        this._lastVelocity = 0;\n        this._lastWidth = (this.minWidth + this.maxWidth) / 2;\n        this._ctx.fillStyle = this.penColor;\n    }\n    _createPoint(x, y) {\n        const rect = this.canvas.getBoundingClientRect();\n        return new Point(x - rect.left, y - rect.top, new Date().getTime());\n    }\n    _addPoint(point) {\n        const { _lastPoints } = this;\n        _lastPoints.push(point);\n        if (_lastPoints.length > 2) {\n            if (_lastPoints.length === 3) {\n                _lastPoints.unshift(_lastPoints[0]);\n            }\n            const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2]);\n            const curve = Bezier.fromPoints(_lastPoints, widths);\n            _lastPoints.shift();\n            return curve;\n        }\n        return null;\n    }\n    _calculateCurveWidths(startPoint, endPoint) {\n        const velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n            (1 - this.velocityFilterWeight) * this._lastVelocity;\n        const newWidth = this._strokeWidth(velocity);\n        const widths = {\n            end: newWidth,\n            start: this._lastWidth,\n        };\n        this._lastVelocity = velocity;\n        this._lastWidth = newWidth;\n        return widths;\n    }\n    _strokeWidth(velocity) {\n        return Math.max(this.maxWidth / (velocity + 1), this.minWidth);\n    }\n    _drawCurveSegment(x, y, width) {\n        const ctx = this._ctx;\n        ctx.moveTo(x, y);\n        ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n        this._isEmpty = false;\n    }\n    _drawCurve({ color, curve }) {\n        const ctx = this._ctx;\n        const widthDelta = curve.endWidth - curve.startWidth;\n        const drawSteps = Math.floor(curve.length()) * 2;\n        ctx.beginPath();\n        ctx.fillStyle = color;\n        for (let i = 0; i < drawSteps; i += 1) {\n            const t = i / drawSteps;\n            const tt = t * t;\n            const ttt = tt * t;\n            const u = 1 - t;\n            const uu = u * u;\n            const uuu = uu * u;\n            let x = uuu * curve.startPoint.x;\n            x += 3 * uu * t * curve.control1.x;\n            x += 3 * u * tt * curve.control2.x;\n            x += ttt * curve.endPoint.x;\n            let y = uuu * curve.startPoint.y;\n            y += 3 * uu * t * curve.control1.y;\n            y += 3 * u * tt * curve.control2.y;\n            y += ttt * curve.endPoint.y;\n            const width = Math.min(curve.startWidth + ttt * widthDelta, this.maxWidth);\n            this._drawCurveSegment(x, y, width);\n        }\n        ctx.closePath();\n        ctx.fill();\n    }\n    _drawDot({ color, point, }) {\n        const ctx = this._ctx;\n        const width = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;\n        ctx.beginPath();\n        this._drawCurveSegment(point.x, point.y, width);\n        ctx.closePath();\n        ctx.fillStyle = color;\n        ctx.fill();\n    }\n    _fromData(pointGroups, drawCurve, drawDot) {\n        for (const group of pointGroups) {\n            const { color, points } = group;\n            if (points.length > 1) {\n                for (let j = 0; j < points.length; j += 1) {\n                    const basicPoint = points[j];\n                    const point = new Point(basicPoint.x, basicPoint.y, basicPoint.time);\n                    this.penColor = color;\n                    if (j === 0) {\n                        this._reset();\n                    }\n                    const curve = this._addPoint(point);\n                    if (curve) {\n                        drawCurve({ color, curve });\n                    }\n                }\n            }\n            else {\n                this._reset();\n                drawDot({\n                    color,\n                    point: points[0],\n                });\n            }\n        }\n    }\n    _toSVG() {\n        const pointGroups = this._data;\n        const ratio = Math.max(window.devicePixelRatio || 1, 1);\n        const minX = 0;\n        const minY = 0;\n        const maxX = this.canvas.width / ratio;\n        const maxY = this.canvas.height / ratio;\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.setAttribute('width', this.canvas.width.toString());\n        svg.setAttribute('height', this.canvas.height.toString());\n        this._fromData(pointGroups, ({ color, curve }) => {\n            const path = document.createElement('path');\n            if (!isNaN(curve.control1.x) &&\n                !isNaN(curve.control1.y) &&\n                !isNaN(curve.control2.x) &&\n                !isNaN(curve.control2.y)) {\n                const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} ` +\n                    `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +\n                    `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +\n                    `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n                path.setAttribute('d', attr);\n                path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n                path.setAttribute('stroke', color);\n                path.setAttribute('fill', 'none');\n                path.setAttribute('stroke-linecap', 'round');\n                svg.appendChild(path);\n            }\n        }, ({ color, point }) => {\n            const circle = document.createElement('circle');\n            const dotSize = typeof this.dotSize === 'function' ? this.dotSize() : this.dotSize;\n            circle.setAttribute('r', dotSize.toString());\n            circle.setAttribute('cx', point.x.toString());\n            circle.setAttribute('cy', point.y.toString());\n            circle.setAttribute('fill', color);\n            svg.appendChild(circle);\n        });\n        const prefix = 'data:image/svg+xml;base64,';\n        const header = '<svg' +\n            ' xmlns=\"http://www.w3.org/2000/svg\"' +\n            ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"' +\n            ` viewBox=\"${minX} ${minY} ${maxX} ${maxY}\"` +\n            ` width=\"${maxX}\"` +\n            ` height=\"${maxY}\"` +\n            '>';\n        let body = svg.innerHTML;\n        if (body === undefined) {\n            const dummy = document.createElement('dummy');\n            const nodes = svg.childNodes;\n            dummy.innerHTML = '';\n            for (let i = 0; i < nodes.length; i += 1) {\n                dummy.appendChild(nodes[i].cloneNode(true));\n            }\n            body = dummy.innerHTML;\n        }\n        const footer = '</svg>';\n        const data = header + body + footer;\n        return prefix + btoa(data);\n    }\n}\n\nexport default SignaturePad;\n//# sourceMappingURL=signature_pad.js.map\n"]},"metadata":{},"sourceType":"module"}