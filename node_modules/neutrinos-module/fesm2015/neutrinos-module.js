import { __decorate } from 'tslib';
import { Injectable, EventEmitter, Input, Output, HostListener, Directive, Renderer2, ViewChild, Component, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HttpHeaders, HttpClient, HttpClientModule } from '@angular/common/http';
import { FormsModule } from '@angular/forms';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { FlexLayoutModule } from '@angular/flex-layout';
import { NSystemService, NeutrinosSeedServicesModule } from 'neutrinos-seed-services';
import { MatIconModule } from '@angular/material/icon';
import { MatDialogRef, MatDialog, MatDialogModule } from '@angular/material/dialog';
import { MatButtonModule } from '@angular/material/button';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import signing__default from 'signature_pad';

let NFileIOService = class NFileIOService {
    constructor(http) {
        this.http = http;
        this.checkFileExist = (path, fileName, i, callback) => {
            return window.resolveLocalFileSystemURL(path + fileName, () => {
                let length = 4;
                if (fileName.lastIndexOf('(') > -1) {
                    const isExist = parseInt(fileName.slice((fileName.lastIndexOf('(') + 1), fileName.lastIndexOf(')')), 10);
                    if (!isNaN(isExist)) {
                        i = isExist + 1;
                        if (i > 10 && i < 100) {
                            length += 1;
                        }
                        else if (i > 100) {
                            length += 2;
                        }
                        fileName = fileName.slice(0, (fileName.lastIndexOf('.') - length)) + ' (' + i + ')' + fileName.slice(fileName.lastIndexOf('.'));
                    }
                    else {
                        i += 1;
                        fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + fileName.slice(fileName.lastIndexOf('.'));
                        fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + ' (' + i + ')' + fileName.slice(fileName.lastIndexOf('.'));
                    }
                }
                else {
                    i += 1;
                    fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + fileName.slice(fileName.lastIndexOf('.'));
                    fileName = fileName.slice(0, (fileName.lastIndexOf('.'))) + ' (' + i + ')' + fileName.slice(fileName.lastIndexOf('.'));
                }
                return this.checkFileExist(path, fileName, i, callback);
            }, () => {
                return callback(fileName);
            });
        };
        this.systemService = NSystemService.getInstance();
        this.appProperties = this.systemService.getVal('properties');
    }
    getFileInfo(options) {
        let dataModelURL = this.systemService.getDataModelUrl();
        if (options.metadata) {
            dataModelURL += `${this.appProperties.appName}_${options.entityName}.files?filter={"metadata.key": "${options.metadata.key}"}`;
        }
        else {
            dataModelURL += `${this.appProperties.appName}_${options.entityName}.files/${options.fileId}`;
        }
        return this.http.get(dataModelURL);
    }
    getFormData(fileUri) {
        return new Promise((resolve, reject) => {
            window.resolveLocalFileSystemURL(fileUri, (fileEntry) => {
                fileEntry.file((file) => {
                    const reader = new FileReader();
                    reader.onerror = evt => {
                        return reject(evt);
                    };
                    reader.onloadend = evt => {
                        const formData = new FormData();
                        const blob = new Blob([new Uint8Array(reader.result)], { type: file.type });
                        formData.append('file', blob, file.name);
                        return resolve(formData);
                    };
                    reader.readAsArrayBuffer(file);
                });
            }, (error) => {
                return reject(error);
            });
        });
    }
    getPicture(cameraOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                navigator.camera.getPicture((imageUri) => {
                    this.getFormData(imageUri).then(res => {
                        return resolve(res);
                    }).catch(err => reject(err));
                }, (error) => {
                    return reject(error);
                }, cameraOptions);
            }, false);
        });
    }
    scanPicture(scanOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (scanOptions.hasOwnProperty('sourceType') && scanOptions.hasOwnProperty('doUpload')) {
                    scan.scanDoc(scanOptions.sourceType, (imageUri) => {
                        if (scanOptions.doUpload) {
                            this.getFormData(imageUri).then(res => {
                                return resolve(res);
                            }).catch(err => reject(err));
                        }
                        else {
                            resolve(imageUri);
                        }
                    }, (error) => {
                        return reject(error);
                    });
                }
                else {
                    reject('sourceType not found');
                }
            }, false);
        });
    }
    //Barcode
    getBarcode(barcodeOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                cordova.plugins.barcodeScanner.scan((result) => {
                    if (result.cancelled) {
                        return reject(result);
                    }
                    else {
                        return resolve(result);
                    }
                }, (error) => {
                    return reject(error);
                }, barcodeOptions);
            }, false);
        });
    }
    //Video
    getVideo(videoOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                navigator.device.capture.captureVideo((mediaFiles) => {
                    var imageUri = mediaFiles[0].fullPath;
                    this.getFormData(imageUri).then(res => {
                        return resolve(res);
                    }).catch(err => reject(err));
                }, (error) => {
                    return reject(error);
                }, {});
            }, false);
        });
    }
    //tts
    getTts(ttsOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (ttsOptions.hasOwnProperty('text')) {
                    TTS.speak(ttsOptions).then(() => {
                        return resolve('success');
                    }, (reason) => {
                        return reject(reason);
                    });
                }
                else {
                    reject('text not found');
                }
            }, false);
        });
    }
    //shake
    getShake(shakeOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (shakeOptions.hasOwnProperty('start') && shakeOptions.hasOwnProperty('sensitivity')) {
                    if (shakeOptions.start) {
                        shake.startWatch(() => {
                            return resolve('success');
                        }, shakeOptions.sensitivity, () => {
                            return reject('error');
                        });
                    }
                    else {
                        shake.stopWatch();
                    }
                }
                else {
                    reject('start or sensitivity not found');
                }
            }, false);
        });
    }
    //ocr
    getOcr(ocrOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (ocrOptions.hasOwnProperty('uriOrBase') && ocrOptions.hasOwnProperty('returnType')) {
                    navigator.camera.getPicture((imageData) => {
                        textocr.recText(ocrOptions.uriOrBase, ocrOptions.returnType, imageData, (recognizedText) => {
                            return resolve(recognizedText);
                        }, (message) => {
                            return reject(message);
                        });
                    }, (message) => {
                        return reject(message);
                    }, ocrOptions);
                }
                else {
                    reject('uriOrBase or returnType not found');
                }
            }, false);
        });
    }
    //fingerprint
    getFingerprint(fingerprintOptions) {
        return new Promise((resolve, reject) => {
            document.addEventListener('deviceready', () => {
                if (fingerprintOptions.hasOwnProperty('clientId') && fingerprintOptions.hasOwnProperty('clientSecret')) {
                    Fingerprint.isAvailable((result) => {
                        Fingerprint.show(fingerprintOptions, () => {
                            return resolve('success');
                        }, (err) => {
                            return reject(err);
                        });
                    }, (message) => {
                        return reject(message);
                    });
                }
                else {
                    reject('clientId or clientSecret not found');
                }
            }, false);
        });
    }
    upload(options) {
        return new Promise((resolve, reject) => {
            let body = new FormData();
            if (options.formData) {
                body = options.formData;
            }
            else if (options.files) {
                body.append('file', options.files);
            }
            else {
                reject('No file selected!');
            }
            if (options.metadata) {
                body.append('metadata', JSON.stringify(options.metadata));
            }
            const headers = { 'Content-Type': 'no-content' };
            const url = this.systemService.getFileIOUrl() + `${options.entityName}`;
            let temp_headers = { headers: this.setHeaders(headers) };
            this.http.post(url, body, temp_headers)
                .subscribe(res => resolve(res), err => reject(err));
        });
    }
    download(options) {
        return new Promise((resolve, reject) => {
            if (options.entityName && (options.metadata || options.fileId)) {
                this.getFileInfo(options).subscribe((res) => {
                    if (options.metadata) {
                        res = res[res.length - 1];
                    }
                    else {
                        res = res.result;
                    }
                    const fileInfo = {
                        contentType: '',
                        filename: ''
                    };
                    if (res && res['contentType'] && res['filename']) {
                        fileInfo['contentType'] = res['contentType'];
                        fileInfo['filename'] = res['filename'];
                        let fileIOURL = this.systemService.getFileIOUrl();
                        if (options.metadata) {
                            fileIOURL += `${options.entityName}?metadataFilter={"metadata.key": "${options.metadata.key}"}`;
                        }
                        else {
                            fileIOURL += `${options.entityName}/${options.fileId}`;
                        }
                        const headers = {
                            'Accept': fileInfo.contentType
                        };
                        this.http.get(fileIOURL, { headers: this.setHeaders(headers), responseType: 'blob' }).subscribe((response) => {
                            const blob = new Blob([response.body], { type: fileInfo.contentType });
                            this.saveFile(blob, fileInfo.filename).then((resp) => {
                            }).catch(err => reject(err));
                        }, err => reject(err));
                    }
                    else {
                        reject('fileInfo not exit');
                    }
                }, err => reject(err));
            }
            else {
                return reject('download options not found');
            }
        });
    }
    saveFile(data, filename) {
        return new Promise((resolve, reject) => {
            if (this.systemService.checkDevice() == 'mobile') {
                const storageLocation = this.systemService.isAndroid() ? cordova.file.externalRootDirectory : cordova.file.documentsDirectory;
                this.createDirectory(storageLocation, this.appProperties.appName, filename, data)
                    .then(res => resolve(res))
                    .catch(err => reject(err));
            }
            else {
                this.saveToBrowser(data, filename).then(res => resolve(res));
            }
        });
    }
    saveToBrowser(data, fileName) {
        return new Promise((resolve) => {
            // Edge 20+
            const isEdge = !( /*@cc_on!@*/false || !!document['documentMode']) && !!window.StyleMedia;
            if (isEdge) {
                window.navigator.msSaveBlob(data, fileName);
            }
            else {
                const downloadURL = window.URL.createObjectURL(data);
                const anchor = document.createElement('a');
                document.body.appendChild(anchor);
                anchor.style.display = 'none';
                anchor.download = fileName;
                anchor.href = downloadURL;
                anchor.click();
                window.URL.revokeObjectURL(downloadURL);
                document.body.removeChild(anchor);
                anchor.remove();
            }
            return resolve('download complete');
        });
    }
    createDirectory(rootDirectory, appName, fileName, data) {
        return new Promise((resolve, reject) => {
            window.resolveLocalFileSystemURL(rootDirectory, (fileSystem) => {
                fileSystem.getDirectory(appName, { create: true }, (dirEntry) => {
                    this.checkFileExist(dirEntry.nativeURL, fileName, 0, (newFileName) => {
                        dirEntry.getFile(newFileName, { create: true }, (targetFile) => {
                            targetFile.createWriter((fileWriter) => {
                                fileWriter.onwriteend = () => {
                                    return resolve(targetFile.toURL());
                                };
                                fileWriter.onerror = (err) => {
                                    return reject(err);
                                };
                                fileWriter.write(data);
                            });
                        });
                    });
                }, err => reject(err));
            }, err => reject(err));
        });
    }
    setHeaders(headerJSON) {
        let headers = new HttpHeaders();
        for (const key in headerJSON) {
            if (key) {
                headers = headers.set(key, headerJSON[key]);
            }
        }
        return headers;
    }
};
NFileIOService.ctorParameters = () => [
    { type: HttpClient }
];
NFileIOService = __decorate([
    Injectable()
], NFileIOService);

let NCameraDirective = class NCameraDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getPicture()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getPicture() {
        return new Promise((resolve, reject) => {
            this.fsv.getPicture(this.cameraOptions).then(res => {
                const options = {
                    'formData': res,
                    'entityName': this.cameraOptions.entityName,
                    'metadata': this.cameraOptions.metadata
                };
                this.fsv.upload(options)
                    .then(uri => resolve(uri))
                    .catch(err => reject(err));
            }).catch(err => reject(err));
        });
    }
};
NCameraDirective.ctorParameters = () => [
    { type: NFileIOService }
];
__decorate([
    Input()
], NCameraDirective.prototype, "cameraOptions", void 0);
__decorate([
    Output()
], NCameraDirective.prototype, "onsuccess", void 0);
__decorate([
    Output()
], NCameraDirective.prototype, "onerror", void 0);
__decorate([
    HostListener('click')
], NCameraDirective.prototype, "methodToHandleMouseClickAction", null);
NCameraDirective = __decorate([
    Directive({
        selector: '[n-camera]'
    })
], NCameraDirective);

let NDownloadDirective = class NDownloadDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.downloadFile()
            .then(res => this.onsuccess.emit(res))
            .catch(err => this.onerror.emit(err));
    }
    downloadFile() {
        return this.fsv.download(this.downloadOptions);
    }
};
NDownloadDirective.ctorParameters = () => [
    { type: NFileIOService }
];
__decorate([
    Input()
], NDownloadDirective.prototype, "downloadOptions", void 0);
__decorate([
    Output()
], NDownloadDirective.prototype, "onsuccess", void 0);
__decorate([
    Output()
], NDownloadDirective.prototype, "onerror", void 0);
__decorate([
    HostListener('click')
], NDownloadDirective.prototype, "methodToHandleMouseClickAction", null);
NDownloadDirective = __decorate([
    Directive({ selector: '[n-download]' })
], NDownloadDirective);

let NScanDirective = class NScanDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getPicture()
            .then((sucess) => this.onsuccess.emit(sucess))
            .catch((error) => this.onerror.emit(error));
    }
    getPicture() {
        return new Promise((resolve, reject) => {
            this.fsv.scanPicture(this.scanOptions).then(res => {
                if (this.scanOptions.doUpload) {
                    const options = {
                        'formData': res,
                        'entityName': this.scanOptions.entityName,
                        'metadata': this.scanOptions.metadata
                    };
                    this.fsv.upload(options).then(uri => {
                        resolve(uri);
                    }).catch(err => reject(err));
                }
                else {
                    resolve(res);
                }
            }).catch((err) => {
                return reject(err);
            });
        });
    }
};
NScanDirective.ctorParameters = () => [
    { type: NFileIOService }
];
__decorate([
    Input()
], NScanDirective.prototype, "scanOptions", void 0);
__decorate([
    Output()
], NScanDirective.prototype, "onsuccess", void 0);
__decorate([
    Output()
], NScanDirective.prototype, "onerror", void 0);
__decorate([
    HostListener('click')
], NScanDirective.prototype, "methodToHandleMouseClickAction", null);
NScanDirective = __decorate([
    Directive({
        selector: '[n-scan]'
    })
], NScanDirective);

let NVideoDirective = class NVideoDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getVideo()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getVideo() {
        return new Promise((resolve, reject) => {
            this.fsv.getVideo(this.videoOptions).then(res => {
                const options = {
                    'formData': res,
                    'entityName': this.videoOptions.entityName,
                    'metadata': this.videoOptions.metadata
                };
                this.fsv.upload(options)
                    .then(uri => resolve(uri))
                    .catch(err => reject(err));
            }).catch(err => reject(err));
        });
    }
};
NVideoDirective.ctorParameters = () => [
    { type: NFileIOService }
];
__decorate([
    Input()
], NVideoDirective.prototype, "videoOptions", void 0);
__decorate([
    Output()
], NVideoDirective.prototype, "onsuccess", void 0);
__decorate([
    Output()
], NVideoDirective.prototype, "onerror", void 0);
__decorate([
    HostListener('click')
], NVideoDirective.prototype, "methodToHandleMouseClickAction", null);
NVideoDirective = __decorate([
    Directive({
        selector: '[n-video]'
    })
], NVideoDirective);

let NBarcodeDirective = class NBarcodeDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getBarcode()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getBarcode() {
        return new Promise((resolve, reject) => {
            this.fsv.getBarcode(this.barcodeOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
};
NBarcodeDirective.ctorParameters = () => [
    { type: NFileIOService }
];
__decorate([
    Input()
], NBarcodeDirective.prototype, "barcodeOptions", void 0);
__decorate([
    Output()
], NBarcodeDirective.prototype, "onsuccess", void 0);
__decorate([
    Output()
], NBarcodeDirective.prototype, "onerror", void 0);
__decorate([
    HostListener('click')
], NBarcodeDirective.prototype, "methodToHandleMouseClickAction", null);
NBarcodeDirective = __decorate([
    Directive({
        selector: '[n-barcode]'
    })
], NBarcodeDirective);

let NTtsDirective = class NTtsDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getTts()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getTts() {
        return new Promise((resolve, reject) => {
            this.fsv.getTts(this.ttsOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
};
NTtsDirective.ctorParameters = () => [
    { type: NFileIOService }
];
__decorate([
    Input()
], NTtsDirective.prototype, "ttsOptions", void 0);
__decorate([
    Output()
], NTtsDirective.prototype, "onsuccess", void 0);
__decorate([
    Output()
], NTtsDirective.prototype, "onerror", void 0);
__decorate([
    HostListener('click')
], NTtsDirective.prototype, "methodToHandleMouseClickAction", null);
NTtsDirective = __decorate([
    Directive({
        selector: '[n-tts]'
    })
], NTtsDirective);

let NFingerprintDirective = class NFingerprintDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getFingerprint()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getFingerprint() {
        return new Promise((resolve, reject) => {
            this.fsv.getFingerprint(this.fingerprintOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
};
NFingerprintDirective.ctorParameters = () => [
    { type: NFileIOService }
];
__decorate([
    Input()
], NFingerprintDirective.prototype, "fingerprintOptions", void 0);
__decorate([
    Output()
], NFingerprintDirective.prototype, "onsuccess", void 0);
__decorate([
    Output()
], NFingerprintDirective.prototype, "onerror", void 0);
__decorate([
    HostListener('click')
], NFingerprintDirective.prototype, "methodToHandleMouseClickAction", null);
NFingerprintDirective = __decorate([
    Directive({
        selector: '[n-fingerprint]'
    })
], NFingerprintDirective);

let NOcrDirective = class NOcrDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getOcr()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getOcr() {
        return new Promise((resolve, reject) => {
            this.fsv.getOcr(this.ocrOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
};
NOcrDirective.ctorParameters = () => [
    { type: NFileIOService }
];
__decorate([
    Input()
], NOcrDirective.prototype, "ocrOptions", void 0);
__decorate([
    Output()
], NOcrDirective.prototype, "onsuccess", void 0);
__decorate([
    Output()
], NOcrDirective.prototype, "onerror", void 0);
__decorate([
    HostListener('click')
], NOcrDirective.prototype, "methodToHandleMouseClickAction", null);
NOcrDirective = __decorate([
    Directive({
        selector: '[n-ocr]'
    })
], NOcrDirective);

let NShakeDirective = class NShakeDirective {
    constructor(fsv) {
        this.fsv = fsv;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    methodToHandleMouseClickAction() {
        this.getShake()
            .then(sucess => this.onsuccess.emit(sucess))
            .catch(error => this.onerror.emit(error));
    }
    getShake() {
        return new Promise((resolve, reject) => {
            this.fsv.getShake(this.shakeOptions).then(res => {
                return resolve(res);
            }).catch(err => reject(err));
        });
    }
};
NShakeDirective.ctorParameters = () => [
    { type: NFileIOService }
];
__decorate([
    Input()
], NShakeDirective.prototype, "shakeOptions", void 0);
__decorate([
    Output()
], NShakeDirective.prototype, "onsuccess", void 0);
__decorate([
    Output()
], NShakeDirective.prototype, "onerror", void 0);
__decorate([
    HostListener('click')
], NShakeDirective.prototype, "methodToHandleMouseClickAction", null);
NShakeDirective = __decorate([
    Directive({
        selector: '[n-shake]'
    })
], NShakeDirective);

let NFileUploadComponent = class NFileUploadComponent {
    constructor(fileIOService, _renderer) {
        this.fileIOService = fileIOService;
        this._renderer = _renderer;
        this.onsuccess = new EventEmitter();
        this.onerror = new EventEmitter();
    }
    /**
     * Method executed when upload button is clicked.
     */
    handleUpload() {
        this.isDone = false;
        if (this.file && this.uploadOptions && this.uploadOptions.entityName && this.uploadOptions.metadata) {
            this.fileIOService.upload({ files: this.file, entityName: this.uploadOptions.entityName, metadata: this.uploadOptions.metadata })
                .then((res) => {
                this.isDone = true;
                this.onsuccess.emit(res);
            })
                .catch(err => this.onerror.emit(err));
        }
        else {
            this.onerror.emit(new Error('Upload options missing'));
        }
    }
    /**
     * Method executed when a file is selected.
     */
    handleSelect(fileInput) {
        if (fileInput.target.files && fileInput.target.files[0]) {
            this.file = fileInput.target.files[0];
            this.fileName = this.file.name;
        }
    }
    /**
     * Methods executed when cancel button is clicked.
     * Clears files.
     */
    cancel() {
        this.file = null;
        this.fileName = null;
        this.isDone = false;
        // check if the file input is rendered before clearing it
        if (this.fileInput) {
            this._renderer.setProperty(this.fileInput, 'value', '');
        }
    }
    disableFileUploadButton() {
        if (typeof this.disableButton === 'boolean') {
            return this.disableButton;
        }
        return this.disableButton === 'disabled' || this.disableButton === 'true' ? true : false;
    }
};
NFileUploadComponent.ctorParameters = () => [
    { type: NFileIOService },
    { type: Renderer2 }
];
__decorate([
    ViewChild('fileInput', { static: false })
], NFileUploadComponent.prototype, "fileInput", void 0);
__decorate([
    Input()
], NFileUploadComponent.prototype, "uploadOptions", void 0);
__decorate([
    Input('disabled')
], NFileUploadComponent.prototype, "disableButton", void 0);
__decorate([
    Output()
], NFileUploadComponent.prototype, "onsuccess", void 0);
__decorate([
    Output()
], NFileUploadComponent.prototype, "onerror", void 0);
NFileUploadComponent = __decorate([
    Component({
        selector: 'n-file-upload',
        template: "<div>\n  <button mat-raised-button class=\"bh-file-upload\" (click)=\"fileInput.click()\" color=\"primary\"\n    *ngIf=\"!fileName\" [disabled]=\"disableFileUploadButton()\">\n    <mat-icon>attach_file</mat-icon>\n    <span>Choose a file...</span>\n    <input #fileInput type=\"file\" (change)=\"handleSelect($event)\" style=\"display:none;\" />\n  </button>\n  <div *ngIf=\"fileName\">\n    <button mat-raised-button color=\"primary\" (click)=\"handleUpload()\">\n      <mat-icon>file_upload</mat-icon>\n      <span>{{fileName}}</span>\n    </button>\n    <button *ngIf=\"!isDone\" mat-icon-button color=\"warn\" (click)=\"cancel()\" class=\"bh-file-upload-cancel\">\n      <mat-icon>cancel</mat-icon>\n    </button>\n    <button *ngIf=\"isDone\" mat-icon-button (click)=\"cancel()\" class=\"bh-file-upload-done\">\n      <mat-icon>done</mat-icon>\n    </button>\n  </div>\n</div>\n",
        styles: [".bh-file-upload{padding-left:8px;padding-right:8px}.bh-file-upload-cancel{height:24px;width:24px;position:relative;top:24px;left:-12px}::ng-deep [dir=rtl] .bh-file-upload-cancel{right:-12px;left:0}.bh-file-upload-cancel mat-icon{border-radius:12px;vertical-align:baseline}.bh-file-upload-done{height:24px;width:24px;position:relative;top:20px;left:-13px}::ng-deep [dir=rtl] .bh-file-upload-done{right:-12px;left:0}.bh-file-upload-done mat-icon{border-radius:12px;vertical-align:baseline}"]
    })
], NFileUploadComponent);

var NAlertComponent_1;
let NAlertComponent = NAlertComponent_1 = class NAlertComponent {
    constructor(dialogRef) {
        this.dialogRef = dialogRef;
        this.messageContent = NAlertComponent_1.message;
        this.titleContent = NAlertComponent_1.title;
    }
};
NAlertComponent.title = '';
NAlertComponent.message = '';
NAlertComponent.ctorParameters = () => [
    { type: MatDialogRef }
];
NAlertComponent = NAlertComponent_1 = __decorate([
    Component({
        selector: 'n-alert-dialog',
        template: "\n<div class=\"alertContainer\" fxLayout=\"column\">\n  <h4 mat-dialog-title>{{titleContent}}</h4>\n  <span class=\"msgContainer\" >{{messageContent}}</span>\n  <button mat-raised-button (click)=\"dialogRef.close()\">Close</button>\n</div>\n",
        styles: [".alertContainer{height:auto;width:auto}.msgContainer{margin-bottom:.5em}"]
    })
], NAlertComponent);

let NAlertService = class NAlertService {
    constructor(dialog) {
        this.dialog = dialog;
    }
    alert(message, title, data) {
        NAlertComponent.message = message;
        NAlertComponent.title = title;
        this.dialog.open(NAlertComponent, data);
    }
};
NAlertService.ctorParameters = () => [
    { type: MatDialog }
];
NAlertService = __decorate([
    Injectable()
], NAlertService);

let NToggleoptionsComponent = class NToggleoptionsComponent {
    constructor() {
        // options = {icon: 'home', value: 'home', disabled: false, 'checked': false}
        this.toggleOptions = [];
        this.align = 'horizontal';
        this.indexChange = new EventEmitter();
        this.valueChange = new EventEmitter();
    }
    // constructor(private snackbar: MatSnackBar) {
    // }
    ngOnInit() {
        if (this.checkNumber(this.checkedIndex)) {
            this.checkedIndex = Number(this.checkedIndex);
        }
        if (this.checkNumber(this.disabledIndex)) {
            this.disabledIndex = Number(this.disabledIndex);
        }
    }
    ngOnChanges(changes) {
        if (changes['checkedIndex'] && this.checkNumber(this.checkedIndex)) {
            this.checkedIndex = Number(this.checkedIndex);
        }
        else if (changes['disabledIndex'] && this.checkNumber(this.disabledIndex)) {
            this.disabledIndex = Number(this.disabledIndex);
        }
    }
    optionClicked(index) {
        if (this.toggleOptions && this.toggleOptions.length > 0) {
            this.indexChange.emit(index);
            if (this.toggleOptions[index] && this.toggleOptions[index].value) {
                this.valueChange.emit(this.toggleOptions[index].value);
            }
            else {
                // this.snackbar.open('Invalid toggle button value', 'OK');
            }
        }
        else {
            // this.snackbar.open('Invalid toggle options', 'OK');
        }
    }
    checkNumber(number) {
        if (number !== undefined && number !== null) {
            return Number.isNaN(Number(number));
        }
        return false;
    }
};
__decorate([
    Input('toggleOptions')
], NToggleoptionsComponent.prototype, "toggleOptions", void 0);
__decorate([
    Input('align')
], NToggleoptionsComponent.prototype, "align", void 0);
__decorate([
    Input('disabledIndex')
], NToggleoptionsComponent.prototype, "disabledIndex", void 0);
__decorate([
    Input('checkedIndex')
], NToggleoptionsComponent.prototype, "checkedIndex", void 0);
__decorate([
    Input('value')
], NToggleoptionsComponent.prototype, "value", void 0);
__decorate([
    Output()
], NToggleoptionsComponent.prototype, "indexChange", void 0);
__decorate([
    Output()
], NToggleoptionsComponent.prototype, "valueChange", void 0);
NToggleoptionsComponent = __decorate([
    Component({
        selector: 'n-toggleoptions',
        template: "<mat-button-toggle-group #group=\"matButtonToggleGroup\" [vertical]=\"align == 'vertical'? true: false\" [value]=\"value\">\n    <mat-button-toggle *ngFor=\"let option of toggleOptions; let i = index;\" [value]=\"option.value\" [disabled]=\"option.disabled || disabledIndex == i\" [checked]=\"option.checked || checkedIndex == i\" (click)=\"optionClicked(i)\" fxLayoutAlign=\"center center\">\n        <mat-icon *ngIf=\"option.icon\">{{option.icon}}</mat-icon>\n        <span *ngIf=\"!option.icon && option.value\">{{option.value}}</span>\n    </mat-button-toggle>\n</mat-button-toggle-group>"
    })
], NToggleoptionsComponent);

// import { MatSnackBar } from '@angular/material';
/**
* Model import Example :
* import { HERO } from '../models/hero.model';
*/
/**
 * Service import Example :
 * import { HeroService } from '../services/hero/hero.service';
 */
let NSignatureComponent = class NSignatureComponent {
    constructor() {
        this.imageDataValue = '';
        this.signaturePad = '';
        this.mode = 'responsive'; // 'click-fullscreen' or 'responsive'
        this.canvasMode = 'responsive'; // 'responsive' or 'fullscreen'
        this.imageDataChange = new EventEmitter();
    }
    get imageData() {
        return this.imageDataValue;
    }
    set imageData(val) {
        this.imageDataValue = val;
        if (val || val === '' || this.isDataURL(val)) {
            this.saveCavas(val);
        }
        this.imageDataChange.emit(this.imageDataValue);
    }
    ngAfterViewInit() {
        if (this.mode === 'responsive') {
            this.createCanvas();
        }
    }
    createCanvas() {
        this.fitToContainer(this.signaturecanvas.nativeElement);
        this.signaturePad = new signing__default(this.signaturecanvas.nativeElement, this.assignOptions());
    }
    saveCavas(dataUrl) {
        if (this.signaturePad) {
            if (this.signaturePad.isEmpty() || dataUrl === '') {
                this.savedData = '';
                this.signaturePad.clear();
            }
            else if (this.isDataURL(dataUrl)) {
                this.signaturePad.fromDataURL(dataUrl);
                this.savedData = this.signaturePad.toData();
            }
            else {
                this.imageData = this.signaturePad.toDataURL();
                if (this.mode === 'click-fullscreen') {
                    this.savedData = this.signaturePad.toData();
                    this.hideCanvas();
                }
            }
        }
    }
    clearCanvas() {
        this.signaturePad.clear();
        // this.fitToContainer(this.signaturecanvas.nativeElement);
    }
    undoCanvas() {
        const data = this.signaturePad.toData();
        if (data) {
            data.pop(); // remove the last dot or line
            this.signaturePad.fromData(data);
        }
    }
    showCanvas() {
        this.classAbs = true;
        this.canvasMode = 'fullscreen';
        if (!this.signaturePad) {
            this.createCanvas();
        }
        this.fitToContainer(this.signaturecanvas.nativeElement, document.body.clientHeight, document.body.clientWidth);
        this.clearCanvas();
        this.createCanvasFromData();
    }
    hideCanvas() {
        this.canvasMode = 'responsive';
    }
    // cancel currently drawn
    cancel() {
        this.savedData = Object.assign([], this.previousSavedData);
    }
    createCanvasFromData() {
        if (this.savedData) {
            this.previousSavedData = Object.assign({}, this.savedData);
            this.signaturePad.fromData(this.savedData);
        }
    }
    fitToContainer(element, height, width) {
        element.style.width = '100%';
        element.style.height = 'calc(100% - 56px)';
        if (height && width) {
            element.width = width;
            element.height = height - 56;
        }
        else {
            element.width = element.offsetWidth;
            element.height = element.offsetHeight;
        }
    }
    assignOptions() {
        let options = {};
        options['backgroundColor'] = this.checkIfValidValueAndRGB(this.backgroundColor, 'backgroundColor');
        options['dotSize'] = this.checkIfValidValueAndNumber(this.dotSize, 'dotSize');
        options['minWidth'] = this.checkIfValidValueAndNumber(this.minWidth, 'minWidth');
        options['maxWidth'] = this.checkIfValidValueAndNumber(this.maxWidth, 'maxWidth');
        options['throttle'] = this.checkIfValidValueAndNumber(this.throttle, 'throttle');
        options['minDistance'] = this.checkIfValidValueAndNumber(this.minDistance, 'minDistance');
        options['penColor'] = this.checkIfValidValueAndRGB(this.penColor, 'penColor');
        options['velocityFilterWeight'] = this.checkIfValidValueAndNumber(this.velocityFilterWeight, 'velocityFilterWeight');
        options = JSON.parse(JSON.stringify(options)); // removing all undefined fields
        options['onBegin'] = this.checkIfValidValueAndFunction(this.onBegin, 'onBegin');
        options['onEnd'] = this.checkIfValidValueAndFunction(this.onEnd, 'onEnd');
        return options;
    }
    checkIfValidValueAndNumber(num, name) {
        if (this.checkIfValid(num) && this.checkNumber(num)) {
            return num;
        }
        this.invalidToast(name, 'num');
        return undefined;
    }
    checkIfValidValueAndRGB(color, name) {
        if (this.checkIfValid(color) && this.checkRGB(color)) {
            return color;
        }
        this.invalidToast(name, 'rgb');
        return undefined;
    }
    checkIfValidValueAndFunction(fn, name) {
        if (this.checkIfValid(fn) && this.checkIfValidFunction(fn)) {
            return fn;
        }
        this.invalidToast(name, 'function format');
        return undefined;
    }
    checkIfValid(value) {
        return (value !== undefined && value !== null) ? value : undefined;
    }
    checkNumber(num) {
        return !this.checkIsNan(Number(num)) ? Number(num) : undefined;
    }
    checkIfValidFunction(fn) {
        return typeof fn === 'function' ? fn : undefined;
    }
    checkRGB(color) {
        const matchColors1 = new RegExp(/rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/);
        const matchColors2 = new RegExp(/rgb\((\d{1,3}),[ \t]+(\d{1,3}),(\d{1,3})\)/);
        const matchColors3 = new RegExp(/rgb\((\d{1,3}),(\d{1,3}),[ \t]+(\d{1,3})\)/);
        return matchColors1.test(color) || matchColors2.test(color) || matchColors3.test(color);
    }
    checkIsNan(value) {
        return Number.isNaN(value);
    }
    invalidToast(optionName, optionType) {
        switch (optionType) {
            case 'num':
                // this.snackbar.open(`Invalid ${optionName} (number or float) given, taking default value instead.`, 'OK');
                break;
            case 'rgb':
                // this.snackbar.open(`Invalid ${optionName} format Eg: rgb(255, 255, 255)  given, taking default value instead.`, 'OK');
                break;
        }
        return;
    }
    isDataURL(s) {
        if (s) {
            const regex = /^\s*data:([a-z]+\/[a-z]+(;[a-z\-]+\=[a-z\-]+)?)?(;base64)?,[a-z0-9\!\$\&\'\,\(\)\*\+\,\;\=\-\.\_\~\:\@\/\?\%\s]*\s*$/i;
            return !!s.match(regex);
        }
        else {
            return false;
        }
    }
};
__decorate([
    ViewChild('signaturecanvas', { static: false })
], NSignatureComponent.prototype, "signaturecanvas", void 0);
__decorate([
    ViewChild('canvasparent', { static: false })
], NSignatureComponent.prototype, "canvasparent", void 0);
__decorate([
    Input('backgroundColor')
], NSignatureComponent.prototype, "backgroundColor", void 0);
__decorate([
    Input('dotSize')
], NSignatureComponent.prototype, "dotSize", void 0);
__decorate([
    Input('minWidth')
], NSignatureComponent.prototype, "minWidth", void 0);
__decorate([
    Input('maxWidth')
], NSignatureComponent.prototype, "maxWidth", void 0);
__decorate([
    Input('throttle')
], NSignatureComponent.prototype, "throttle", void 0);
__decorate([
    Input('minDistance')
], NSignatureComponent.prototype, "minDistance", void 0);
__decorate([
    Input('penColor')
], NSignatureComponent.prototype, "penColor", void 0);
__decorate([
    Input('velocityFilterWeight')
], NSignatureComponent.prototype, "velocityFilterWeight", void 0);
__decorate([
    Input('onBegin')
], NSignatureComponent.prototype, "onBegin", void 0);
__decorate([
    Input('onEnd')
], NSignatureComponent.prototype, "onEnd", void 0);
__decorate([
    Input('mode')
], NSignatureComponent.prototype, "mode", void 0);
__decorate([
    Output()
], NSignatureComponent.prototype, "imageDataChange", void 0);
__decorate([
    Input()
], NSignatureComponent.prototype, "imageData", null);
NSignatureComponent = __decorate([
    Component({
        selector: 'n-signature',
        template: "<div fxFill fxLayout=\"row\" *ngIf=\"mode == 'click-fullscreen' && canvasMode !== 'fullscreen'\" class=\"signature-component-border\">\n    <div fxFlex=\"calc(100%-56px)\" fxLayout=\"column\">\n        <img *ngIf=\"imageDataValue\" [src]=\"imageDataValue\" fxFill/>\n    </div>\n    <div fxFlex=\"56px\" fxLayoutAlign=\" center\" class=\"signature-component-border\">\n        <button mat-icon-button (click)=\"showCanvas()\">\n            <mat-icon>mode_edit</mat-icon>\n        </button>\n    </div>\n</div>\n<div fxFill fxLayout=\"column\" class=\"signature-component-border\" [fxShow]=\"(mode == 'click-fullscreen' && canvasMode == 'fullscreen') || mode == 'responsive'\" [ngClass]=\"{'signature-canvas-fullscreen': classAbs}\">\n    <canvas #signaturecanvas></canvas>\n    <div fxFlex=\"56px\" fxLayoutAlign=\"center center\" class=\"signature-component-border\">\n        <button mat-icon-button (click)=\"undoCanvas()\">\n            <mat-icon>undo</mat-icon>\n        </button>\n        <button mat-icon-button (click)=\"clearCanvas()\">\n            <mat-icon>loop</mat-icon>\n        </button>\n        <button mat-icon-button (click)=\"saveCavas()\">\n            <mat-icon>save</mat-icon>\n        </button>\n        <button mat-icon-button (click)=\"canvasMode = 'responsive'; cancel()\">\n            <mat-icon>clear</mat-icon>\n        </button>\n    </div>\n</div>",
        styles: [`
     :host { height: 100% !important; }
     .signature-canvas-fullscreen {
         position: absolute;
         top: 0;
         bottom: 0;
         right: 0;
         left: 0;
     }
     .signature-component-border {
         border: 2px solid black;
     }
    `]
    })
], NSignatureComponent);

const EXPORTS = [
    NCameraDirective,
    NDownloadDirective,
    NScanDirective,
    NVideoDirective,
    NBarcodeDirective,
    NTtsDirective,
    NFingerprintDirective,
    NOcrDirective,
    NShakeDirective,
    NFileUploadComponent,
    NAlertComponent,
    NToggleoptionsComponent,
    NSignatureComponent,
];
let NeutrinosModule = class NeutrinosModule {
};
NeutrinosModule = __decorate([
    NgModule({
        imports: [
            HttpClientModule,
            FormsModule,
            CommonModule,
            MatIconModule,
            MatDialogModule,
            MatButtonModule,
            BrowserAnimationsModule,
            MatButtonToggleModule,
            NeutrinosSeedServicesModule,
            FlexLayoutModule,
        ],
        declarations: [
            EXPORTS,
        ],
        exports: [
            EXPORTS,
            NFileUploadComponent,
            NeutrinosSeedServicesModule,
        ],
        providers: [
            NFileIOService,
            NAlertService
        ]
    })
], NeutrinosModule);

/**
 * Generated bundle index. Do not edit.
 */

export { NAlertComponent, NAlertService, NFileIOService, NFileUploadComponent, NeutrinosModule, NCameraDirective as ɵa, NDownloadDirective as ɵb, NScanDirective as ɵc, NVideoDirective as ɵd, NBarcodeDirective as ɵe, NTtsDirective as ɵf, NFingerprintDirective as ɵg, NOcrDirective as ɵh, NShakeDirective as ɵi, NToggleoptionsComponent as ɵj, NSignatureComponent as ɵk };
//# sourceMappingURL=neutrinos-module.js.map
