(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('localforage')) :
    typeof define === 'function' && define.amd ? define('ngforage', ['exports', '@angular/core', 'localforage'], factory) :
    (global = global || self, factory(global.ngforage = {}, global.ng.core, global.localforage));
}(this, (function (exports, core, lf) { 'use strict';

    var lf__default = 'default' in lf ? lf['default'] : lf;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/cache/cached-item.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Cached data
     * @record
     * @template T
     */
    function CachedItem() { }
    if (false) {
        /**
         * The data
         * @type {?}
         */
        CachedItem.prototype.data;
        /**
         * Whether the data has expired
         * @type {?}
         */
        CachedItem.prototype.expired;
        /**
         * When the cached item expired or will expire
         * @type {?}
         */
        CachedItem.prototype.expires;
        /**
         * Number of milliseconds until the data expires
         * @type {?}
         */
        CachedItem.prototype.expiresIn;
        /**
         * Whether data was found
         * @type {?}
         */
        CachedItem.prototype.hasData;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/cache/cached-item-impl.class.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@internal
     * @template T
     */
    var   /**
     * \@internal
     * @template T
     */
    CachedItemImpl = /** @class */ (function () {
        function CachedItemImpl(data, expiryTime) {
            this.data = data;
            this.expires = new Date(typeof (/** @type {?} */ (expiryTime)) === 'number' ? expiryTime : 0);
        }
        Object.defineProperty(CachedItemImpl.prototype, "expired", {
            get: /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var value = this.expiresIn === 0;
                if (value) {
                    Object.defineProperty(this, 'expired', { value: value });
                }
                return value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CachedItemImpl.prototype, "expiresIn", {
            get: /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var value = Math.max(0, this.expires.getTime() - Date.now());
                if (!value) {
                    Object.defineProperty(this, 'expiresIn', { value: value });
                }
                return value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CachedItemImpl.prototype, "hasData", {
            get: /**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var value = this.data != null;
                Object.defineProperty(this, 'hasData', { value: value });
                return value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        CachedItemImpl.prototype.toJSON = /**
         * @return {?}
         */
        function () {
            return {
                data: this.data,
                expired: this.expired,
                expires: this.expires,
                expiresIn: this.expiresIn,
                hasData: this.hasData
            };
        };
        /**
         * @return {?}
         */
        CachedItemImpl.prototype.toString = /**
         * @return {?}
         */
        function () {
            return JSON.stringify(this.toJSON());
        };
        return CachedItemImpl;
    }());
    if (false) {
        /** @type {?} */
        CachedItemImpl.prototype.expires;
        /** @type {?} */
        CachedItemImpl.prototype.data;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/imports/localforage.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@internal
     * @type {?}
     */
    var localForage = 'defineDriver' in lf ? lf : lf__default;

    var e_1, _a;
    /** @enum {string} */
    var Driver = {
        /** The IndexedDB driver */
        INDEXED_DB: (/** @type {?} */ (localForage.INDEXEDDB)),
        /** The localStorage driver */
        LOCAL_STORAGE: (/** @type {?} */ (localForage.LOCALSTORAGE)),
        /** The WebSQL driver */
        WEB_SQL: (/** @type {?} */ (localForage.WEBSQL)),
    };
    try {
        // Clean up after Typescript's two-way enum transpilig
        for (var _b = __values([localForage.INDEXEDDB, localForage.LOCALSTORAGE, localForage.WEBSQL]), _c = _b.next(); !_c.done; _c = _b.next()) {
            var d = _c.value;
            delete Driver[d];
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    Object.freeze(Driver);

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/misc/injection-tokens.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Default ngforage configuration
     * @type {?}
     */
    var DEFAULT_CONFIG = new core.InjectionToken('Default NgForage config');

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/config/ng-forage-config.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@internal
     * @type {?}
     */
    var $defaultConfig = Symbol('Default Config');
    /**
     * Global/default configuration
     */
    var NgForageConfig = /** @class */ (function () {
        function NgForageConfig(conf) {
            this[$defaultConfig] = {
                cacheTime: 300000,
                description: '',
                driver: [Driver.INDEXED_DB, Driver.WEB_SQL, Driver.LOCAL_STORAGE],
                name: 'ngForage',
                size: 4980736,
                storeName: 'ng_forage',
                version: 1
            };
            if (conf) {
                this.configure(conf);
            }
        }
        Object.defineProperty(NgForageConfig.prototype, "cacheTime", {
            /**
             * Cache time in milliseconds
             * @default 300000
             */
            get: /**
             * Cache time in milliseconds
             * \@default 300000
             * @return {?}
             */
            function () {
                return (/** @type {?} */ (this[$defaultConfig].cacheTime));
            },
            set: /**
             * @param {?} t
             * @return {?}
             */
            function (t) {
                this[$defaultConfig].cacheTime = t;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForageConfig.prototype, "config", {
            /**
             * Get the compiled configuration
             */
            get: /**
             * Get the compiled configuration
             * @return {?}
             */
            function () {
                return {
                    cacheTime: this.cacheTime,
                    description: this.description,
                    driver: this.driver,
                    name: this.name,
                    size: this.size,
                    storeName: this.storeName,
                    version: this.version
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForageConfig.prototype, "description", {
            /**
             * A description of the database, essentially for developer usage.
             * @default
             */
            get: /**
             * A description of the database, essentially for developer usage.
             * \@default
             * @return {?}
             */
            function () {
                return (/** @type {?} */ (this[$defaultConfig].description));
            },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                this[$defaultConfig].description = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForageConfig.prototype, "driver", {
            /**
             * The preferred driver(s) to use.
             */
            get: /**
             * The preferred driver(s) to use.
             * @return {?}
             */
            function () {
                if (typeof this[$defaultConfig].driver === 'string') {
                    return (/** @type {?} */ (this[$defaultConfig].driver));
                }
                return ((/** @type {?} */ (this[$defaultConfig].driver))).slice();
            },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                this[$defaultConfig].driver = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForageConfig.prototype, "name", {
            /**
             * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.
             * In localStorage, this is used as a key prefix for all keys stored in localStorage.
             * @default ngForage
             */
            get: /**
             * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.
             * In localStorage, this is used as a key prefix for all keys stored in localStorage.
             * \@default ngForage
             * @return {?}
             */
            function () {
                return (/** @type {?} */ (this[$defaultConfig].name));
            },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                this[$defaultConfig].name = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForageConfig.prototype, "size", {
            /**
             * The size of the database in bytes. Used only in WebSQL for now.
             * @default 4980736
             */
            get: /**
             * The size of the database in bytes. Used only in WebSQL for now.
             * \@default 4980736
             * @return {?}
             */
            function () {
                return (/** @type {?} */ (this[$defaultConfig].size));
            },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                this[$defaultConfig].size = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForageConfig.prototype, "storeName", {
            /**
             * The name of the datastore.
             * In IndexedDB this is the dataStore,
             * in WebSQL this is the name of the key/value table in the database.
             * Must be alphanumeric, with underscores.
             * Any non-alphanumeric characters will be converted to underscores.
             * @default ng_forage
             */
            get: /**
             * The name of the datastore.
             * In IndexedDB this is the dataStore,
             * in WebSQL this is the name of the key/value table in the database.
             * Must be alphanumeric, with underscores.
             * Any non-alphanumeric characters will be converted to underscores.
             * \@default ng_forage
             * @return {?}
             */
            function () {
                return (/** @type {?} */ (this[$defaultConfig].storeName));
            },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                this[$defaultConfig].storeName = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForageConfig.prototype, "version", {
            /**
             * The version of your database. May be used for upgrades in the future; currently unused.
             * @default 1.0
             */
            get: /**
             * The version of your database. May be used for upgrades in the future; currently unused.
             * \@default 1.0
             * @return {?}
             */
            function () {
                return (/** @type {?} */ (this[$defaultConfig].version));
            },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                this[$defaultConfig].version = v;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Bulk-set configuration options
         * @param opts The configuration
         */
        /**
         * Bulk-set configuration options
         * @template THIS
         * @this {THIS}
         * @param {?} opts The configuration
         * @return {THIS}
         */
        NgForageConfig.prototype.configure = /**
         * Bulk-set configuration options
         * @template THIS
         * @this {THIS}
         * @param {?} opts The configuration
         * @return {THIS}
         */
        function (opts) {
            opts = opts || {};
            if (opts.driver && ((/** @type {?} */ (opts.driver))).slice) {
                opts.driver = ((/** @type {?} */ (opts.driver))).slice();
            }
            Object.assign((/** @type {?} */ (this))[$defaultConfig], opts);
            return (/** @type {?} */ (this));
        };
        /**
         * Define a driver
         *
         * You’ll want to make sure you accept a callback argument and that you pass the same arguments to callbacks as the
         * default drivers do. You’ll also want to resolve or reject promises.
         * Check any of the {@link https://github.com/mozilla/localForage/tree/master/src/drivers default drivers}
         * for an idea of how to implement your own, custom driver.
         * @param spec Driver spec
         */
        /**
         * Define a driver
         *
         * You’ll want to make sure you accept a callback argument and that you pass the same arguments to callbacks as the
         * default drivers do. You’ll also want to resolve or reject promises.
         * Check any of the {\@link https://github.com/mozilla/localForage/tree/master/src/drivers default drivers}
         * for an idea of how to implement your own, custom driver.
         * @param {?} spec Driver spec
         * @return {?}
         */
        NgForageConfig.prototype.defineDriver = /**
         * Define a driver
         *
         * You’ll want to make sure you accept a callback argument and that you pass the same arguments to callbacks as the
         * default drivers do. You’ll also want to resolve or reject promises.
         * Check any of the {\@link https://github.com/mozilla/localForage/tree/master/src/drivers default drivers}
         * for an idea of how to implement your own, custom driver.
         * @param {?} spec Driver spec
         * @return {?}
         */
        function (spec) {
            return localForage.defineDriver(spec);
        };
        /** @internal */
        /**
         * \@internal
         * @return {?}
         */
        NgForageConfig.prototype.toJSON = /**
         * \@internal
         * @return {?}
         */
        function () {
            return this.config;
        };
        /**
         * @return {?}
         */
        NgForageConfig.prototype.toString = /**
         * @return {?}
         */
        function () {
            return JSON.stringify(this.toJSON());
        };
        NgForageConfig.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        NgForageConfig.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DEFAULT_CONFIG,] }] }
        ]; };
        /** @nocollapse */ NgForageConfig.ɵprov = core.ɵɵdefineInjectable({ factory: function NgForageConfig_Factory() { return new NgForageConfig(core.ɵɵinject(DEFAULT_CONFIG, 8)); }, token: NgForageConfig, providedIn: "root" });
        return NgForageConfig;
    }());
    if (false) {
        /* Skipping unnamed member:
        private readonly [$defaultConfig]: NgForageOptions;*/
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/instance-factory/instance-factory.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@internal
     * @record
     */
    function InstanceMap() { }
    /**
     * \@internal
     * @type {?}
     */
    var stores = {};
    /**
     * \@internal
     * @param {?=} driver
     * @return {?}
     */
    function getDriverString(driver) {
        if (!driver) {
            return '';
        }
        else if (Array.isArray(driver)) {
            return driver.slice().sort().join(',');
        }
        else {
            return (/** @type {?} */ (driver));
        }
    }
    /**
     * \@internal
     * @param {?} cfg
     * @return {?}
     */
    function getHash(cfg) {
        return [
            getDriverString(cfg.driver),
            cfg.name,
            cfg.size,
            cfg.storeName,
            cfg.version,
            cfg.description,
            cfg.cacheTime
        ].join('|');
    }
    /**
     * \@internal
     * @type {?}
     */
    var conf$ = Symbol('Config');
    /**
     * Creates localForage instances
     */
    var InstanceFactory = /** @class */ (function () {
        /** @internal */
        function InstanceFactory(conf) {
            this[conf$] = conf;
        }
        /**
         * @param {?} cfg
         * @return {?}
         */
        InstanceFactory.prototype.getInstance = /**
         * @param {?} cfg
         * @return {?}
         */
        function (cfg) {
            cfg = Object.assign({}, this[conf$].config, cfg || {});
            /** @type {?} */
            var hash = getHash(cfg);
            if (!stores[hash]) {
                stores[hash] = localForage.createInstance(cfg);
            }
            return stores[hash];
        };
        InstanceFactory.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        InstanceFactory.ctorParameters = function () { return [
            { type: NgForageConfig }
        ]; };
        /** @nocollapse */ InstanceFactory.ɵprov = core.ɵɵdefineInjectable({ factory: function InstanceFactory_Factory() { return new InstanceFactory(core.ɵɵinject(NgForageConfig)); }, token: InstanceFactory, providedIn: "root" });
        return InstanceFactory;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/config/base-configurable-impl.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@internal
     * @type {?}
     */
    var store$ = Symbol('Store');
    /**
     * Abstract service-level configuration layer for NgForage
     * @abstract
     */
    var BaseConfigurableImpl = /** @class */ (function () {
        /** @internal */
        function BaseConfigurableImpl(config, instanceFactory) {
            /**
             * \@internal
             */
            this.config = {};
            /**
             * \@internal
             */
            this.storeNeedsRecalc = true;
            this.baseConfig = config;
            this.fact = instanceFactory;
        }
        Object.defineProperty(BaseConfigurableImpl.prototype, "description", {
            /**
             * A description of the database, essentially for developer usage.
             * @default ""
             */
            get: /**
             * A description of the database, essentially for developer usage.
             * \@default ""
             * @return {?}
             */
            function () {
                return this.config.description || this.baseConfig.description;
            },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                this.config.description = v;
                this.storeNeedsRecalc = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseConfigurableImpl.prototype, "driver", {
            /**
             * The preferred driver(s) to use.
             * @default IndexedDB, WebSQL and localStorage
             */
            get: /**
             * The preferred driver(s) to use.
             * \@default IndexedDB, WebSQL and localStorage
             * @return {?}
             */
            function () {
                return this.config.driver || this.baseConfig.driver;
            },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                this.config.driver = v;
                this.storeNeedsRecalc = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseConfigurableImpl.prototype, "name", {
            /**
             * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.
             * In localStorage, this is used as a key prefix for all keys stored in localStorage.
             * @default ngForage
             */
            get: /**
             * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.
             * In localStorage, this is used as a key prefix for all keys stored in localStorage.
             * \@default ngForage
             * @return {?}
             */
            function () {
                return this.config.name || this.baseConfig.name;
            },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                this.config.name = v;
                this.storeNeedsRecalc = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseConfigurableImpl.prototype, "size", {
            /**
             * The size of the database in bytes. Used only in WebSQL for now.
             * @default 4980736
             */
            get: /**
             * The size of the database in bytes. Used only in WebSQL for now.
             * \@default 4980736
             * @return {?}
             */
            function () {
                return this.config.size || this.baseConfig.size;
            },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                this.config.size = v;
                this.storeNeedsRecalc = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseConfigurableImpl.prototype, "storeName", {
            /**
             * The name of the datastore.
             * In IndexedDB this is the dataStore,
             * in WebSQL this is the name of the key/value table in the database.
             * Must be alphanumeric, with underscores.
             * Any non-alphanumeric characters will be converted to underscores.
             * @default ng_forage
             */
            get: /**
             * The name of the datastore.
             * In IndexedDB this is the dataStore,
             * in WebSQL this is the name of the key/value table in the database.
             * Must be alphanumeric, with underscores.
             * Any non-alphanumeric characters will be converted to underscores.
             * \@default ng_forage
             * @return {?}
             */
            function () {
                return this.config.storeName || this.baseConfig.storeName;
            },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                this.config.storeName = v;
                this.storeNeedsRecalc = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseConfigurableImpl.prototype, "version", {
            /**
             * The version of your database. May be used for upgrades in the future; currently unused.
             * @default 1.0
             */
            get: /**
             * The version of your database. May be used for upgrades in the future; currently unused.
             * \@default 1.0
             * @return {?}
             */
            function () {
                return 'version' in this.config ? (/** @type {?} */ (this.config.version)) : this.baseConfig.version;
            },
            set: /**
             * @param {?} v
             * @return {?}
             */
            function (v) {
                this.config.version = v;
                this.storeNeedsRecalc = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseConfigurableImpl.prototype, "finalConfig", {
            /** @internal */
            get: /**
             * \@internal
             * @protected
             * @return {?}
             */
            function () {
                return Object.assign({}, this.baseConfig.config, this.config);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseConfigurableImpl.prototype, "store", {
            /** @internal */
            get: /**
             * \@internal
             * @protected
             * @return {?}
             */
            function () {
                if (this.storeNeedsRecalc || !this[store$]) {
                    this[store$] = this.fact.getInstance(this.finalConfig);
                    this.storeNeedsRecalc = false;
                }
                return this[store$];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Bulk-set configuration options
         * @param opts The configuration
         */
        /**
         * Bulk-set configuration options
         * @template THIS
         * @this {THIS}
         * @param {?} opts The configuration
         * @return {THIS}
         */
        BaseConfigurableImpl.prototype.configure = /**
         * Bulk-set configuration options
         * @template THIS
         * @this {THIS}
         * @param {?} opts The configuration
         * @return {THIS}
         */
        function (opts) {
            opts = opts || {};
            if (Array.isArray(opts.driver)) {
                opts.driver = opts.driver.slice();
            }
            Object.assign((/** @type {?} */ (this)).config, opts);
            (/** @type {?} */ (this)).storeNeedsRecalc = true;
            return (/** @type {?} */ (this));
        };
        /**
         * @return {?}
         */
        BaseConfigurableImpl.prototype.toJSON = /**
         * @return {?}
         */
        function () {
            return {
                description: this.description,
                driver: this.driver,
                name: this.name,
                size: this.size,
                storeName: this.storeName,
                version: this.version
            };
        };
        /**
         * @return {?}
         */
        BaseConfigurableImpl.prototype.toString = /**
         * @return {?}
         */
        function () {
            return JSON.stringify(this.toJSON());
        };
        BaseConfigurableImpl.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        BaseConfigurableImpl.ctorParameters = function () { return [
            { type: NgForageConfig, decorators: [{ type: core.Inject, args: [NgForageConfig,] }] },
            { type: InstanceFactory, decorators: [{ type: core.Inject, args: [InstanceFactory,] }] }
        ]; };
        return BaseConfigurableImpl;
    }());
    if (false) {
        /**
         * \@internal
         * @type {?}
         * @protected
         */
        BaseConfigurableImpl.prototype.baseConfig;
        /**
         * \@internal
         * @type {?}
         * @protected
         */
        BaseConfigurableImpl.prototype.config;
        /**
         * \@internal
         * @type {?}
         * @protected
         */
        BaseConfigurableImpl.prototype.fact;
        /**
         * \@internal
         * @type {?}
         * @protected
         */
        BaseConfigurableImpl.prototype.storeNeedsRecalc;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/main/ng-forage.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Cache instance
     */
    var NgForage = /** @class */ (function (_super) {
        __extends(NgForage, _super);
        function NgForage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(NgForage.prototype, "activeDriver", {
            /**
             * Returns the name of the driver being used, or null if none can be used.
             */
            get: /**
             * Returns the name of the driver being used, or null if none can be used.
             * @return {?}
             */
            function () {
                return this.store.driver();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Removes every key from the database, returning it to a blank slate.
         *
         * clear() will remove <b>every item in the offline store</b>. Use this method with caution.
         */
        /**
         * Removes every key from the database, returning it to a blank slate.
         *
         * clear() will remove <b>every item in the offline store</b>. Use this method with caution.
         * @return {?}
         */
        NgForage.prototype.clear = /**
         * Removes every key from the database, returning it to a blank slate.
         *
         * clear() will remove <b>every item in the offline store</b>. Use this method with caution.
         * @return {?}
         */
        function () {
            return this.store.clear();
        };
        /**
         * Make a clone of the instance
         * @param config Optional configuration
         */
        /**
         * Make a clone of the instance
         * @param {?=} config Optional configuration
         * @return {?}
         */
        NgForage.prototype.clone = /**
         * Make a clone of the instance
         * @param {?=} config Optional configuration
         * @return {?}
         */
        function (config) {
            /** @type {?} */
            var inst = new NgForage(this.baseConfig, this.fact);
            inst.configure(Object.assign(this.finalConfig, config || {}));
            return inst;
        };
        /**
         * Gets an item from the storage library.
         * If the key does not exist, getItem() will return null.
         * @param key Data key
         */
        /**
         * Gets an item from the storage library.
         * If the key does not exist, getItem() will return null.
         * @template T
         * @param {?} key Data key
         * @return {?}
         */
        NgForage.prototype.getItem = /**
         * Gets an item from the storage library.
         * If the key does not exist, getItem() will return null.
         * @template T
         * @param {?} key Data key
         * @return {?}
         */
        function (key) {
            return this.store.getItem(key);
        };
        /**
         * Iterate over all value/key pairs in datastore.
         * <i>iteratee</i> is called once for each pair, with the following arguments:
         * <ol>
         *   <li>Value</li>
         *   <li>Key</li>
         *   <li>iterationNumber - one-based number</li>
         * </ol>
         * iterate() supports early exit by returning non undefined value inside iteratorCallback callback.
         * @param iteratee
         */
        /**
         * Iterate over all value/key pairs in datastore.
         * <i>iteratee</i> is called once for each pair, with the following arguments:
         * <ol>
         *   <li>Value</li>
         *   <li>Key</li>
         *   <li>iterationNumber - one-based number</li>
         * </ol>
         * iterate() supports early exit by returning non undefined value inside iteratorCallback callback.
         * @template T, U
         * @param {?} iteratee
         * @return {?}
         */
        NgForage.prototype.iterate = /**
         * Iterate over all value/key pairs in datastore.
         * <i>iteratee</i> is called once for each pair, with the following arguments:
         * <ol>
         *   <li>Value</li>
         *   <li>Key</li>
         *   <li>iterationNumber - one-based number</li>
         * </ol>
         * iterate() supports early exit by returning non undefined value inside iteratorCallback callback.
         * @template T, U
         * @param {?} iteratee
         * @return {?}
         */
        function (iteratee) {
            return this.store.iterate(iteratee);
        };
        /**
         * Get the name of a key based on its ID.
         * @param index
         */
        /**
         * Get the name of a key based on its ID.
         * @param {?} index
         * @return {?}
         */
        NgForage.prototype.key = /**
         * Get the name of a key based on its ID.
         * @param {?} index
         * @return {?}
         */
        function (index) {
            return this.store.key(index);
        };
        /**
         * Get the list of all keys in the datastore.
         */
        /**
         * Get the list of all keys in the datastore.
         * @return {?}
         */
        NgForage.prototype.keys = /**
         * Get the list of all keys in the datastore.
         * @return {?}
         */
        function () {
            return this.store.keys();
        };
        /**
         * Gets the number of keys in the offline store (i.e. its “length”).
         */
        /**
         * Gets the number of keys in the offline store (i.e. its “length”).
         * @return {?}
         */
        NgForage.prototype.length = /**
         * Gets the number of keys in the offline store (i.e. its “length”).
         * @return {?}
         */
        function () {
            return this.store.length();
        };
        /**
         * Even though localForage queues up all of its data API method calls,
         * ready() provides a way to determine whether the asynchronous driver initialization process has finished.
         * That’s useful in cases like when we want to know which driver localForage has settled down using.
         */
        /**
         * Even though localForage queues up all of its data API method calls,
         * ready() provides a way to determine whether the asynchronous driver initialization process has finished.
         * That’s useful in cases like when we want to know which driver localForage has settled down using.
         * @return {?}
         */
        NgForage.prototype.ready = /**
         * Even though localForage queues up all of its data API method calls,
         * ready() provides a way to determine whether the asynchronous driver initialization process has finished.
         * That’s useful in cases like when we want to know which driver localForage has settled down using.
         * @return {?}
         */
        function () {
            return this.store.ready();
        };
        /**
         * Removes the value of a key from the offline store.
         * @param key Data key
         */
        /**
         * Removes the value of a key from the offline store.
         * @param {?} key Data key
         * @return {?}
         */
        NgForage.prototype.removeItem = /**
         * Removes the value of a key from the offline store.
         * @param {?} key Data key
         * @return {?}
         */
        function (key) {
            return this.store.removeItem(key);
        };
        /**
         * Saves data to an offline store. You can store the following types of JavaScript objects:
         * <ul>
         *  <li>Array</li>
         *  <li>ArrayBuffer</li>
         *  <li>Blob</li>
         *  <li>Float32Array</li>
         *  <li>Float64Array</li>
         *  <li>Int8Array</li>
         *  <li>Int16Array</li>
         *  <li>Int32Array</li>
         *  <li>Number</li>
         *  <li>Object</li>
         *  <li>Uint8Array</li>
         *  <li>Uint8ClampedArray</li>
         *  <li>Uint16Array</li>
         *  <li>Uint32Array</li>
         *  <li>String</li>
         * </ul>
         * @param key Data key
         * @param data Data
         */
        /**
         * Saves data to an offline store. You can store the following types of JavaScript objects:
         * <ul>
         *  <li>Array</li>
         *  <li>ArrayBuffer</li>
         *  <li>Blob</li>
         *  <li>Float32Array</li>
         *  <li>Float64Array</li>
         *  <li>Int8Array</li>
         *  <li>Int16Array</li>
         *  <li>Int32Array</li>
         *  <li>Number</li>
         *  <li>Object</li>
         *  <li>Uint8Array</li>
         *  <li>Uint8ClampedArray</li>
         *  <li>Uint16Array</li>
         *  <li>Uint32Array</li>
         *  <li>String</li>
         * </ul>
         * @template T
         * @param {?} key Data key
         * @param {?} data Data
         * @return {?}
         */
        NgForage.prototype.setItem = /**
         * Saves data to an offline store. You can store the following types of JavaScript objects:
         * <ul>
         *  <li>Array</li>
         *  <li>ArrayBuffer</li>
         *  <li>Blob</li>
         *  <li>Float32Array</li>
         *  <li>Float64Array</li>
         *  <li>Int8Array</li>
         *  <li>Int16Array</li>
         *  <li>Int32Array</li>
         *  <li>Number</li>
         *  <li>Object</li>
         *  <li>Uint8Array</li>
         *  <li>Uint8ClampedArray</li>
         *  <li>Uint16Array</li>
         *  <li>Uint32Array</li>
         *  <li>String</li>
         * </ul>
         * @template T
         * @param {?} key Data key
         * @param {?} data Data
         * @return {?}
         */
        function (key, data) {
            return this.store.setItem(key, data);
        };
        /**
         * Check whether the given driver is supported/registered.
         * @param driver Driver name
         */
        /**
         * Check whether the given driver is supported/registered.
         * @param {?} driver Driver name
         * @return {?}
         */
        NgForage.prototype.supports = /**
         * Check whether the given driver is supported/registered.
         * @param {?} driver Driver name
         * @return {?}
         */
        function (driver) {
            return this.store.supports((/** @type {?} */ (driver)));
        };
        NgForage.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */ NgForage.ɵprov = core.ɵɵdefineInjectable({ factory: function NgForage_Factory() { return new NgForage(core.ɵɵinject(NgForageConfig), core.ɵɵinject(InstanceFactory)); }, token: NgForage, providedIn: "root" });
        return NgForage;
    }(BaseConfigurableImpl));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/cache/ng-forage-cache.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@internal
     * @record
     */
    function CacheKeys() { }
    if (false) {
        /** @type {?} */
        CacheKeys.prototype.data;
        /** @type {?} */
        CacheKeys.prototype.expiry;
    }
    /**
     * \@internal
     * @param {?} mainKey
     * @return {?}
     */
    function calculateCacheKeys(mainKey) {
        return {
            data: mainKey + "_data",
            expiry: mainKey + "_expiry"
        };
    }
    /**
     * \@internal
     * @template T
     * @param {?} r
     * @return {?}
     */
    function toCachedItem(r) {
        return new CachedItemImpl(r[0], r[1]);
    }
    /**
     * \@internal
     * @template T
     * @param {?} r
     * @return {?}
     */
    function head(r) {
        return r[0];
    }
    /**
     * \@internal
     * @return {?}
     */
    // tslint:disable-next-line:no-empty
    function toVoid() {
    }
    /**
     * An extension of {\@link NgForage} which adds expiration support
     */
    var NgForageCache = /** @class */ (function (_super) {
        __extends(NgForageCache, _super);
        function NgForageCache() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(NgForageCache.prototype, "cacheTime", {
            /**
             * Cache time in milliseconds
             * @default 300000
             */
            get: /**
             * Cache time in milliseconds
             * \@default 300000
             * @return {?}
             */
            function () {
                return this.config.cacheTime || this.baseConfig.cacheTime;
            },
            set: /**
             * @param {?} t
             * @return {?}
             */
            function (t) {
                this.config.cacheTime = t;
                this.storeNeedsRecalc = true;
            },
            enumerable: true,
            configurable: true
        });
        /** @inheritDoc */
        /**
         * @inheritDoc
         * @param {?=} config
         * @return {?}
         */
        NgForageCache.prototype.clone = /**
         * @inheritDoc
         * @param {?=} config
         * @return {?}
         */
        function (config) {
            /** @type {?} */
            var inst = new NgForageCache(this.baseConfig, this.fact);
            inst.configure(Object.assign(this.finalConfig, config || {}));
            return inst;
        };
        /**
         * Retrieve data
         * @param key Data key
         */
        /**
         * Retrieve data
         * @template T
         * @param {?} key Data key
         * @return {?}
         */
        NgForageCache.prototype.getCached = /**
         * Retrieve data
         * @template T
         * @param {?} key Data key
         * @return {?}
         */
        function (key) {
            /** @type {?} */
            var keys = calculateCacheKeys(key);
            /** @type {?} */
            var dataPromise = this.getItem(keys.data);
            /** @type {?} */
            var expiryPromise = this.getItem(keys.expiry);
            return Promise.all([dataPromise, expiryPromise]).then(toCachedItem);
        };
        /**
         * Remove data
         * @param key Data key
         */
        /**
         * Remove data
         * @param {?} key Data key
         * @return {?}
         */
        NgForageCache.prototype.removeCached = /**
         * Remove data
         * @param {?} key Data key
         * @return {?}
         */
        function (key) {
            /** @type {?} */
            var keys = calculateCacheKeys(key);
            /** @type {?} */
            var dataPromise = this.removeItem(keys.data);
            /** @type {?} */
            var expiryPromise = this.removeItem(keys.expiry);
            return Promise.all([dataPromise, expiryPromise]).then(toVoid);
        };
        /**
         * Set data
         * @param key Data key
         * @param data Data to set
         * @param [cacheTime] Override cache set in {@link CacheConfigurable#cacheTime global or instance config}.
         */
        /**
         * Set data
         * @template T
         * @param {?} key Data key
         * @param {?} data Data to set
         * @param {?=} cacheTime
         * @return {?}
         */
        NgForageCache.prototype.setCached = /**
         * Set data
         * @template T
         * @param {?} key Data key
         * @param {?} data Data to set
         * @param {?=} cacheTime
         * @return {?}
         */
        function (key, data, cacheTime) {
            /** @type {?} */
            var keys = calculateCacheKeys(key);
            /** @type {?} */
            var expiry = typeof cacheTime === 'number' ? cacheTime : this.cacheTime;
            /** @type {?} */
            var dataPromise = this.setItem(keys.data, data);
            /** @type {?} */
            var expiryPromise = this.setItem(keys.expiry, Date.now() + expiry);
            return Promise.all([dataPromise, expiryPromise]).then(head);
        };
        /** @internal */
        /**
         * \@internal
         * @return {?}
         */
        NgForageCache.prototype.toJSON = /**
         * \@internal
         * @return {?}
         */
        function () {
            return Object.assign((/** @type {?} */ (_super.prototype.toJSON.call(this))), { cacheTime: this.cacheTime });
        };
        NgForageCache.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */ NgForageCache.ɵprov = core.ɵɵdefineInjectable({ factory: function NgForageCache_Factory() { return new NgForageCache(core.ɵɵinject(NgForageConfig), core.ɵɵinject(InstanceFactory)); }, token: NgForageCache, providedIn: "root" });
        return NgForageCache;
    }(NgForage));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/cache/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/config/base-configurable.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A configurable object
     * @record
     */
    function BaseConfigurable() { }
    if (false) {
        /**
         * A description of the database, essentially for developer usage.
         * \@default ""
         * @type {?}
         */
        BaseConfigurable.prototype.description;
        /**
         * The preferred driver(s) to use.
         * \@default IndexedDB, WebSQL & localStorage
         * @type {?}
         */
        BaseConfigurable.prototype.driver;
        /**
         * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.
         * In localStorage, this is used as a key prefix for all keys stored in localStorage.
         * \@default ngForage
         * @type {?}
         */
        BaseConfigurable.prototype.name;
        /**
         * The size of the database in bytes. Used only in WebSQL for now.
         * \@default 4980736
         * @type {?}
         */
        BaseConfigurable.prototype.size;
        /**
         * The name of the datastore.
         * In IndexedDB this is the dataStore,
         * in WebSQL this is the name of the key/value table in the database.
         * Must be alphanumeric, with underscores.
         * Any non-alphanumeric characters will be converted to underscores.
         * \@default ng_forage
         * @type {?}
         */
        BaseConfigurable.prototype.storeName;
        /**
         * The version of your database. May be used for upgrades in the future; currently unused.
         * \@default 1.0
         * @type {?}
         */
        BaseConfigurable.prototype.version;
        /**
         * Bulk-set configuration options
         * @template THIS
         * @this {THIS}
         * @param {?} opts The configuration
         * @return {THIS}
         */
        BaseConfigurable.prototype.configure = function (opts) { };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/config/cache-configurable.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A cacheable configurable object
     * @record
     */
    function CacheConfigurable() { }
    if (false) {
        /**
         * Cache time in milliseconds
         * \@default 300000
         * @type {?}
         */
        CacheConfigurable.prototype.cacheTime;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/config/ng-forage-options.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/config/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/dedicated/ng-forage-cache-dedicated.class.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@internal
     */
    var   /**
     * \@internal
     */
    NgForageCacheDedicated = /** @class */ (function (_super) {
        __extends(NgForageCacheDedicated, _super);
        function NgForageCacheDedicated() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?=} config
         * @return {?}
         */
        NgForageCacheDedicated.prototype.clone = /**
         * @param {?=} config
         * @return {?}
         */
        function (config) {
            /** @type {?} */
            var inst = new NgForageCacheDedicated(this.baseConfig, this.fact);
            inst.configure(Object.assign(this.finalConfig, config || {}));
            return inst;
        };
        return NgForageCacheDedicated;
    }(NgForageCache));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/dedicated/ng-forage-dedicated.class.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@internal
     */
    var   /**
     * \@internal
     */
    NgForageDedicated = /** @class */ (function (_super) {
        __extends(NgForageDedicated, _super);
        function NgForageDedicated() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?=} config
         * @return {?}
         */
        NgForageDedicated.prototype.clone = /**
         * @param {?=} config
         * @return {?}
         */
        function (config) {
            /** @type {?} */
            var inst = new NgForageDedicated(this.baseConfig, this.fact);
            inst.configure(Object.assign(this.finalConfig, config || {}));
            return inst;
        };
        return NgForageDedicated;
    }(NgForage));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/dedicated/dedicated-instance-factory.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * \@internal
     * @type {?}
     */
    var conf$$1 = Symbol('NgForageConfig');
    /**
     * \@internal
     * @type {?}
     */
    var if$ = Symbol('InstanceFactory');
    var DedicatedInstanceFactory = /** @class */ (function () {
        function DedicatedInstanceFactory(conf, instFact) {
            this[conf$$1] = conf;
            this[if$] = instFact;
        }
        /**
         * @param {?=} config
         * @return {?}
         */
        DedicatedInstanceFactory.prototype.createCache = /**
         * @param {?=} config
         * @return {?}
         */
        function (config) {
            /** @type {?} */
            var inst = new NgForageCacheDedicated(this[conf$$1], this[if$]);
            if (config) {
                inst.configure(config);
            }
            return inst;
        };
        /**
         * @param {?=} config
         * @return {?}
         */
        DedicatedInstanceFactory.prototype.createNgForage = /**
         * @param {?=} config
         * @return {?}
         */
        function (config) {
            /** @type {?} */
            var inst = new NgForageDedicated(this[conf$$1], this[if$]);
            if (config) {
                inst.configure(config);
            }
            return inst;
        };
        DedicatedInstanceFactory.decorators = [
            { type: core.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        DedicatedInstanceFactory.ctorParameters = function () { return [
            { type: NgForageConfig },
            { type: InstanceFactory }
        ]; };
        /** @nocollapse */ DedicatedInstanceFactory.ɵprov = core.ɵɵdefineInjectable({ factory: function DedicatedInstanceFactory_Factory() { return new DedicatedInstanceFactory(core.ɵɵinject(NgForageConfig), core.ɵɵinject(InstanceFactory)); }, token: DedicatedInstanceFactory, providedIn: "root" });
        return DedicatedInstanceFactory;
    }());
    if (false) {
        /* Skipping unnamed member:
        private readonly [conf$]: NgForageConfig;*/
        /* Skipping unnamed member:
        private readonly [if$]: InstanceFactory;*/
    }

    exports.BaseConfigurableImpl = BaseConfigurableImpl;
    exports.CachedItemImpl = CachedItemImpl;
    exports.DEFAULT_CONFIG = DEFAULT_CONFIG;
    exports.DedicatedInstanceFactory = DedicatedInstanceFactory;
    exports.Driver = Driver;
    exports.InstanceFactory = InstanceFactory;
    exports.NgForage = NgForage;
    exports.NgForageCache = NgForageCache;
    exports.NgForageCacheDedicated = NgForageCacheDedicated;
    exports.NgForageConfig = NgForageConfig;
    exports.NgForageDedicated = NgForageDedicated;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngforage.umd.js.map
