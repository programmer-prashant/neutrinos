"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const lazy_get_decorator_1 = require("lazy-get-decorator");
const ts = require("typescript");
const insertMetaEntry_1 = require("../_common/insertMetaEntry");
const loadAppModule_1 = require("../_common/loadAppModule");
const lazyGetter = lazy_get_decorator_1.LazyGetter();
//tslint:disable:max-classes-per-file
class ForRootMigrater {
    constructor(appModule, ngModuleMetadata, recorder) {
        this.appModule = appModule;
        this.ngModuleMetadata = ngModuleMetadata;
        this.recorder = recorder;
    }
    process() {
        let returnValue = false;
        for (const property of this.ngModuleMetadata.properties) {
            if (!ts.isPropertyAssignment(property) ||
                property.name.getText() !== 'imports' ||
                !ts.isArrayLiteralExpression(property.initializer)) {
                continue;
            }
            if (this.property(property)) {
                returnValue = true;
            }
        }
        return returnValue;
    }
    /** Returns true if a DEFAULT_OPTIONS import should be generated */
    arg(arg) {
        if (ts.isIdentifier(arg) || ts.isObjectLiteralExpression(arg) || ts.isAsExpression(arg)) {
            const useValue = arg.getText();
            if (useValue) {
                const provide = `{\n      provide: DEFAULT_CONFIG,\n      useValue: ${useValue}\n    }`;
                insertMetaEntry_1.insertMetaEntry('providers', this.appModule, this.recorder, provide);
                return true;
            }
        }
        return false;
    }
    /** Returns true if a DEFAULT_OPTIONS import should be generated */
    callExpr(el) {
        const access = el.expression;
        let returnValue = false;
        if (ts.isPropertyAccessExpression(access) &&
            access.expression.getText() === 'NgForageModule' &&
            access.name.getText() === 'forRoot') {
            const arg = el.arguments[0];
            if (arg && this.arg(arg)) {
                returnValue = true;
            }
            this.recorder.remove(el.pos, this.rmLength);
        }
        return returnValue;
    }
    identifier(el) {
        if (el.getText() === 'NgForageModule') {
            this.recorder.remove(el.pos, this.rmLength);
        }
    }
    /** Returns true if a DEFAULT_OPTIONS import should be generated */
    property(property) {
        const elements = (property.initializer).elements;
        const maxIndex = elements.length - 1;
        let returnValue = false;
        for (let i = maxIndex; i > -1; i--) {
            const el = elements[i];
            this.rmLength = (i === maxIndex ? 0 : 1) + el.getFullWidth();
            if (ts.isIdentifier(el)) {
                this.identifier(el);
            }
            else if (ts.isCallExpression(el) && this.callExpr(el)) {
                returnValue = true;
            }
        }
        return returnValue;
    }
}
class ImportMigrater {
    constructor(file, importCfg, recorder) {
        this.file = file;
        this.importCfg = importCfg;
        this.recorder = recorder;
    }
    get imports() {
        return this.file.statements
            .filter((c) => ts.isImportDeclaration(c));
    }
    get willImportCfg() {
        return this.importCfg && !ast_utils_1.isImported(this.file, 'DEFAULT_CONFIG', 'ngforage');
    }
    process() {
        for (const imp of this.imports) {
            this.import(imp);
        }
        if (this.willImportCfg) {
            this.recorder.insertLeft(0, `import {DEFAULT_CONFIG} from 'ngforage';\n`);
        }
    }
    element(element, numBindings, imp) {
        if (element.name.getText() === 'NgForageModule') {
            if (numBindings > 1) {
                this.recorder.remove(element.getFullStart(), element.getFullWidth());
            }
            else {
                this.recorder.remove(imp.getFullStart(), imp.getFullWidth());
            }
            return true;
        }
        return false;
    }
    import(imp) {
        const moduleSpecifier = imp.moduleSpecifier;
        if (!imp.importClause || moduleSpecifier.text !== 'ngforage') {
            return;
        }
        const bindings = imp.importClause.namedBindings;
        if (!bindings || !bindings.elements || !bindings.elements.length || ts.isNamespaceImport(bindings)) {
            return;
        }
        const maxIndex = bindings.elements.length - 1;
        for (let i = maxIndex; i > -1; i--) {
            if (this.element(bindings.elements[i], bindings.elements.length, imp)) {
                break;
            }
        }
    }
}
tslib_1.__decorate([
    lazyGetter
], ImportMigrater.prototype, "imports", null);
tslib_1.__decorate([
    lazyGetter
], ImportMigrater.prototype, "willImportCfg", null);
class OmitMigrater {
    constructor(tree, ctx) {
        this.tree = tree;
        this.ctx = ctx;
    }
    get matchedFiles() {
        const matchedFiles = [];
        const regExclude = /node_modules/;
        const regInclude = /\.ts$/;
        this.info('Building file tree');
        this.tree.visit((path, entry) => {
            if (regExclude.test(path) || !regInclude.test(path) || !entry) {
                this.debug(`${path} didn't match`);
                return;
            }
            this.debug(`${path} matched`);
            matchedFiles.push(entry);
        });
        this.info('File tree built');
        return matchedFiles;
    }
    process() {
        for (const mf of this.matchedFiles) {
            this.file(mf);
        }
    }
    debug(msg) {
        this.ctx.logger.debug(msg);
    }
    file(mf) {
        const content = (mf.content || this.tree.read(mf.path)).toString();
        const src = ts.createSourceFile(mf.path, content, ts.ScriptTarget.Latest, true);
        if (!src.statements || !src.statements.length) {
            return;
        }
        let hasChange = false;
        const recorder = this.tree.beginUpdate(mf.path);
        for (let i = src.statements.length - 1; i > -1; i--) {
            if (this.statement(src.statements[i], recorder, mf)) {
                hasChange = true;
            }
        }
        if (hasChange) {
            this.tree.commitUpdate(recorder);
        }
    }
    info(msg) {
        this.ctx.logger.info(msg);
    }
    statement(stmt, recorder, mf) {
        if (!ts.isImportDeclaration(stmt) ||
            !ts.isStringLiteral(stmt.moduleSpecifier) ||
            stmt.moduleSpecifier.text !== 'ngforage/lib/misc/omit.type') {
            return false;
        }
        this.debug(`Found ${stmt.getText()} in ${mf.path}`);
        recorder.remove(stmt.getFullStart(), stmt.getFullWidth());
        return true;
    }
}
tslib_1.__decorate([
    lazyGetter
], OmitMigrater.prototype, "matchedFiles", null);
function update(options) {
    return (tree, ctx) => {
        const { ngModuleMetadata, modulePath, appModule } = loadAppModule_1.loadAppModule(tree, options.project);
        const modulePathRecorder = tree.beginUpdate(modulePath);
        const importCfg = new ForRootMigrater(appModule, ngModuleMetadata, modulePathRecorder).process();
        new ImportMigrater(appModule, importCfg, modulePathRecorder).process();
        tree.commitUpdate(modulePathRecorder);
        new OmitMigrater(tree, ctx).process();
    };
}
exports.update = update;
//# sourceMappingURL=v6.js.map