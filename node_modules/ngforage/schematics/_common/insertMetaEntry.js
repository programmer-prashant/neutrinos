"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const ts = require("typescript");
function insertMetaEntry(field, file, recorder, def) {
    let node = ast_utils_1.getDecoratorMetadata(file, 'NgModule', '@angular/core')[0];
    const objNode = node;
    let position;
    let toInsert;
    const matchingProps = ast_utils_1.getMetadataField(objNode, field);
    if (!matchingProps.length) {
        // field not found
        if (!objNode.properties.length) {
            position = node.getEnd() - 1;
            toInsert = `  ${field}: [\n    ${def}\n  ]`;
        }
        else {
            node = objNode.properties[objNode.properties.length - 1];
            position = node.getEnd();
            // Get the indentation of the last element, if any.
            const text = node.getFullText();
            const matches = text.match(/^\r?\n\s*/);
            toInsert = matches && matches.length ?
                `,${matches[0]}${field}: [\n    ${def}\n  ]` :
                `, ${field}: [\n    ${def}\n  ]`;
        }
    }
    else {
        const arrLiteral = matchingProps[0].initializer;
        if (ts.isArrayLiteralExpression(arrLiteral)) {
            let prefix = '\n    ';
            let indexSubtract;
            if (arrLiteral.elements.length) {
                node = arrLiteral.elements[arrLiteral.elements.length - 1];
                prefix = ',' + prefix;
                indexSubtract = 0;
            }
            else {
                node = arrLiteral;
                indexSubtract = 1;
            }
            position = node.getEnd() - indexSubtract;
            toInsert = prefix + def;
        }
        else {
            return false;
        }
    }
    recorder.insertLeft(position, toInsert);
    return true;
}
exports.insertMetaEntry = insertMetaEntry;
//# sourceMappingURL=insertMetaEntry.js.map