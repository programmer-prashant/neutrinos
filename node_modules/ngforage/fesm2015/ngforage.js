import { InjectionToken, Injectable, Optional, Inject, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';
import * as lf from 'localforage';
import lf__default from 'localforage';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/cache/cached-item.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Cached data
 * @record
 * @template T
 */
function CachedItem() { }
if (false) {
    /**
     * The data
     * @type {?}
     */
    CachedItem.prototype.data;
    /**
     * Whether the data has expired
     * @type {?}
     */
    CachedItem.prototype.expired;
    /**
     * When the cached item expired or will expire
     * @type {?}
     */
    CachedItem.prototype.expires;
    /**
     * Number of milliseconds until the data expires
     * @type {?}
     */
    CachedItem.prototype.expiresIn;
    /**
     * Whether data was found
     * @type {?}
     */
    CachedItem.prototype.hasData;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/cache/cached-item-impl.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 * @template T
 */
class CachedItemImpl {
    /**
     * @param {?} data
     * @param {?} expiryTime
     */
    constructor(data, expiryTime) {
        this.data = data;
        this.expires = new Date(typeof (/** @type {?} */ (expiryTime)) === 'number' ? expiryTime : 0);
    }
    /**
     * @return {?}
     */
    get expired() {
        /** @type {?} */
        const value = this.expiresIn === 0;
        if (value) {
            Object.defineProperty(this, 'expired', { value });
        }
        return value;
    }
    /**
     * @return {?}
     */
    get expiresIn() {
        /** @type {?} */
        const value = Math.max(0, this.expires.getTime() - Date.now());
        if (!value) {
            Object.defineProperty(this, 'expiresIn', { value });
        }
        return value;
    }
    /**
     * @return {?}
     */
    get hasData() {
        /** @type {?} */
        const value = this.data != null;
        Object.defineProperty(this, 'hasData', { value });
        return value;
    }
    /**
     * @return {?}
     */
    toJSON() {
        return {
            data: this.data,
            expired: this.expired,
            expires: this.expires,
            expiresIn: this.expiresIn,
            hasData: this.hasData
        };
    }
    /**
     * @return {?}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
if (false) {
    /** @type {?} */
    CachedItemImpl.prototype.expires;
    /** @type {?} */
    CachedItemImpl.prototype.data;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/imports/localforage.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 * @type {?}
 */
const localForage = 'defineDriver' in lf ? lf : lf__default;

/**
 * @fileoverview added by tsickle
 * Generated from: lib/misc/driver.enum.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const Driver = {
    /** The IndexedDB driver */
    INDEXED_DB: (/** @type {?} */ (localForage.INDEXEDDB)),
    /** The localStorage driver */
    LOCAL_STORAGE: (/** @type {?} */ (localForage.LOCALSTORAGE)),
    /** The WebSQL driver */
    WEB_SQL: (/** @type {?} */ (localForage.WEBSQL)),
};
// Clean up after Typescript's two-way enum transpilig
for (const d of [localForage.INDEXEDDB, localForage.LOCALSTORAGE, localForage.WEBSQL]) {
    delete Driver[d];
}
Object.freeze(Driver);

/**
 * @fileoverview added by tsickle
 * Generated from: lib/misc/injection-tokens.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Default ngforage configuration
 * @type {?}
 */
const DEFAULT_CONFIG = new InjectionToken('Default NgForage config');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/config/ng-forage-config.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 * @type {?}
 */
const $defaultConfig = Symbol('Default Config');
/**
 * Global/default configuration
 */
class NgForageConfig {
    /**
     * @param {?} conf
     */
    constructor(conf) {
        this[$defaultConfig] = {
            cacheTime: 300000,
            description: '',
            driver: [Driver.INDEXED_DB, Driver.WEB_SQL, Driver.LOCAL_STORAGE],
            name: 'ngForage',
            size: 4980736,
            storeName: 'ng_forage',
            version: 1
        };
        if (conf) {
            this.configure(conf);
        }
    }
    /**
     * Cache time in milliseconds
     * \@default 300000
     * @return {?}
     */
    get cacheTime() {
        return (/** @type {?} */ (this[$defaultConfig].cacheTime));
    }
    /**
     * @param {?} t
     * @return {?}
     */
    set cacheTime(t) {
        this[$defaultConfig].cacheTime = t;
    }
    /**
     * Get the compiled configuration
     * @return {?}
     */
    get config() {
        return {
            cacheTime: this.cacheTime,
            description: this.description,
            driver: this.driver,
            name: this.name,
            size: this.size,
            storeName: this.storeName,
            version: this.version
        };
    }
    /**
     * A description of the database, essentially for developer usage.
     * \@default
     * @return {?}
     */
    get description() {
        return (/** @type {?} */ (this[$defaultConfig].description));
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set description(v) {
        this[$defaultConfig].description = v;
    }
    /**
     * The preferred driver(s) to use.
     * @return {?}
     */
    get driver() {
        if (typeof this[$defaultConfig].driver === 'string') {
            return (/** @type {?} */ (this[$defaultConfig].driver));
        }
        return ((/** @type {?} */ (this[$defaultConfig].driver))).slice();
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set driver(v) {
        this[$defaultConfig].driver = v;
    }
    /**
     * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.
     * In localStorage, this is used as a key prefix for all keys stored in localStorage.
     * \@default ngForage
     * @return {?}
     */
    get name() {
        return (/** @type {?} */ (this[$defaultConfig].name));
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set name(v) {
        this[$defaultConfig].name = v;
    }
    /**
     * The size of the database in bytes. Used only in WebSQL for now.
     * \@default 4980736
     * @return {?}
     */
    get size() {
        return (/** @type {?} */ (this[$defaultConfig].size));
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set size(v) {
        this[$defaultConfig].size = v;
    }
    /**
     * The name of the datastore.
     * In IndexedDB this is the dataStore,
     * in WebSQL this is the name of the key/value table in the database.
     * Must be alphanumeric, with underscores.
     * Any non-alphanumeric characters will be converted to underscores.
     * \@default ng_forage
     * @return {?}
     */
    get storeName() {
        return (/** @type {?} */ (this[$defaultConfig].storeName));
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set storeName(v) {
        this[$defaultConfig].storeName = v;
    }
    /**
     * The version of your database. May be used for upgrades in the future; currently unused.
     * \@default 1.0
     * @return {?}
     */
    get version() {
        return (/** @type {?} */ (this[$defaultConfig].version));
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set version(v) {
        this[$defaultConfig].version = v;
    }
    /**
     * Bulk-set configuration options
     * @template THIS
     * @this {THIS}
     * @param {?} opts The configuration
     * @return {THIS}
     */
    configure(opts) {
        opts = opts || {};
        if (opts.driver && ((/** @type {?} */ (opts.driver))).slice) {
            opts.driver = ((/** @type {?} */ (opts.driver))).slice();
        }
        Object.assign((/** @type {?} */ (this))[$defaultConfig], opts);
        return (/** @type {?} */ (this));
    }
    /**
     * Define a driver
     *
     * You’ll want to make sure you accept a callback argument and that you pass the same arguments to callbacks as the
     * default drivers do. You’ll also want to resolve or reject promises.
     * Check any of the {\@link https://github.com/mozilla/localForage/tree/master/src/drivers default drivers}
     * for an idea of how to implement your own, custom driver.
     * @param {?} spec Driver spec
     * @return {?}
     */
    defineDriver(spec) {
        return localForage.defineDriver(spec);
    }
    /**
     * \@internal
     * @return {?}
     */
    toJSON() {
        return this.config;
    }
    /**
     * @return {?}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
NgForageConfig.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
NgForageConfig.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DEFAULT_CONFIG,] }] }
];
/** @nocollapse */ NgForageConfig.ɵprov = ɵɵdefineInjectable({ factory: function NgForageConfig_Factory() { return new NgForageConfig(ɵɵinject(DEFAULT_CONFIG, 8)); }, token: NgForageConfig, providedIn: "root" });
if (false) {
    /* Skipping unnamed member:
    private readonly [$defaultConfig]: NgForageOptions;*/
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/instance-factory/instance-factory.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 * @record
 */
function InstanceMap() { }
/**
 * \@internal
 * @type {?}
 */
const stores = {};
/**
 * \@internal
 * @param {?=} driver
 * @return {?}
 */
function getDriverString(driver) {
    if (!driver) {
        return '';
    }
    else if (Array.isArray(driver)) {
        return driver.slice().sort().join(',');
    }
    else {
        return (/** @type {?} */ (driver));
    }
}
/**
 * \@internal
 * @param {?} cfg
 * @return {?}
 */
function getHash(cfg) {
    return [
        getDriverString(cfg.driver),
        cfg.name,
        cfg.size,
        cfg.storeName,
        cfg.version,
        cfg.description,
        cfg.cacheTime
    ].join('|');
}
/**
 * \@internal
 * @type {?}
 */
const conf$ = Symbol('Config');
/**
 * Creates localForage instances
 */
class InstanceFactory {
    /**
     * \@internal
     * @param {?} conf
     */
    constructor(conf) {
        this[conf$] = conf;
    }
    /**
     * @param {?} cfg
     * @return {?}
     */
    getInstance(cfg) {
        cfg = Object.assign({}, this[conf$].config, cfg || {});
        /** @type {?} */
        const hash = getHash(cfg);
        if (!stores[hash]) {
            stores[hash] = localForage.createInstance(cfg);
        }
        return stores[hash];
    }
}
InstanceFactory.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
InstanceFactory.ctorParameters = () => [
    { type: NgForageConfig }
];
/** @nocollapse */ InstanceFactory.ɵprov = ɵɵdefineInjectable({ factory: function InstanceFactory_Factory() { return new InstanceFactory(ɵɵinject(NgForageConfig)); }, token: InstanceFactory, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * Generated from: lib/config/base-configurable-impl.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 * @type {?}
 */
const store$ = Symbol('Store');
/**
 * Abstract service-level configuration layer for NgForage
 * @abstract
 */
class BaseConfigurableImpl {
    /**
     * \@internal
     * @param {?} config
     * @param {?} instanceFactory
     */
    constructor(config, instanceFactory) {
        /**
         * \@internal
         */
        this.config = {};
        /**
         * \@internal
         */
        this.storeNeedsRecalc = true;
        this.baseConfig = config;
        this.fact = instanceFactory;
    }
    /**
     * A description of the database, essentially for developer usage.
     * \@default ""
     * @return {?}
     */
    get description() {
        return this.config.description || this.baseConfig.description;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set description(v) {
        this.config.description = v;
        this.storeNeedsRecalc = true;
    }
    /**
     * The preferred driver(s) to use.
     * \@default IndexedDB, WebSQL and localStorage
     * @return {?}
     */
    get driver() {
        return this.config.driver || this.baseConfig.driver;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set driver(v) {
        this.config.driver = v;
        this.storeNeedsRecalc = true;
    }
    /**
     * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.
     * In localStorage, this is used as a key prefix for all keys stored in localStorage.
     * \@default ngForage
     * @return {?}
     */
    get name() {
        return this.config.name || this.baseConfig.name;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set name(v) {
        this.config.name = v;
        this.storeNeedsRecalc = true;
    }
    /**
     * The size of the database in bytes. Used only in WebSQL for now.
     * \@default 4980736
     * @return {?}
     */
    get size() {
        return this.config.size || this.baseConfig.size;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set size(v) {
        this.config.size = v;
        this.storeNeedsRecalc = true;
    }
    /**
     * The name of the datastore.
     * In IndexedDB this is the dataStore,
     * in WebSQL this is the name of the key/value table in the database.
     * Must be alphanumeric, with underscores.
     * Any non-alphanumeric characters will be converted to underscores.
     * \@default ng_forage
     * @return {?}
     */
    get storeName() {
        return this.config.storeName || this.baseConfig.storeName;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set storeName(v) {
        this.config.storeName = v;
        this.storeNeedsRecalc = true;
    }
    /**
     * The version of your database. May be used for upgrades in the future; currently unused.
     * \@default 1.0
     * @return {?}
     */
    get version() {
        return 'version' in this.config ? (/** @type {?} */ (this.config.version)) : this.baseConfig.version;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set version(v) {
        this.config.version = v;
        this.storeNeedsRecalc = true;
    }
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    get finalConfig() {
        return Object.assign({}, this.baseConfig.config, this.config);
    }
    /**
     * \@internal
     * @protected
     * @return {?}
     */
    get store() {
        if (this.storeNeedsRecalc || !this[store$]) {
            this[store$] = this.fact.getInstance(this.finalConfig);
            this.storeNeedsRecalc = false;
        }
        return this[store$];
    }
    /**
     * Bulk-set configuration options
     * @template THIS
     * @this {THIS}
     * @param {?} opts The configuration
     * @return {THIS}
     */
    configure(opts) {
        opts = opts || {};
        if (Array.isArray(opts.driver)) {
            opts.driver = opts.driver.slice();
        }
        Object.assign((/** @type {?} */ (this)).config, opts);
        (/** @type {?} */ (this)).storeNeedsRecalc = true;
        return (/** @type {?} */ (this));
    }
    /**
     * @return {?}
     */
    toJSON() {
        return {
            description: this.description,
            driver: this.driver,
            name: this.name,
            size: this.size,
            storeName: this.storeName,
            version: this.version
        };
    }
    /**
     * @return {?}
     */
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
BaseConfigurableImpl.decorators = [
    { type: Injectable }
];
/** @nocollapse */
BaseConfigurableImpl.ctorParameters = () => [
    { type: NgForageConfig, decorators: [{ type: Inject, args: [NgForageConfig,] }] },
    { type: InstanceFactory, decorators: [{ type: Inject, args: [InstanceFactory,] }] }
];
if (false) {
    /**
     * \@internal
     * @type {?}
     * @protected
     */
    BaseConfigurableImpl.prototype.baseConfig;
    /**
     * \@internal
     * @type {?}
     * @protected
     */
    BaseConfigurableImpl.prototype.config;
    /**
     * \@internal
     * @type {?}
     * @protected
     */
    BaseConfigurableImpl.prototype.fact;
    /**
     * \@internal
     * @type {?}
     * @protected
     */
    BaseConfigurableImpl.prototype.storeNeedsRecalc;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/main/ng-forage.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Cache instance
 */
class NgForage extends BaseConfigurableImpl {
    /**
     * Returns the name of the driver being used, or null if none can be used.
     * @return {?}
     */
    get activeDriver() {
        return this.store.driver();
    }
    /**
     * Removes every key from the database, returning it to a blank slate.
     *
     * clear() will remove <b>every item in the offline store</b>. Use this method with caution.
     * @return {?}
     */
    clear() {
        return this.store.clear();
    }
    /**
     * Make a clone of the instance
     * @param {?=} config Optional configuration
     * @return {?}
     */
    clone(config) {
        /** @type {?} */
        const inst = new NgForage(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    }
    /**
     * Gets an item from the storage library.
     * If the key does not exist, getItem() will return null.
     * @template T
     * @param {?} key Data key
     * @return {?}
     */
    getItem(key) {
        return this.store.getItem(key);
    }
    /**
     * Iterate over all value/key pairs in datastore.
     * <i>iteratee</i> is called once for each pair, with the following arguments:
     * <ol>
     *   <li>Value</li>
     *   <li>Key</li>
     *   <li>iterationNumber - one-based number</li>
     * </ol>
     * iterate() supports early exit by returning non undefined value inside iteratorCallback callback.
     * @template T, U
     * @param {?} iteratee
     * @return {?}
     */
    iterate(iteratee) {
        return this.store.iterate(iteratee);
    }
    /**
     * Get the name of a key based on its ID.
     * @param {?} index
     * @return {?}
     */
    key(index) {
        return this.store.key(index);
    }
    /**
     * Get the list of all keys in the datastore.
     * @return {?}
     */
    keys() {
        return this.store.keys();
    }
    /**
     * Gets the number of keys in the offline store (i.e. its “length”).
     * @return {?}
     */
    length() {
        return this.store.length();
    }
    /**
     * Even though localForage queues up all of its data API method calls,
     * ready() provides a way to determine whether the asynchronous driver initialization process has finished.
     * That’s useful in cases like when we want to know which driver localForage has settled down using.
     * @return {?}
     */
    ready() {
        return this.store.ready();
    }
    /**
     * Removes the value of a key from the offline store.
     * @param {?} key Data key
     * @return {?}
     */
    removeItem(key) {
        return this.store.removeItem(key);
    }
    /**
     * Saves data to an offline store. You can store the following types of JavaScript objects:
     * <ul>
     *  <li>Array</li>
     *  <li>ArrayBuffer</li>
     *  <li>Blob</li>
     *  <li>Float32Array</li>
     *  <li>Float64Array</li>
     *  <li>Int8Array</li>
     *  <li>Int16Array</li>
     *  <li>Int32Array</li>
     *  <li>Number</li>
     *  <li>Object</li>
     *  <li>Uint8Array</li>
     *  <li>Uint8ClampedArray</li>
     *  <li>Uint16Array</li>
     *  <li>Uint32Array</li>
     *  <li>String</li>
     * </ul>
     * @template T
     * @param {?} key Data key
     * @param {?} data Data
     * @return {?}
     */
    setItem(key, data) {
        return this.store.setItem(key, data);
    }
    /**
     * Check whether the given driver is supported/registered.
     * @param {?} driver Driver name
     * @return {?}
     */
    supports(driver) {
        return this.store.supports((/** @type {?} */ (driver)));
    }
}
NgForage.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ NgForage.ɵprov = ɵɵdefineInjectable({ factory: function NgForage_Factory() { return new NgForage(ɵɵinject(NgForageConfig), ɵɵinject(InstanceFactory)); }, token: NgForage, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * Generated from: lib/cache/ng-forage-cache.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 * @record
 */
function CacheKeys() { }
if (false) {
    /** @type {?} */
    CacheKeys.prototype.data;
    /** @type {?} */
    CacheKeys.prototype.expiry;
}
/**
 * \@internal
 * @param {?} mainKey
 * @return {?}
 */
function calculateCacheKeys(mainKey) {
    return {
        data: `${mainKey}_data`,
        expiry: `${mainKey}_expiry`
    };
}
/**
 * \@internal
 * @template T
 * @param {?} r
 * @return {?}
 */
function toCachedItem(r) {
    return new CachedItemImpl(r[0], r[1]);
}
/**
 * \@internal
 * @template T
 * @param {?} r
 * @return {?}
 */
function head(r) {
    return r[0];
}
/**
 * \@internal
 * @return {?}
 */
// tslint:disable-next-line:no-empty
function toVoid() {
}
/**
 * An extension of {\@link NgForage} which adds expiration support
 */
class NgForageCache extends NgForage {
    /**
     * Cache time in milliseconds
     * \@default 300000
     * @return {?}
     */
    get cacheTime() {
        return this.config.cacheTime || this.baseConfig.cacheTime;
    }
    /**
     * @param {?} t
     * @return {?}
     */
    set cacheTime(t) {
        this.config.cacheTime = t;
        this.storeNeedsRecalc = true;
    }
    /**
     * @inheritDoc
     * @param {?=} config
     * @return {?}
     */
    clone(config) {
        /** @type {?} */
        const inst = new NgForageCache(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    }
    /**
     * Retrieve data
     * @template T
     * @param {?} key Data key
     * @return {?}
     */
    getCached(key) {
        /** @type {?} */
        const keys = calculateCacheKeys(key);
        /** @type {?} */
        const dataPromise = this.getItem(keys.data);
        /** @type {?} */
        const expiryPromise = this.getItem(keys.expiry);
        return Promise.all([dataPromise, expiryPromise]).then(toCachedItem);
    }
    /**
     * Remove data
     * @param {?} key Data key
     * @return {?}
     */
    removeCached(key) {
        /** @type {?} */
        const keys = calculateCacheKeys(key);
        /** @type {?} */
        const dataPromise = this.removeItem(keys.data);
        /** @type {?} */
        const expiryPromise = this.removeItem(keys.expiry);
        return Promise.all([dataPromise, expiryPromise]).then(toVoid);
    }
    /**
     * Set data
     * @template T
     * @param {?} key Data key
     * @param {?} data Data to set
     * @param {?=} cacheTime
     * @return {?}
     */
    setCached(key, data, cacheTime) {
        /** @type {?} */
        const keys = calculateCacheKeys(key);
        /** @type {?} */
        const expiry = typeof cacheTime === 'number' ? cacheTime : this.cacheTime;
        /** @type {?} */
        const dataPromise = this.setItem(keys.data, data);
        /** @type {?} */
        const expiryPromise = this.setItem(keys.expiry, Date.now() + expiry);
        return Promise.all([dataPromise, expiryPromise]).then(head);
    }
    /**
     * \@internal
     * @return {?}
     */
    toJSON() {
        return Object.assign((/** @type {?} */ (super.toJSON())), { cacheTime: this.cacheTime });
    }
}
NgForageCache.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ NgForageCache.ɵprov = ɵɵdefineInjectable({ factory: function NgForageCache_Factory() { return new NgForageCache(ɵɵinject(NgForageConfig), ɵɵinject(InstanceFactory)); }, token: NgForageCache, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * Generated from: lib/cache/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/config/base-configurable.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A configurable object
 * @record
 */
function BaseConfigurable() { }
if (false) {
    /**
     * A description of the database, essentially for developer usage.
     * \@default ""
     * @type {?}
     */
    BaseConfigurable.prototype.description;
    /**
     * The preferred driver(s) to use.
     * \@default IndexedDB, WebSQL & localStorage
     * @type {?}
     */
    BaseConfigurable.prototype.driver;
    /**
     * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.
     * In localStorage, this is used as a key prefix for all keys stored in localStorage.
     * \@default ngForage
     * @type {?}
     */
    BaseConfigurable.prototype.name;
    /**
     * The size of the database in bytes. Used only in WebSQL for now.
     * \@default 4980736
     * @type {?}
     */
    BaseConfigurable.prototype.size;
    /**
     * The name of the datastore.
     * In IndexedDB this is the dataStore,
     * in WebSQL this is the name of the key/value table in the database.
     * Must be alphanumeric, with underscores.
     * Any non-alphanumeric characters will be converted to underscores.
     * \@default ng_forage
     * @type {?}
     */
    BaseConfigurable.prototype.storeName;
    /**
     * The version of your database. May be used for upgrades in the future; currently unused.
     * \@default 1.0
     * @type {?}
     */
    BaseConfigurable.prototype.version;
    /**
     * Bulk-set configuration options
     * @template THIS
     * @this {THIS}
     * @param {?} opts The configuration
     * @return {THIS}
     */
    BaseConfigurable.prototype.configure = function (opts) { };
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/config/cache-configurable.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A cacheable configurable object
 * @record
 */
function CacheConfigurable() { }
if (false) {
    /**
     * Cache time in milliseconds
     * \@default 300000
     * @type {?}
     */
    CacheConfigurable.prototype.cacheTime;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/config/ng-forage-options.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/config/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dedicated/ng-forage-cache-dedicated.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 */
class NgForageCacheDedicated extends NgForageCache {
    /**
     * @param {?=} config
     * @return {?}
     */
    clone(config) {
        /** @type {?} */
        const inst = new NgForageCacheDedicated(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dedicated/ng-forage-dedicated.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 */
class NgForageDedicated extends NgForage {
    /**
     * @param {?=} config
     * @return {?}
     */
    clone(config) {
        /** @type {?} */
        const inst = new NgForageDedicated(this.baseConfig, this.fact);
        inst.configure(Object.assign(this.finalConfig, config || {}));
        return inst;
    }
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dedicated/dedicated-instance-factory.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 * @type {?}
 */
const conf$$1 = Symbol('NgForageConfig');
/**
 * \@internal
 * @type {?}
 */
const if$ = Symbol('InstanceFactory');
class DedicatedInstanceFactory {
    /**
     * @param {?} conf
     * @param {?} instFact
     */
    constructor(conf, instFact) {
        this[conf$$1] = conf;
        this[if$] = instFact;
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    createCache(config) {
        /** @type {?} */
        const inst = new NgForageCacheDedicated(this[conf$$1], this[if$]);
        if (config) {
            inst.configure(config);
        }
        return inst;
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    createNgForage(config) {
        /** @type {?} */
        const inst = new NgForageDedicated(this[conf$$1], this[if$]);
        if (config) {
            inst.configure(config);
        }
        return inst;
    }
}
DedicatedInstanceFactory.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
DedicatedInstanceFactory.ctorParameters = () => [
    { type: NgForageConfig },
    { type: InstanceFactory }
];
/** @nocollapse */ DedicatedInstanceFactory.ɵprov = ɵɵdefineInjectable({ factory: function DedicatedInstanceFactory_Factory() { return new DedicatedInstanceFactory(ɵɵinject(NgForageConfig), ɵɵinject(InstanceFactory)); }, token: DedicatedInstanceFactory, providedIn: "root" });
if (false) {
    /* Skipping unnamed member:
    private readonly [conf$]: NgForageConfig;*/
    /* Skipping unnamed member:
    private readonly [if$]: InstanceFactory;*/
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/dedicated/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/instance-factory/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/main/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/misc/driver-type.type.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngforage.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { BaseConfigurableImpl, CachedItemImpl, DEFAULT_CONFIG, DedicatedInstanceFactory, Driver, InstanceFactory, NgForage, NgForageCache, NgForageCacheDedicated, NgForageConfig, NgForageDedicated };
//# sourceMappingURL=ngforage.js.map
