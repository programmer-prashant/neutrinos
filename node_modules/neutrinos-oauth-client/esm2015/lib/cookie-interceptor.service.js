/**
 * @fileoverview added by tsickle
 * Generated from: lib/cookie-interceptor.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { UtilService } from './services/util.service';
import { NeutrinosOAuthClientService } from './neutrinos-oauth-client.service';
import * as i0 from "@angular/core";
import * as i1 from "./services/util.service";
import * as i2 from "./neutrinos-oauth-client.service";
export class CookieInterceptorService {
    /**
     * @param {?} utilService
     * @param {?} neutrinosOAuthClientService
     */
    constructor(utilService, neutrinosOAuthClientService) {
        this.utilService = utilService;
        this.neutrinosOAuthClientService = neutrinosOAuthClientService;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        /* withCredentials adds cookies to the request for cross site (Only ssd urls).*/
        /** @type {?} */
        const baseUrl = this.utilService.getSSDBasePath();
        /** @type {?} */
        const isSSD = (baseUrl !== '' && request.url.includes(baseUrl));
        if (isSSD && this.isCrossDomain(baseUrl)) {
            request = request.clone({
                withCredentials: true
            });
        }
        return next.handle(request).pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            return event;
        })), catchError((/**
         * @param {?} errorResponse
         * @return {?}
         */
        (errorResponse) => {
            /*Intercept all requests and remove userinfo and cookies when status is 401 with code SESSION_EXPIRED, which means
            * cookies have expired or access has been revoked by the OAuth providers hence IDS rejected.  */
            if (errorResponse && errorResponse.hasOwnProperty('status') && errorResponse.status === 401 &&
                errorResponse.error.hasOwnProperty('code')) {
                this.neutrinosOAuthClientService.removeUserInfo(errorResponse.error);
            }
            return throwError(errorResponse);
        })));
    }
    /**
     * Returns true is the ssd url is running on a different domain than where UI is hosted.
     * For mobile Returns false always since UI is already bundled with cordova
     * If the user is not using IDS and is cross domain isIDSEnabled can be set to false to skip adding withCredentials
     * @private
     * @param {?} ssdUrl - string
     * @return {?}
     */
    isCrossDomain(ssdUrl) {
        try {
            ssdUrl = new URL(ssdUrl);
            return (this.utilService.getPlatformType() === 'browser' && (ssdUrl.host !== location.host)
                && this.utilService.getEnvValue('isIDSEnabled') === 'true');
        }
        catch (e) {
            return false; // ssdUrl is not a valid URL hence return false;
        }
    }
}
CookieInterceptorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CookieInterceptorService.ctorParameters = () => [
    { type: UtilService },
    { type: NeutrinosOAuthClientService }
];
/** @nocollapse */ CookieInterceptorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CookieInterceptorService_Factory() { return new CookieInterceptorService(i0.ɵɵinject(i1.UtilService), i0.ɵɵinject(i2.NeutrinosOAuthClientService)); }, token: CookieInterceptorService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    CookieInterceptorService.prototype.utilService;
    /**
     * @type {?}
     * @private
     */
    CookieInterceptorService.prototype.neutrinosOAuthClientService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29va2llLWludGVyY2VwdG9yLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiL2hvbWUvbmV1dHJpbm9zL0RvY3VtZW50cy9uZXV0cmlub3MtbW9kdWxlcy1hbmd1bGFyL25ldXRyaW5vcy1hdXRoL3Byb2plY3RzL25ldXRyaW5vcy1vYXV0aC1jbGllbnQvc3JjLyIsInNvdXJjZXMiOlsibGliL2Nvb2tpZS1pbnRlcmNlcHRvci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUzQyxPQUFPLEVBQWMsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzlDLE9BQU8sRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDakQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3RELE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDOzs7O0FBSy9FLE1BQU0sT0FBTyx3QkFBd0I7Ozs7O0lBRW5DLFlBQW9CLFdBQXdCLEVBQVUsMkJBQXdEO1FBQTFGLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQVUsZ0NBQTJCLEdBQTNCLDJCQUEyQixDQUE2QjtJQUFJLENBQUM7Ozs7OztJQUVuSCxTQUFTLENBQUMsT0FBeUIsRUFBRSxJQUFpQjs7O2NBRzlDLE9BQU8sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsRUFBRTs7Y0FDM0MsS0FBSyxHQUFHLENBQUMsT0FBTyxLQUFLLEVBQUUsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMvRCxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3hDLE9BQU8sR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO2dCQUN0QixlQUFlLEVBQUUsSUFBSTthQUN0QixDQUFDLENBQUM7U0FDSjtRQUNELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRzs7OztRQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzNDLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQyxFQUFDLEVBQUUsVUFBVTs7OztRQUFDLENBQUMsYUFBZ0MsRUFBRSxFQUFFO1lBQ2xEOzRHQUNnRztZQUNoRyxJQUFJLGFBQWEsSUFBSSxhQUFhLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxJQUFJLGFBQWEsQ0FBQyxNQUFNLEtBQUssR0FBRztnQkFDekYsYUFBYSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQzVDLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3RFO1lBQ0QsT0FBTyxVQUFVLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDbkMsQ0FBQyxFQUFDLENBQUMsQ0FBQztJQUNOLENBQUM7Ozs7Ozs7OztJQVFPLGFBQWEsQ0FBQyxNQUFNO1FBQzFCLElBQUk7WUFDRixNQUFNLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDekIsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsZUFBZSxFQUFFLEtBQUssU0FBUyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsSUFBSSxDQUFDO21CQUN0RixJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsS0FBSyxNQUFNLENBQUMsQ0FBQztTQUMvRDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxLQUFLLENBQUMsQ0FBQyxnREFBZ0Q7U0FDL0Q7SUFFSCxDQUFDOzs7WUE3Q0YsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7O1lBTFEsV0FBVztZQUNYLDJCQUEyQjs7Ozs7Ozs7SUFPdEIsK0NBQWdDOzs7OztJQUFFLCtEQUFnRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEh0dHBSZXF1ZXN0LCBIdHRwSGFuZGxlciwgSHR0cEV2ZW50LCBIdHRwRXJyb3JSZXNwb25zZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IE9ic2VydmFibGUsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFV0aWxTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy91dGlsLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmV1dHJpbm9zT0F1dGhDbGllbnRTZXJ2aWNlIH0gZnJvbSAnLi9uZXV0cmlub3Mtb2F1dGgtY2xpZW50LnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBDb29raWVJbnRlcmNlcHRvclNlcnZpY2Uge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdXRpbFNlcnZpY2U6IFV0aWxTZXJ2aWNlLCBwcml2YXRlIG5ldXRyaW5vc09BdXRoQ2xpZW50U2VydmljZTogTmV1dHJpbm9zT0F1dGhDbGllbnRTZXJ2aWNlKSB7IH1cblxuICBpbnRlcmNlcHQocmVxdWVzdDogSHR0cFJlcXVlc3Q8YW55PiwgbmV4dDogSHR0cEhhbmRsZXIpOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PiB7XG5cbiAgICAvKiB3aXRoQ3JlZGVudGlhbHMgYWRkcyBjb29raWVzIHRvIHRoZSByZXF1ZXN0IGZvciBjcm9zcyBzaXRlIChPbmx5IHNzZCB1cmxzKS4qL1xuICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLnV0aWxTZXJ2aWNlLmdldFNTREJhc2VQYXRoKCk7XG4gICAgY29uc3QgaXNTU0QgPSAoYmFzZVVybCAhPT0gJycgJiYgcmVxdWVzdC51cmwuaW5jbHVkZXMoYmFzZVVybCkpO1xuICAgIGlmIChpc1NTRCAmJiB0aGlzLmlzQ3Jvc3NEb21haW4oYmFzZVVybCkpIHtcbiAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LmNsb25lKHtcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcXVlc3QpLnBpcGUobWFwKGV2ZW50ID0+IHtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9KSwgY2F0Y2hFcnJvcigoZXJyb3JSZXNwb25zZTogSHR0cEVycm9yUmVzcG9uc2UpID0+IHtcbiAgICAgIC8qSW50ZXJjZXB0IGFsbCByZXF1ZXN0cyBhbmQgcmVtb3ZlIHVzZXJpbmZvIGFuZCBjb29raWVzIHdoZW4gc3RhdHVzIGlzIDQwMSB3aXRoIGNvZGUgU0VTU0lPTl9FWFBJUkVELCB3aGljaCBtZWFuc1xuICAgICAgKiBjb29raWVzIGhhdmUgZXhwaXJlZCBvciBhY2Nlc3MgaGFzIGJlZW4gcmV2b2tlZCBieSB0aGUgT0F1dGggcHJvdmlkZXJzIGhlbmNlIElEUyByZWplY3RlZC4gICovXG4gICAgICBpZiAoZXJyb3JSZXNwb25zZSAmJiBlcnJvclJlc3BvbnNlLmhhc093blByb3BlcnR5KCdzdGF0dXMnKSAmJiBlcnJvclJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxICYmXG4gICAgICAgIGVycm9yUmVzcG9uc2UuZXJyb3IuaGFzT3duUHJvcGVydHkoJ2NvZGUnKSkge1xuICAgICAgICB0aGlzLm5ldXRyaW5vc09BdXRoQ2xpZW50U2VydmljZS5yZW1vdmVVc2VySW5mbyhlcnJvclJlc3BvbnNlLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yUmVzcG9uc2UpO1xuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaXMgdGhlIHNzZCB1cmwgaXMgcnVubmluZyBvbiBhIGRpZmZlcmVudCBkb21haW4gdGhhbiB3aGVyZSBVSSBpcyBob3N0ZWQuXG4gICAqIEZvciBtb2JpbGUgUmV0dXJucyBmYWxzZSBhbHdheXMgc2luY2UgVUkgaXMgYWxyZWFkeSBidW5kbGVkIHdpdGggY29yZG92YVxuICAgKiBJZiB0aGUgdXNlciBpcyBub3QgdXNpbmcgSURTIGFuZCBpcyBjcm9zcyBkb21haW4gaXNJRFNFbmFibGVkIGNhbiBiZSBzZXQgdG8gZmFsc2UgdG8gc2tpcCBhZGRpbmcgd2l0aENyZWRlbnRpYWxzXG4gICAqIEBwYXJhbSBzc2RVcmwgLSBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgaXNDcm9zc0RvbWFpbihzc2RVcmwpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgc3NkVXJsID0gbmV3IFVSTChzc2RVcmwpO1xuICAgICAgcmV0dXJuICh0aGlzLnV0aWxTZXJ2aWNlLmdldFBsYXRmb3JtVHlwZSgpID09PSAnYnJvd3NlcicgJiYgKHNzZFVybC5ob3N0ICE9PSBsb2NhdGlvbi5ob3N0KVxuICAgICAgICAmJiB0aGlzLnV0aWxTZXJ2aWNlLmdldEVudlZhbHVlKCdpc0lEU0VuYWJsZWQnKSA9PT0gJ3RydWUnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIHNzZFVybCBpcyBub3QgYSB2YWxpZCBVUkwgaGVuY2UgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICB9XG5cbn1cbiJdfQ==