import { __awaiter } from 'tslib';
import { isDevMode, Injectable, ɵɵdefineInjectable, ɵɵinject, Component, NgModule, APP_INITIALIZER } from '@angular/core';
import { HttpHeaders, HttpClient, HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { Subject, throwError } from 'rxjs';
import { Router, ActivatedRoute } from '@angular/router';
import { map, catchError } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/services/util.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UtilService {
    constructor() {
        this.platformType = this.checkPlatformType();
        this.getEnvironment();
    }
    /**
     * Returns 'mobile' or 'browser' based on the platform
     * @return {?}
     */
    getPlatformType() {
        return this.platformType;
    }
    /**
     * Returns env from neutrinos seed app
     * @private
     * @return {?}
     */
    getEnvironment() {
        if (window['neutrinos'] && window['neutrinos']['environments'] && window['neutrinos']['environments']['properties']) {
            // Break the refernce
            this.environment = JSON.parse(JSON.stringify(window['neutrinos']['environments']['properties']));
            // Append the url with / if ssdUrl does not end with /
            if (this.environment['ssdURL']) {
                this.environment['ssdURL'] = this.environment['ssdURL'].endsWith('/') ? this.environment['ssdURL'] :
                    (this.environment['ssdURL'] + '/');
            }
            return;
        }
        /*For dev env only */
        this.environment = {
            ssdURL: 'http://localhost:8081/api/',
            useDefaultExceptionUI: true,
            isIDSEnabled: 'true',
            webAppMountpoint: '',
            production: true
        };
    }
    /**
     * Returns 'mobile' or 'browser' based on the platform
     * @private
     * @return {?}
     */
    checkPlatformType() {
        // tslint:disable-next-line: no-string-literal
        if (window['device'] && (window['device']['platform'] !== 'browser' || window['device']['platform'] !== 'Browser')) {
            return 'mobile';
            // tslint:disable-next-line: no-string-literal
        }
        else if (window['device'] && (window['device']['platform'] === 'browser' || window['device']['platform'] === 'Browser')) {
            return 'cordova_browser';
        }
        else {
            return 'browser';
        }
    }
    /*URL helper methods */
    /**
     * @return {?}
     */
    getBaseLoginPath() {
        return `${this.environment.ssdURL}login`;
    }
    /**
     * @param {?} redirectTo
     * @return {?}
     */
    getWebLoginUrl(redirectTo) {
        redirectTo = this.calcRedirectUrl(redirectTo);
        return `${this.getBaseLoginPath()}?redirectTo=${redirectTo}`;
    }
    /**
     * @return {?}
     */
    getMobileLoginUrl() {
        return `${this.getBaseLoginPath()}?isMobile=true`;
    }
    /**
     * @param {?} redirectTo
     * @return {?}
     */
    getWebLogoutUrl(redirectTo) {
        redirectTo = this.calcRedirectUrl(redirectTo);
        return `${this.environment.ssdURL}logout?redirectTo=${redirectTo}`;
    }
    /**
     * @return {?}
     */
    getMobileLogoutUrl() {
        return `${this.environment.ssdURL}logout?isMobile=true`;
    }
    /**
     * @return {?}
     */
    getUserInfoUrl() {
        return `${this.environment.ssdURL}user/info`;
    }
    /**
     * @return {?}
     */
    getSSDBasePath() {
        return `${this.environment.ssdURL}`;
    }
    /**
     *  Returns a absoulte url for the urlPath
     * @private
     * @param {?} urlPath - path relative to the current host
     * @return {?}
     */
    calcRedirectUrl(urlPath) {
        if (urlPath) {
            /** @type {?} */
            let host = new URL(window.location.href).origin;
            if (!isDevMode()) {
                // Append `webAppMountpoint` to host
                host = (this.environment.webAppMountpoint !== '' && this.environment.webAppMountpoint !== '/')
                    ? new URL(this.environment.webAppMountpoint, host).href : host;
                // Get user redirect path with `webAppMountpoint`
                /** @type {?} */
                const mountPointWithRedirect = new URL(urlPath, host).pathname;
                return host + mountPointWithRedirect;
            }
            else {
                return new URL(urlPath, host);
            }
        }
        else {
            return window.location.href;
        }
    }
    /**
     *
     * @param {?} property - environment property key
     * @return {?}
     */
    getEnvValue(property) {
        return this.environment[property];
    }
}
UtilService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
UtilService.ctorParameters = () => [];
/** @nocollapse */ UtilService.ɵprov = ɵɵdefineInjectable({ factory: function UtilService_Factory() { return new UtilService(); }, token: UtilService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    UtilService.prototype.platformType;
    /**
     * @type {?}
     * @private
     */
    UtilService.prototype.environment;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/neutrinos-oauth-client.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NeutrinosOAuthClientService {
    /**
     * @param {?} util
     * @param {?} http
     */
    constructor(util, http) {
        this.util = util;
        this.http = http;
        this.cookieName = 'connect.sid';
        this.authStateSubject = new Subject();
    }
    /**
     * Get user info and tokens of the current logged in user
     * @return {?}
     */
    get userInfo() {
        return this.currentUserInfo;
    }
    /**
     * @return {?}
     */
    get isLoggedIn() {
        return this.currentUserInfo ? true : false;
    }
    /**
     * @private
     * @param {?} userInfo
     * @return {?}
     */
    setUserInfo(userInfo) {
        this.currentUserInfo = userInfo;
    }
    /**
     * Performs authentication based on configuration and returns user info for mobile env and
     * for web app user info is stored in memory. Call userInfo getter method to retrieve userinfo
     * @param {?=} redirectBackUrl - url to redirect back to when authentication is done. Valid only for Web.
     * For mobile use the Promise returned to perform post authentication actions
     * @return {?}
     */
    login(redirectBackUrl) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            if (this.util.getEnvValue('isIDSEnabled') === 'false') {
                return reject({ message: 'IDS is not enabled in environments' });
            }
            if (this.util.getPlatformType() === 'browser') {
                this.loginWithRedirect(redirectBackUrl);
                return;
            }
            this.loginWithInAppBrowser()
                .then((/**
             * @param {?} tokenset
             * @return {?}
             */
            tokenset => {
                return resolve(tokenset);
            }))
                .catch((/**
             * @param {?} authError
             * @return {?}
             */
            authError => {
                return reject(authError);
            }));
        }));
    }
    /**
     *
     * @private
     * @return {?}
     */
    loginWithInAppBrowser() {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const scriptURLS = ['/interaction/', '/auth-provider/return'];
            // execute JS only for this urls
            /** @type {?} */
            const script = yield this.getScript();
            // Get JS which stores guid and device details in local storage of webview
            /** @type {?} */
            const inAppBrowserRef = cordova.InAppBrowser.open(this.util.getMobileLoginUrl(), '_blank');
            /** @type {?} */
            const executeScriptCB = (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                if (event && event.hasOwnProperty('type') && event.hasOwnProperty('url') && event.type === 'loadstop'
                    && this.isURLMatch(event.url, scriptURLS)) {
                    inAppBrowserRef.executeScript({ code: script }, (/**
                     * @return {?}
                     */
                    () => { }));
                }
            });
            inAppBrowserRef.addEventListener('loadstop', executeScriptCB);
            /** @type {?} */
            const exitCB = (/**
             * @return {?}
             */
            () => {
                return reject({ code: 'auth-cancel', message: 'Authentication cancelled by user' });
            });
            inAppBrowserRef.addEventListener('message', (/**
             * @param {?} message
             * @return {?}
             */
            (message) => {
                if (message && message.data && message.data.auth && message.data.auth === 'success') {
                    inAppBrowserRef.removeEventListener('exit', exitCB);
                    inAppBrowserRef.close();
                    this.getUserInfo().then((/**
                     * @param {?} tokenset
                     * @return {?}
                     */
                    tokenset => {
                        return resolve(tokenset);
                    })).catch((/**
                     * @param {?} authErr
                     * @return {?}
                     */
                    authErr => {
                        return reject(authErr);
                    }));
                }
            }));
            // settle the promise if user closed the in app browser manually
            inAppBrowserRef.addEventListener('exit', exitCB);
        })));
    }
    /**
     * @private
     * @param {?} url
     * @param {?} compareWith
     * @return {?}
     */
    isURLMatch(url, compareWith) {
        return compareWith.some((/**
         * @param {?} u
         * @return {?}
         */
        u => url.includes(u)));
    }
    /**
     * Returns JS as a string to be executed in inAppBrowser which sets guid and device details in localStorage
     * @private
     * @return {?}
     */
    getScript() {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const deviceDetails = JSON.stringify(window['device']) || {};
            /** @type {?} */
            const guid = yield this.getuniqueDeviceID();
            /** @type {?} */
            const guidScript = guid ? `localStorage.setItem('guid', '${guid}')` : '';
            /** @type {?} */
            const script = `${guidScript}
          localStorage.setItem('additionalInfo', '${deviceDetails}')
          window.isScriptExecuted = true;`;
            return script;
        });
    }
    /**
     * @private
     * @return {?}
     */
    getuniqueDeviceID() {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            window['plugins'].uniqueDeviceID.get((/**
             * @param {?} guid
             * @return {?}
             */
            (guid) => {
                return resolve(guid);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            error => {
                return resolve(null);
            }));
        }));
    }
    /**
     * @return {?}
     */
    getUserInfo() {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            /** @type {?} */
            let headers = new HttpHeaders();
            /*Edge case: Userinfo is retreived from cache when login page is opened and user cancels the login attempt  */
            headers = headers.set('Cache-Control', 'no-cache, no-store, must-revalidate');
            headers = headers.set('Pragma', 'no-cache');
            headers = headers.set('Expires', '0');
            this.http.get(this.util.getUserInfoUrl(), { headers }).subscribe((/**
             * @param {?} tokenset
             * @return {?}
             */
            tokenset => {
                this.setUserInfo(tokenset);
                return resolve(tokenset);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            error => {
                this.destroyClientSession();
                return reject(error);
            }));
        }));
    }
    /*If SSD throws 401 during any http request due to refresh token expiry, cookie expiry or access revoke nullify the userinfo in memory
      and emit authState event  */
    /**
     * @param {?} errorResponse
     * @return {?}
     */
    removeUserInfo(errorResponse) {
        this.destroyClientSession();
        this.authStateSubject.next(errorResponse);
    }
    /**
     * Returns event when Auth state has changed due to session expiry, access revoke or cookie expiry.
     * @return {?}
     */
    authState() {
        return this.authStateSubject.asObservable();
    }
    /**
     * @private
     * @param {?} redirectBackUrl
     * @return {?}
     */
    loginWithRedirect(redirectBackUrl) {
        window.location.href = this.util.getWebLoginUrl(redirectBackUrl);
    }
    /**
     * Restores the connect.sid cookie from session storage during app bootstrap if device is mobile
     * @return {?}
     */
    restoreCookies() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.getCookie(this.cookieName, this.util.getSSDBasePath())
                .then((/**
             * @param {?} connectSid
             * @return {?}
             */
            (connectSid) => __awaiter(this, void 0, void 0, function* () {
                return yield this.setCookie(this.util.getSSDBasePath(), this.cookieName, connectSid);
            }))).catch((/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                return false;
            }));
        });
    }
    /**
     *
     * @private
     * @param {?} url - site where the cookie is stored
     * @param {?} cookieName - name of the cookie to restore
     * @param {?} cookieValue - value of the cookie to restore
     * @return {?}
     */
    setCookie(url, cookieName, cookieValue) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            cookieMaster.setCookieValue(url, cookieName, cookieValue, (/**
             * @return {?}
             */
            () => {
                return resolve(true);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                return reject(false);
            }));
        }));
    }
    /**
     *
     * @private
     * @param {?} cookieName          name of the cookie to retrieve
     * @param {?} fullCookieString    String containing all the cookies from an url
     * @return {?}
     */
    readCookieValueFromCookieString(cookieName, fullCookieString) {
        /** @type {?} */
        let cookieNameWithEqualsSign = cookieName + "=";
        /** @type {?} */
        let cookieArray = fullCookieString.split(';');
        for (let i = 0; i < cookieArray.length; i++) {
            /** @type {?} */
            let cookie = cookieArray[i];
            // Remove unnecessary leading spaces from cookie
            while (cookie.charAt(0) == ' ') {
                cookie = cookie.substring(1, cookie.length);
            }
            // Retrieve and return cookie value
            if (cookie.indexOf(cookieNameWithEqualsSign) == 0) {
                return cookie.substring(cookieNameWithEqualsSign.length, cookie.length);
            }
        }
        return null;
    }
    /**
     *
     * @private
     * @param {?} cookieName - name of the cookie to retrieve
     * @param {?} url - site where the cookie is stored
     * @return {?}
     */
    getCookie(cookieName, url) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            window['cordova'].plugins.CookiesPlugin.getCookie(url, (/**
             * @param {?} cookies
             * @return {?}
             */
            (cookies) => {
                /** @type {?} */
                let cookieValue = this.readCookieValueFromCookieString(cookieName, cookies);
                if (cookieValue) {
                    return resolve(cookieValue);
                }
                else {
                    return reject("cookie value null");
                }
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
                return reject(error);
            }));
        }));
    }
    /**
     * Logout the current user, destroys session between client and server.
     * @param {?=} redirectBackUrl - URL where the user is navigated post logout. Valid only for Web.
     * For mobile use the Promise returned to perform post authentication actions
     * @return {?}
     */
    logout(redirectBackUrl) {
        /** @type {?} */
        const logoutUrl = (this.util.getPlatformType() === 'browser') ? this.util.getWebLogoutUrl(redirectBackUrl)
            : this.util.getMobileLogoutUrl();
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this.http.get(logoutUrl).subscribe((/**
             * @param {?} idsLogoutInfo
             * @return {?}
             */
            idsLogoutInfo => {
                this.destroyIDSSession(idsLogoutInfo)
                    .then((/**
                 * @return {?}
                 */
                () => {
                    return resolve();
                }))
                    .catch((/**
                 * @param {?} logoutErr
                 * @return {?}
                 */
                logoutErr => {
                    return reject(logoutErr);
                }));
            }), (/**
             * @param {?} logoutError
             * @return {?}
             */
            logoutError => {
                return reject(logoutError);
            }));
        }));
    }
    /**
     * @private
     * @param {?} idsInfo
     * @return {?}
     */
    destroyIDSSession(idsInfo) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            if (idsInfo['sessionExists'] === false) {
                // No session present with SSD due to cookie expiry
                this.destroyClientSession();
                this.authStateSubject.next({ code: 'NO_SESSION', message: 'User session has already expired' });
                return resolve();
            }
            if (this.util.getPlatformType() === 'browser') {
                window.location.href = idsInfo['idsURL'];
            }
            else {
                this.logoutWithInappBrowser(idsInfo['idsURL'])
                    .then((/**
                 * @return {?}
                 */
                () => {
                    return resolve();
                }))
                    .catch((/**
                 * @param {?} sessionError
                 * @return {?}
                 */
                sessionError => {
                    return reject(sessionError);
                }));
            }
        }));
    }
    /**
     *
     * @private
     * @param {?} idsLogoutUrl - IDS logout url
     * Opens InApp browser and destroys the session
     * @return {?}
     */
    logoutWithInappBrowser(idsLogoutUrl) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            /** @type {?} */
            const exitCB = (/**
             * @return {?}
             */
            () => {
                return reject({ code: 'auth-cancel', message: 'Authentication cancelled by user' });
            });
            /** @type {?} */
            const inAppBrowserRef = cordova.InAppBrowser.open(idsLogoutUrl, '_blank');
            inAppBrowserRef.addEventListener('message', (/**
             * @param {?} message
             * @return {?}
             */
            (message) => {
                // Remove exit listener if script closed the in app browser
                if (message && message.data && message.data.auth && message.data.auth === 'success') {
                    inAppBrowserRef.removeEventListener('exit', exitCB);
                    inAppBrowserRef.close();
                    this.destroyClientSession();
                    return resolve();
                }
            }));
            // settle the promise if user closed the in app browser manually
            inAppBrowserRef.addEventListener('exit', exitCB);
        }));
    }
    /*Remove persisted cookies in local storage and nullify user info */
    /**
     * @private
     * @return {?}
     */
    destroyClientSession() {
        this.setUserInfo(null);
    }
}
NeutrinosOAuthClientService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NeutrinosOAuthClientService.ctorParameters = () => [
    { type: UtilService },
    { type: HttpClient }
];
/** @nocollapse */ NeutrinosOAuthClientService.ɵprov = ɵɵdefineInjectable({ factory: function NeutrinosOAuthClientService_Factory() { return new NeutrinosOAuthClientService(ɵɵinject(UtilService), ɵɵinject(HttpClient)); }, token: NeutrinosOAuthClientService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NeutrinosOAuthClientService.prototype.cookieName;
    /**
     * @type {?}
     * @private
     */
    NeutrinosOAuthClientService.prototype.currentUserInfo;
    /**
     * @type {?}
     * @private
     */
    NeutrinosOAuthClientService.prototype.authStateSubject;
    /**
     * @type {?}
     * @private
     */
    NeutrinosOAuthClientService.prototype.util;
    /**
     * @type {?}
     * @private
     */
    NeutrinosOAuthClientService.prototype.http;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/auth-guard.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NeutrinosAuthGuardService {
    /**
     * @param {?} _neutrinosOAuthClientService
     * @param {?} _router
     * @param {?} _arouter
     */
    constructor(_neutrinosOAuthClientService, _router, _arouter) {
        this._neutrinosOAuthClientService = _neutrinosOAuthClientService;
        this._router = _router;
        this._arouter = _arouter;
    }
    /**
     * @param {?} route
     * @param {?} state
     * @return {?}
     */
    canActivate(route, state) {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this.currUrl = state.url;
            if (this._neutrinosOAuthClientService.isLoggedIn) {
                return resolve(true);
            }
            else {
                this._neutrinosOAuthClientService.login().then((/**
                 * @param {?} tokenSet
                 * @return {?}
                 */
                tokenSet => {
                    this._router.navigate([this.currUrl]);
                    return resolve(true);
                }))
                    .catch((/**
                 * @param {?} err
                 * @return {?}
                 */
                err => {
                    console.error(err);
                    if (err && err.code == 'auth-cancel') {
                        // Added setTimeout for reloading the current route
                        setTimeout((/**
                         * @return {?}
                         */
                        () => {
                            this._router.navigateByUrl(this.currUrl, { skipLocationChange: true }).then((/**
                             * @return {?}
                             */
                            () => {
                                return resolve(false);
                            }));
                        }), 500);
                    }
                    else {
                        return resolve(false);
                    }
                }));
            }
        }));
    }
}
NeutrinosAuthGuardService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NeutrinosAuthGuardService.ctorParameters = () => [
    { type: NeutrinosOAuthClientService },
    { type: Router },
    { type: ActivatedRoute }
];
/** @nocollapse */ NeutrinosAuthGuardService.ɵprov = ɵɵdefineInjectable({ factory: function NeutrinosAuthGuardService_Factory() { return new NeutrinosAuthGuardService(ɵɵinject(NeutrinosOAuthClientService), ɵɵinject(Router), ɵɵinject(ActivatedRoute)); }, token: NeutrinosAuthGuardService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NeutrinosAuthGuardService.prototype.currUrl;
    /**
     * @type {?}
     * @private
     */
    NeutrinosAuthGuardService.prototype._neutrinosOAuthClientService;
    /**
     * @type {?}
     * @private
     */
    NeutrinosAuthGuardService.prototype._router;
    /**
     * @type {?}
     * @private
     */
    NeutrinosAuthGuardService.prototype._arouter;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/neutrinos-oauth.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NeutrinosOauthComponent {
    /**
     * @param {?} neutrinosOauthService
     * @param {?} http
     */
    constructor(neutrinosOauthService, http) {
        this.neutrinosOauthService = neutrinosOauthService;
        this.http = http;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.neutrinosOauthService.authState().subscribe((/**
         * @param {?} state
         * @return {?}
         */
        state => {
            console.log(state);
        }));
    }
    /**
     * @return {?}
     */
    login() {
        /** @type {?} */
        const a = this.neutrinosOauthService.login('/i-am-loggedin').then((/**
         * @param {?} tokens
         * @return {?}
         */
        tokens => {
            console.log('got tokens in component', tokens);
        })).catch((/**
         * @param {?} e
         * @return {?}
         */
        e => {
            console.error(e);
        }));
        // console.log(a);
    }
    /**
     * @return {?}
     */
    token() {
        this.neutrinosOauthService.getUserInfo().then((/**
         * @param {?} t
         * @return {?}
         */
        t => {
            console.log('t', t);
        })).catch(console.log);
    }
    /**
     * @return {?}
     */
    logout() {
        this.neutrinosOauthService.logout();
    }
    /**
     * @return {?}
     */
    userinfo() {
        alert(JSON.stringify(this.neutrinosOauthService.userInfo));
        console.log(this.neutrinosOauthService.userInfo);
    }
    /**
     * @return {?}
     */
    httpTest() {
        this.http.get('http://localhost:8081/api/ping').subscribe((/**
         * @param {?} res
         * @return {?}
         */
        res => {
            console.log(res);
        }), (/**
         * @param {?} e
         * @return {?}
         */
        e => {
            console.error(e);
        }));
    }
}
NeutrinosOauthComponent.decorators = [
    { type: Component, args: [{
                selector: 'lib-neutrinos-oauth',
                template: `
   NOTE: use this component only for testing. Not intended for production

      <button (click)="login()" >  Login </button>
      <button (click)="token()" > Get tokenset</button>
      <button (click)="logout()" > Logout </button>
      <button (click)="userinfo()" > In memory user info </button>
      <button (click)="httpTest()" > Http Interceptor test </button>
      `
            }] }
];
/** @nocollapse */
NeutrinosOauthComponent.ctorParameters = () => [
    { type: NeutrinosOAuthClientService },
    { type: HttpClient }
];
if (false) {
    /** @type {?} */
    NeutrinosOauthComponent.prototype.neutrinosOauthService;
    /**
     * @type {?}
     * @private
     */
    NeutrinosOauthComponent.prototype.http;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/cookie-interceptor.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CookieInterceptorService {
    /**
     * @param {?} utilService
     * @param {?} neutrinosOAuthClientService
     */
    constructor(utilService, neutrinosOAuthClientService) {
        this.utilService = utilService;
        this.neutrinosOAuthClientService = neutrinosOAuthClientService;
    }
    /**
     * @param {?} request
     * @param {?} next
     * @return {?}
     */
    intercept(request, next) {
        /* withCredentials adds cookies to the request for cross site (Only ssd urls).*/
        /** @type {?} */
        const baseUrl = this.utilService.getSSDBasePath();
        /** @type {?} */
        const isSSD = (baseUrl !== '' && request.url.includes(baseUrl));
        if (isSSD && this.isCrossDomain(baseUrl)) {
            request = request.clone({
                withCredentials: true
            });
        }
        return next.handle(request).pipe(map((/**
         * @param {?} event
         * @return {?}
         */
        event => {
            return event;
        })), catchError((/**
         * @param {?} errorResponse
         * @return {?}
         */
        (errorResponse) => {
            /*Intercept all requests and remove userinfo and cookies when status is 401 with code SESSION_EXPIRED, which means
            * cookies have expired or access has been revoked by the OAuth providers hence IDS rejected.  */
            if (errorResponse && errorResponse.hasOwnProperty('status') && errorResponse.status === 401 &&
                errorResponse.error.hasOwnProperty('code')) {
                this.neutrinosOAuthClientService.removeUserInfo(errorResponse.error);
            }
            return throwError(errorResponse);
        })));
    }
    /**
     * Returns true is the ssd url is running on a different domain than where UI is hosted.
     * For mobile Returns false always since UI is already bundled with cordova
     * If the user is not using IDS and is cross domain isIDSEnabled can be set to false to skip adding withCredentials
     * @private
     * @param {?} ssdUrl - string
     * @return {?}
     */
    isCrossDomain(ssdUrl) {
        try {
            ssdUrl = new URL(ssdUrl);
            return (this.utilService.getPlatformType() === 'browser' && (ssdUrl.host !== location.host)
                && this.utilService.getEnvValue('isIDSEnabled') === 'true');
        }
        catch (e) {
            return false; // ssdUrl is not a valid URL hence return false;
        }
    }
}
CookieInterceptorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CookieInterceptorService.ctorParameters = () => [
    { type: UtilService },
    { type: NeutrinosOAuthClientService }
];
/** @nocollapse */ CookieInterceptorService.ɵprov = ɵɵdefineInjectable({ factory: function CookieInterceptorService_Factory() { return new CookieInterceptorService(ɵɵinject(UtilService), ɵɵinject(NeutrinosOAuthClientService)); }, token: CookieInterceptorService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    CookieInterceptorService.prototype.utilService;
    /**
     * @type {?}
     * @private
     */
    CookieInterceptorService.prototype.neutrinosOAuthClientService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/neutrinos-oauth-client.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} neutrinosOAuthService
 * @param {?} utilService
 * @return {?}
 */
function getTokens(neutrinosOAuthService, utilService) {
    return (/**
     * @return {?}
     */
    () => {
        /**
         * For ios restore the cookies and get userInfo since iOS webview does not
         * persisit the cookie between app launches
         */
        if (utilService.getEnvValue('isIDSEnabled') === 'true') {
            if (window['device'] && window['device'].platform === 'iOS') {
                return neutrinosOAuthService.restoreCookies().then((/**
                 * @param {?} cookieExist
                 * @return {?}
                 */
                (cookieExist) => {
                    console.log('cookieExist' + cookieExist);
                    cookieExist ? neutrinosOAuthService.getUserInfo()
                        .catch((/**
                     * @param {?} userInfoErr
                     * @return {?}
                     */
                    userInfoErr => {
                        console.log(userInfoErr);
                    })) : null;
                }));
            }
            else {
                // Cannot get cookie for cross domain using JS. hence calling userinfo always
                return neutrinosOAuthService.getUserInfo()
                    .catch((/**
                 * @param {?} userInfoErr
                 * @return {?}
                 */
                userInfoErr => {
                    console.log(userInfoErr);
                }));
            }
        }
    });
}
// @dynamic (https://github.com/ng-packagr/ng-packagr/issues/641)
class NeutrinosOAuthClientModule {
}
NeutrinosOAuthClientModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NeutrinosOauthComponent],
                imports: [
                    HttpClientModule
                ],
                providers: [
                    {
                        provide: HTTP_INTERCEPTORS,
                        useClass: CookieInterceptorService,
                        multi: true
                    },
                    {
                        provide: APP_INITIALIZER,
                        useFactory: getTokens,
                        deps: [NeutrinosOAuthClientService, UtilService],
                        multi: true
                    },
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: neutrinos-oauth-client.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NeutrinosAuthGuardService, NeutrinosOAuthClientModule, NeutrinosOAuthClientService, getTokens, UtilService as ɵa, NeutrinosOauthComponent as ɵb, CookieInterceptorService as ɵc };
//# sourceMappingURL=neutrinos-oauth-client.js.map
