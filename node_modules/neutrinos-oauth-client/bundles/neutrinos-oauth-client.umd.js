(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common/http'), require('rxjs'), require('@angular/router'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('neutrinos-oauth-client', ['exports', '@angular/core', '@angular/common/http', 'rxjs', '@angular/router', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['neutrinos-oauth-client'] = {}, global.ng.core, global.ng.common.http, global.rxjs, global.ng.router, global.rxjs.operators));
}(this, (function (exports, i0, i2, rxjs, i2$1, operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/services/util.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var UtilService = /** @class */ (function () {
        function UtilService() {
            this.platformType = this.checkPlatformType();
            this.getEnvironment();
        }
        /**
         * Returns 'mobile' or 'browser' based on the platform
         * @return {?}
         */
        UtilService.prototype.getPlatformType = function () {
            return this.platformType;
        };
        /**
         * Returns env from neutrinos seed app
         * @private
         * @return {?}
         */
        UtilService.prototype.getEnvironment = function () {
            if (window['neutrinos'] && window['neutrinos']['environments'] && window['neutrinos']['environments']['properties']) {
                // Break the refernce
                this.environment = JSON.parse(JSON.stringify(window['neutrinos']['environments']['properties']));
                // Append the url with / if ssdUrl does not end with /
                if (this.environment['ssdURL']) {
                    this.environment['ssdURL'] = this.environment['ssdURL'].endsWith('/') ? this.environment['ssdURL'] :
                        (this.environment['ssdURL'] + '/');
                }
                return;
            }
            /*For dev env only */
            this.environment = {
                ssdURL: 'http://localhost:8081/api/',
                useDefaultExceptionUI: true,
                isIDSEnabled: 'true',
                webAppMountpoint: '',
                production: true
            };
        };
        /**
         * Returns 'mobile' or 'browser' based on the platform
         * @private
         * @return {?}
         */
        UtilService.prototype.checkPlatformType = function () {
            // tslint:disable-next-line: no-string-literal
            if (window['device'] && (window['device']['platform'] !== 'browser' || window['device']['platform'] !== 'Browser')) {
                return 'mobile';
                // tslint:disable-next-line: no-string-literal
            }
            else if (window['device'] && (window['device']['platform'] === 'browser' || window['device']['platform'] === 'Browser')) {
                return 'cordova_browser';
            }
            else {
                return 'browser';
            }
        };
        /*URL helper methods */
        /**
         * @return {?}
         */
        UtilService.prototype.getBaseLoginPath = function () {
            return this.environment.ssdURL + "login";
        };
        /**
         * @param {?} redirectTo
         * @return {?}
         */
        UtilService.prototype.getWebLoginUrl = function (redirectTo) {
            redirectTo = this.calcRedirectUrl(redirectTo);
            return this.getBaseLoginPath() + "?redirectTo=" + redirectTo;
        };
        /**
         * @return {?}
         */
        UtilService.prototype.getMobileLoginUrl = function () {
            return this.getBaseLoginPath() + "?isMobile=true";
        };
        /**
         * @param {?} redirectTo
         * @return {?}
         */
        UtilService.prototype.getWebLogoutUrl = function (redirectTo) {
            redirectTo = this.calcRedirectUrl(redirectTo);
            return this.environment.ssdURL + "logout?redirectTo=" + redirectTo;
        };
        /**
         * @return {?}
         */
        UtilService.prototype.getMobileLogoutUrl = function () {
            return this.environment.ssdURL + "logout?isMobile=true";
        };
        /**
         * @return {?}
         */
        UtilService.prototype.getUserInfoUrl = function () {
            return this.environment.ssdURL + "user/info";
        };
        /**
         * @return {?}
         */
        UtilService.prototype.getSSDBasePath = function () {
            return "" + this.environment.ssdURL;
        };
        /**
         *  Returns a absoulte url for the urlPath
         * @private
         * @param {?} urlPath - path relative to the current host
         * @return {?}
         */
        UtilService.prototype.calcRedirectUrl = function (urlPath) {
            if (urlPath) {
                /** @type {?} */
                var host = new URL(window.location.href).origin;
                if (!i0.isDevMode()) {
                    // Append `webAppMountpoint` to host
                    host = (this.environment.webAppMountpoint !== '' && this.environment.webAppMountpoint !== '/')
                        ? new URL(this.environment.webAppMountpoint, host).href : host;
                    // Get user redirect path with `webAppMountpoint`
                    /** @type {?} */
                    var mountPointWithRedirect = new URL(urlPath, host).pathname;
                    return host + mountPointWithRedirect;
                }
                else {
                    return new URL(urlPath, host);
                }
            }
            else {
                return window.location.href;
            }
        };
        /**
         *
         * @param {?} property - environment property key
         * @return {?}
         */
        UtilService.prototype.getEnvValue = function (property) {
            return this.environment[property];
        };
        return UtilService;
    }());
    UtilService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    UtilService.ctorParameters = function () { return []; };
    /** @nocollapse */ UtilService.ɵprov = i0.ɵɵdefineInjectable({ factory: function UtilService_Factory() { return new UtilService(); }, token: UtilService, providedIn: "root" });
    if (false) {
        /**
         * @type {?}
         * @private
         */
        UtilService.prototype.platformType;
        /**
         * @type {?}
         * @private
         */
        UtilService.prototype.environment;
    }

    var NeutrinosOAuthClientService = /** @class */ (function () {
        /**
         * @param {?} util
         * @param {?} http
         */
        function NeutrinosOAuthClientService(util, http) {
            this.util = util;
            this.http = http;
            this.cookieName = 'connect.sid';
            this.authStateSubject = new rxjs.Subject();
        }
        Object.defineProperty(NeutrinosOAuthClientService.prototype, "userInfo", {
            /**
             * Get user info and tokens of the current logged in user
             * @return {?}
             */
            get: function () {
                return this.currentUserInfo;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NeutrinosOAuthClientService.prototype, "isLoggedIn", {
            /**
             * @return {?}
             */
            get: function () {
                return this.currentUserInfo ? true : false;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @private
         * @param {?} userInfo
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.setUserInfo = function (userInfo) {
            this.currentUserInfo = userInfo;
        };
        /**
         * Performs authentication based on configuration and returns user info for mobile env and
         * for web app user info is stored in memory. Call userInfo getter method to retrieve userinfo
         * @param {?=} redirectBackUrl - url to redirect back to when authentication is done. Valid only for Web.
         * For mobile use the Promise returned to perform post authentication actions
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.login = function (redirectBackUrl) {
            var _this = this;
            return new Promise(( /**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */function (resolve, reject) {
                if (_this.util.getEnvValue('isIDSEnabled') === 'false') {
                    return reject({ message: 'IDS is not enabled in environments' });
                }
                if (_this.util.getPlatformType() === 'browser') {
                    _this.loginWithRedirect(redirectBackUrl);
                    return;
                }
                _this.loginWithInAppBrowser()
                    .then(( /**
             * @param {?} tokenset
             * @return {?}
             */function (/**
             * @param {?} tokenset
             * @return {?}
             */ tokenset) {
                    return resolve(tokenset);
                }))
                    .catch(( /**
             * @param {?} authError
             * @return {?}
             */function (/**
             * @param {?} authError
             * @return {?}
             */ authError) {
                    return reject(authError);
                }));
            }));
        };
        /**
         *
         * @private
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.loginWithInAppBrowser = function () {
            var _this = this;
            return new Promise(( /**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                var scriptURLS, script, inAppBrowserRef, executeScriptCB, exitCB;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            scriptURLS = ['/interaction/', '/auth-provider/return'];
                            return [4 /*yield*/, this.getScript()];
                        case 1:
                            script = _a.sent();
                            inAppBrowserRef = cordova.InAppBrowser.open(this.util.getMobileLoginUrl(), '_blank');
                            executeScriptCB = ( /**
                             * @param {?} event
                             * @return {?}
                             */function (event) {
                                if (event && event.hasOwnProperty('type') && event.hasOwnProperty('url') && event.type === 'loadstop'
                                    && _this.isURLMatch(event.url, scriptURLS)) {
                                    inAppBrowserRef.executeScript({ code: script }, ( /**
                                     * @return {?}
                                     */function () { }));
                                }
                            });
                            inAppBrowserRef.addEventListener('loadstop', executeScriptCB);
                            exitCB = ( /**
                             * @return {?}
                             */function () {
                                return reject({ code: 'auth-cancel', message: 'Authentication cancelled by user' });
                            });
                            inAppBrowserRef.addEventListener('message', ( /**
                             * @param {?} message
                             * @return {?}
                             */function (message) {
                                if (message && message.data && message.data.auth && message.data.auth === 'success') {
                                    inAppBrowserRef.removeEventListener('exit', exitCB);
                                    inAppBrowserRef.close();
                                    _this.getUserInfo().then(( /**
                                     * @param {?} tokenset
                                     * @return {?}
                                     */function (/**
                                     * @param {?} tokenset
                                     * @return {?}
                                     */ tokenset) {
                                        return resolve(tokenset);
                                    })).catch(( /**
                                     * @param {?} authErr
                                     * @return {?}
                                     */function (/**
                                     * @param {?} authErr
                                     * @return {?}
                                     */ authErr) {
                                        return reject(authErr);
                                    }));
                                }
                            }));
                            // settle the promise if user closed the in app browser manually
                            inAppBrowserRef.addEventListener('exit', exitCB);
                            return [2 /*return*/];
                    }
                });
            }); }));
        };
        /**
         * @private
         * @param {?} url
         * @param {?} compareWith
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.isURLMatch = function (url, compareWith) {
            return compareWith.some(( /**
             * @param {?} u
             * @return {?}
             */function (/**
             * @param {?} u
             * @return {?}
             */ u) { return url.includes(u); }));
        };
        /**
         * Returns JS as a string to be executed in inAppBrowser which sets guid and device details in localStorage
         * @private
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.getScript = function () {
            return __awaiter(this, void 0, void 0, function () {
                var deviceDetails, guid, guidScript, script;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            deviceDetails = JSON.stringify(window['device']) || {};
                            return [4 /*yield*/, this.getuniqueDeviceID()];
                        case 1:
                            guid = _a.sent();
                            guidScript = guid ? "localStorage.setItem('guid', '" + guid + "')" : '';
                            script = guidScript + "\n          localStorage.setItem('additionalInfo', '" + deviceDetails + "')\n          window.isScriptExecuted = true;";
                            return [2 /*return*/, script];
                    }
                });
            });
        };
        /**
         * @private
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.getuniqueDeviceID = function () {
            return new Promise(( /**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */function (resolve, reject) {
                window['plugins'].uniqueDeviceID.get(( /**
                 * @param {?} guid
                 * @return {?}
                 */function (guid) {
                    return resolve(guid);
                }), ( /**
                 * @param {?} error
                 * @return {?}
                 */function (/**
                 * @param {?} error
                 * @return {?}
                 */ error) {
                    return resolve(null);
                }));
            }));
        };
        /**
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.getUserInfo = function () {
            var _this = this;
            return new Promise(( /**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */function (resolve, reject) {
                /** @type {?} */
                var headers = new i2.HttpHeaders();
                /*Edge case: Userinfo is retreived from cache when login page is opened and user cancels the login attempt  */
                headers = headers.set('Cache-Control', 'no-cache, no-store, must-revalidate');
                headers = headers.set('Pragma', 'no-cache');
                headers = headers.set('Expires', '0');
                _this.http.get(_this.util.getUserInfoUrl(), { headers: headers }).subscribe(( /**
                 * @param {?} tokenset
                 * @return {?}
                 */function (/**
                 * @param {?} tokenset
                 * @return {?}
                 */ tokenset) {
                    _this.setUserInfo(tokenset);
                    return resolve(tokenset);
                }), ( /**
                 * @param {?} error
                 * @return {?}
                 */function (/**
                 * @param {?} error
                 * @return {?}
                 */ error) {
                    _this.destroyClientSession();
                    return reject(error);
                }));
            }));
        };
        /*If SSD throws 401 during any http request due to refresh token expiry, cookie expiry or access revoke nullify the userinfo in memory
          and emit authState event  */
        /**
         * @param {?} errorResponse
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.removeUserInfo = function (errorResponse) {
            this.destroyClientSession();
            this.authStateSubject.next(errorResponse);
        };
        /**
         * Returns event when Auth state has changed due to session expiry, access revoke or cookie expiry.
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.authState = function () {
            return this.authStateSubject.asObservable();
        };
        /**
         * @private
         * @param {?} redirectBackUrl
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.loginWithRedirect = function (redirectBackUrl) {
            window.location.href = this.util.getWebLoginUrl(redirectBackUrl);
        };
        /**
         * Restores the connect.sid cookie from session storage during app bootstrap if device is mobile
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.restoreCookies = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.getCookie(this.cookieName, this.util.getSSDBasePath())
                                .then(( /**
                         * @param {?} connectSid
                         * @return {?}
                         */function (connectSid) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this.setCookie(this.util.getSSDBasePath(), this.cookieName, connectSid)];
                                        case 1: return [2 /*return*/, _a.sent()];
                                    }
                                });
                            }); })).catch(( /**
                             * @param {?} error
                             * @return {?}
                             */function (error) {
                                return false;
                            }))];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        /**
         *
         * @private
         * @param {?} url - site where the cookie is stored
         * @param {?} cookieName - name of the cookie to restore
         * @param {?} cookieValue - value of the cookie to restore
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.setCookie = function (url, cookieName, cookieValue) {
            return new Promise(( /**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */function (resolve, reject) {
                cookieMaster.setCookieValue(url, cookieName, cookieValue, ( /**
                 * @return {?}
                 */function () {
                    return resolve(true);
                }), ( /**
                 * @param {?} error
                 * @return {?}
                 */function (error) {
                    return reject(false);
                }));
            }));
        };
        /**
         *
         * @private
         * @param {?} cookieName          name of the cookie to retrieve
         * @param {?} fullCookieString    String containing all the cookies from an url
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.readCookieValueFromCookieString = function (cookieName, fullCookieString) {
            /** @type {?} */
            var cookieNameWithEqualsSign = cookieName + "=";
            /** @type {?} */
            var cookieArray = fullCookieString.split(';');
            for (var i = 0; i < cookieArray.length; i++) {
                /** @type {?} */
                var cookie = cookieArray[i];
                // Remove unnecessary leading spaces from cookie
                while (cookie.charAt(0) == ' ') {
                    cookie = cookie.substring(1, cookie.length);
                }
                // Retrieve and return cookie value
                if (cookie.indexOf(cookieNameWithEqualsSign) == 0) {
                    return cookie.substring(cookieNameWithEqualsSign.length, cookie.length);
                }
            }
            return null;
        };
        /**
         *
         * @private
         * @param {?} cookieName - name of the cookie to retrieve
         * @param {?} url - site where the cookie is stored
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.getCookie = function (cookieName, url) {
            var _this = this;
            return new Promise(( /**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */function (resolve, reject) {
                window['cordova'].plugins.CookiesPlugin.getCookie(url, ( /**
                 * @param {?} cookies
                 * @return {?}
                 */function (cookies) {
                    /** @type {?} */
                    var cookieValue = _this.readCookieValueFromCookieString(cookieName, cookies);
                    if (cookieValue) {
                        return resolve(cookieValue);
                    }
                    else {
                        return reject("cookie value null");
                    }
                }), ( /**
                 * @param {?} error
                 * @return {?}
                 */function (error) {
                    return reject(error);
                }));
            }));
        };
        /**
         * Logout the current user, destroys session between client and server.
         * @param {?=} redirectBackUrl - URL where the user is navigated post logout. Valid only for Web.
         * For mobile use the Promise returned to perform post authentication actions
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.logout = function (redirectBackUrl) {
            var _this = this;
            /** @type {?} */
            var logoutUrl = (this.util.getPlatformType() === 'browser') ? this.util.getWebLogoutUrl(redirectBackUrl)
                : this.util.getMobileLogoutUrl();
            return new Promise(( /**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */function (resolve, reject) {
                _this.http.get(logoutUrl).subscribe(( /**
                 * @param {?} idsLogoutInfo
                 * @return {?}
                 */function (/**
                 * @param {?} idsLogoutInfo
                 * @return {?}
                 */ idsLogoutInfo) {
                    _this.destroyIDSSession(idsLogoutInfo)
                        .then(( /**
                 * @return {?}
                 */function () {
                        return resolve();
                    }))
                        .catch(( /**
                 * @param {?} logoutErr
                 * @return {?}
                 */function (/**
                 * @param {?} logoutErr
                 * @return {?}
                 */ logoutErr) {
                        return reject(logoutErr);
                    }));
                }), ( /**
                 * @param {?} logoutError
                 * @return {?}
                 */function (/**
                 * @param {?} logoutError
                 * @return {?}
                 */ logoutError) {
                    return reject(logoutError);
                }));
            }));
        };
        /**
         * @private
         * @param {?} idsInfo
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.destroyIDSSession = function (idsInfo) {
            var _this = this;
            return new Promise(( /**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */function (resolve, reject) {
                if (idsInfo['sessionExists'] === false) {
                    // No session present with SSD due to cookie expiry
                    _this.destroyClientSession();
                    _this.authStateSubject.next({ code: 'NO_SESSION', message: 'User session has already expired' });
                    return resolve();
                }
                if (_this.util.getPlatformType() === 'browser') {
                    window.location.href = idsInfo['idsURL'];
                }
                else {
                    _this.logoutWithInappBrowser(idsInfo['idsURL'])
                        .then(( /**
                 * @return {?}
                 */function () {
                        return resolve();
                    }))
                        .catch(( /**
                 * @param {?} sessionError
                 * @return {?}
                 */function (/**
                 * @param {?} sessionError
                 * @return {?}
                 */ sessionError) {
                        return reject(sessionError);
                    }));
                }
            }));
        };
        /**
         *
         * @private
         * @param {?} idsLogoutUrl - IDS logout url
         * Opens InApp browser and destroys the session
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.logoutWithInappBrowser = function (idsLogoutUrl) {
            var _this = this;
            return new Promise(( /**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */function (resolve, reject) {
                /** @type {?} */
                var exitCB = ( /**
                 * @return {?}
                 */function () {
                    return reject({ code: 'auth-cancel', message: 'Authentication cancelled by user' });
                });
                /** @type {?} */
                var inAppBrowserRef = cordova.InAppBrowser.open(idsLogoutUrl, '_blank');
                inAppBrowserRef.addEventListener('message', ( /**
                 * @param {?} message
                 * @return {?}
                 */function (message) {
                    // Remove exit listener if script closed the in app browser
                    if (message && message.data && message.data.auth && message.data.auth === 'success') {
                        inAppBrowserRef.removeEventListener('exit', exitCB);
                        inAppBrowserRef.close();
                        _this.destroyClientSession();
                        return resolve();
                    }
                }));
                // settle the promise if user closed the in app browser manually
                inAppBrowserRef.addEventListener('exit', exitCB);
            }));
        };
        /*Remove persisted cookies in local storage and nullify user info */
        /**
         * @private
         * @return {?}
         */
        NeutrinosOAuthClientService.prototype.destroyClientSession = function () {
            this.setUserInfo(null);
        };
        return NeutrinosOAuthClientService;
    }());
    NeutrinosOAuthClientService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NeutrinosOAuthClientService.ctorParameters = function () { return [
        { type: UtilService },
        { type: i2.HttpClient }
    ]; };
    /** @nocollapse */ NeutrinosOAuthClientService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NeutrinosOAuthClientService_Factory() { return new NeutrinosOAuthClientService(i0.ɵɵinject(UtilService), i0.ɵɵinject(i2.HttpClient)); }, token: NeutrinosOAuthClientService, providedIn: "root" });
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NeutrinosOAuthClientService.prototype.cookieName;
        /**
         * @type {?}
         * @private
         */
        NeutrinosOAuthClientService.prototype.currentUserInfo;
        /**
         * @type {?}
         * @private
         */
        NeutrinosOAuthClientService.prototype.authStateSubject;
        /**
         * @type {?}
         * @private
         */
        NeutrinosOAuthClientService.prototype.util;
        /**
         * @type {?}
         * @private
         */
        NeutrinosOAuthClientService.prototype.http;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/auth-guard.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NeutrinosAuthGuardService = /** @class */ (function () {
        /**
         * @param {?} _neutrinosOAuthClientService
         * @param {?} _router
         * @param {?} _arouter
         */
        function NeutrinosAuthGuardService(_neutrinosOAuthClientService, _router, _arouter) {
            this._neutrinosOAuthClientService = _neutrinosOAuthClientService;
            this._router = _router;
            this._arouter = _arouter;
        }
        /**
         * @param {?} route
         * @param {?} state
         * @return {?}
         */
        NeutrinosAuthGuardService.prototype.canActivate = function (route, state) {
            var _this = this;
            return new Promise(( /**
             * @param {?} resolve
             * @param {?} reject
             * @return {?}
             */function (resolve, reject) {
                _this.currUrl = state.url;
                if (_this._neutrinosOAuthClientService.isLoggedIn) {
                    return resolve(true);
                }
                else {
                    _this._neutrinosOAuthClientService.login().then(( /**
                     * @param {?} tokenSet
                     * @return {?}
                     */function (/**
                     * @param {?} tokenSet
                     * @return {?}
                     */ tokenSet) {
                        _this._router.navigate([_this.currUrl]);
                        return resolve(true);
                    }))
                        .catch(( /**
                 * @param {?} err
                 * @return {?}
                 */function (/**
                 * @param {?} err
                 * @return {?}
                 */ err) {
                        console.error(err);
                        if (err && err.code == 'auth-cancel') {
                            // Added setTimeout for reloading the current route
                            setTimeout(( /**
                             * @return {?}
                             */function () {
                                _this._router.navigateByUrl(_this.currUrl, { skipLocationChange: true }).then(( /**
                                 * @return {?}
                                 */function () {
                                    return resolve(false);
                                }));
                            }), 500);
                        }
                        else {
                            return resolve(false);
                        }
                    }));
                }
            }));
        };
        return NeutrinosAuthGuardService;
    }());
    NeutrinosAuthGuardService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NeutrinosAuthGuardService.ctorParameters = function () { return [
        { type: NeutrinosOAuthClientService },
        { type: i2$1.Router },
        { type: i2$1.ActivatedRoute }
    ]; };
    /** @nocollapse */ NeutrinosAuthGuardService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NeutrinosAuthGuardService_Factory() { return new NeutrinosAuthGuardService(i0.ɵɵinject(NeutrinosOAuthClientService), i0.ɵɵinject(i2$1.Router), i0.ɵɵinject(i2$1.ActivatedRoute)); }, token: NeutrinosAuthGuardService, providedIn: "root" });
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NeutrinosAuthGuardService.prototype.currUrl;
        /**
         * @type {?}
         * @private
         */
        NeutrinosAuthGuardService.prototype._neutrinosOAuthClientService;
        /**
         * @type {?}
         * @private
         */
        NeutrinosAuthGuardService.prototype._router;
        /**
         * @type {?}
         * @private
         */
        NeutrinosAuthGuardService.prototype._arouter;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/neutrinos-oauth.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NeutrinosOauthComponent = /** @class */ (function () {
        /**
         * @param {?} neutrinosOauthService
         * @param {?} http
         */
        function NeutrinosOauthComponent(neutrinosOauthService, http) {
            this.neutrinosOauthService = neutrinosOauthService;
            this.http = http;
        }
        /**
         * @return {?}
         */
        NeutrinosOauthComponent.prototype.ngOnInit = function () {
            this.neutrinosOauthService.authState().subscribe(( /**
             * @param {?} state
             * @return {?}
             */function (/**
             * @param {?} state
             * @return {?}
             */ state) {
                console.log(state);
            }));
        };
        /**
         * @return {?}
         */
        NeutrinosOauthComponent.prototype.login = function () {
            /** @type {?} */
            var a = this.neutrinosOauthService.login('/i-am-loggedin').then(( /**
             * @param {?} tokens
             * @return {?}
             */function (/**
             * @param {?} tokens
             * @return {?}
             */ tokens) {
                console.log('got tokens in component', tokens);
            })).catch(( /**
             * @param {?} e
             * @return {?}
             */function (/**
             * @param {?} e
             * @return {?}
             */ e) {
                console.error(e);
            }));
            // console.log(a);
        };
        /**
         * @return {?}
         */
        NeutrinosOauthComponent.prototype.token = function () {
            this.neutrinosOauthService.getUserInfo().then(( /**
             * @param {?} t
             * @return {?}
             */function (/**
             * @param {?} t
             * @return {?}
             */ t) {
                console.log('t', t);
            })).catch(console.log);
        };
        /**
         * @return {?}
         */
        NeutrinosOauthComponent.prototype.logout = function () {
            this.neutrinosOauthService.logout();
        };
        /**
         * @return {?}
         */
        NeutrinosOauthComponent.prototype.userinfo = function () {
            alert(JSON.stringify(this.neutrinosOauthService.userInfo));
            console.log(this.neutrinosOauthService.userInfo);
        };
        /**
         * @return {?}
         */
        NeutrinosOauthComponent.prototype.httpTest = function () {
            this.http.get('http://localhost:8081/api/ping').subscribe(( /**
             * @param {?} res
             * @return {?}
             */function (/**
             * @param {?} res
             * @return {?}
             */ res) {
                console.log(res);
            }), ( /**
             * @param {?} e
             * @return {?}
             */function (/**
             * @param {?} e
             * @return {?}
             */ e) {
                console.error(e);
            }));
        };
        return NeutrinosOauthComponent;
    }());
    NeutrinosOauthComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'lib-neutrinos-oauth',
                    template: "\n   NOTE: use this component only for testing. Not intended for production\n\n      <button (click)=\"login()\" >  Login </button>\n      <button (click)=\"token()\" > Get tokenset</button>\n      <button (click)=\"logout()\" > Logout </button>\n      <button (click)=\"userinfo()\" > In memory user info </button>\n      <button (click)=\"httpTest()\" > Http Interceptor test </button>\n      "
                }] }
    ];
    /** @nocollapse */
    NeutrinosOauthComponent.ctorParameters = function () { return [
        { type: NeutrinosOAuthClientService },
        { type: i2.HttpClient }
    ]; };
    if (false) {
        /** @type {?} */
        NeutrinosOauthComponent.prototype.neutrinosOauthService;
        /**
         * @type {?}
         * @private
         */
        NeutrinosOauthComponent.prototype.http;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/cookie-interceptor.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CookieInterceptorService = /** @class */ (function () {
        /**
         * @param {?} utilService
         * @param {?} neutrinosOAuthClientService
         */
        function CookieInterceptorService(utilService, neutrinosOAuthClientService) {
            this.utilService = utilService;
            this.neutrinosOAuthClientService = neutrinosOAuthClientService;
        }
        /**
         * @param {?} request
         * @param {?} next
         * @return {?}
         */
        CookieInterceptorService.prototype.intercept = function (request, next) {
            var _this = this;
            /* withCredentials adds cookies to the request for cross site (Only ssd urls).*/
            /** @type {?} */
            var baseUrl = this.utilService.getSSDBasePath();
            /** @type {?} */
            var isSSD = (baseUrl !== '' && request.url.includes(baseUrl));
            if (isSSD && this.isCrossDomain(baseUrl)) {
                request = request.clone({
                    withCredentials: true
                });
            }
            return next.handle(request).pipe(operators.map(( /**
             * @param {?} event
             * @return {?}
             */function (/**
             * @param {?} event
             * @return {?}
             */ event) {
                return event;
            })), operators.catchError(( /**
             * @param {?} errorResponse
             * @return {?}
             */function (errorResponse) {
                /*Intercept all requests and remove userinfo and cookies when status is 401 with code SESSION_EXPIRED, which means
                * cookies have expired or access has been revoked by the OAuth providers hence IDS rejected.  */
                if (errorResponse && errorResponse.hasOwnProperty('status') && errorResponse.status === 401 &&
                    errorResponse.error.hasOwnProperty('code')) {
                    _this.neutrinosOAuthClientService.removeUserInfo(errorResponse.error);
                }
                return rxjs.throwError(errorResponse);
            })));
        };
        /**
         * Returns true is the ssd url is running on a different domain than where UI is hosted.
         * For mobile Returns false always since UI is already bundled with cordova
         * If the user is not using IDS and is cross domain isIDSEnabled can be set to false to skip adding withCredentials
         * @private
         * @param {?} ssdUrl - string
         * @return {?}
         */
        CookieInterceptorService.prototype.isCrossDomain = function (ssdUrl) {
            try {
                ssdUrl = new URL(ssdUrl);
                return (this.utilService.getPlatformType() === 'browser' && (ssdUrl.host !== location.host)
                    && this.utilService.getEnvValue('isIDSEnabled') === 'true');
            }
            catch (e) {
                return false; // ssdUrl is not a valid URL hence return false;
            }
        };
        return CookieInterceptorService;
    }());
    CookieInterceptorService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    CookieInterceptorService.ctorParameters = function () { return [
        { type: UtilService },
        { type: NeutrinosOAuthClientService }
    ]; };
    /** @nocollapse */ CookieInterceptorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CookieInterceptorService_Factory() { return new CookieInterceptorService(i0.ɵɵinject(UtilService), i0.ɵɵinject(NeutrinosOAuthClientService)); }, token: CookieInterceptorService, providedIn: "root" });
    if (false) {
        /**
         * @type {?}
         * @private
         */
        CookieInterceptorService.prototype.utilService;
        /**
         * @type {?}
         * @private
         */
        CookieInterceptorService.prototype.neutrinosOAuthClientService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/neutrinos-oauth-client.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} neutrinosOAuthService
     * @param {?} utilService
     * @return {?}
     */
    function getTokens(neutrinosOAuthService, utilService) {
        return ( /**
         * @return {?}
         */function () {
            /**
             * For ios restore the cookies and get userInfo since iOS webview does not
             * persisit the cookie between app launches
             */
            if (utilService.getEnvValue('isIDSEnabled') === 'true') {
                if (window['device'] && window['device'].platform === 'iOS') {
                    return neutrinosOAuthService.restoreCookies().then(( /**
                     * @param {?} cookieExist
                     * @return {?}
                     */function (cookieExist) {
                        console.log('cookieExist' + cookieExist);
                        cookieExist ? neutrinosOAuthService.getUserInfo()
                            .catch(( /**
                     * @param {?} userInfoErr
                     * @return {?}
                     */function (/**
                     * @param {?} userInfoErr
                     * @return {?}
                     */ userInfoErr) {
                            console.log(userInfoErr);
                        })) : null;
                    }));
                }
                else {
                    // Cannot get cookie for cross domain using JS. hence calling userinfo always
                    return neutrinosOAuthService.getUserInfo()
                        .catch(( /**
                 * @param {?} userInfoErr
                 * @return {?}
                 */function (/**
                 * @param {?} userInfoErr
                 * @return {?}
                 */ userInfoErr) {
                        console.log(userInfoErr);
                    }));
                }
            }
        });
    }
    // @dynamic (https://github.com/ng-packagr/ng-packagr/issues/641)
    var NeutrinosOAuthClientModule = /** @class */ (function () {
        function NeutrinosOAuthClientModule() {
        }
        return NeutrinosOAuthClientModule;
    }());
    NeutrinosOAuthClientModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [NeutrinosOauthComponent],
                    imports: [
                        i2.HttpClientModule
                    ],
                    providers: [
                        {
                            provide: i2.HTTP_INTERCEPTORS,
                            useClass: CookieInterceptorService,
                            multi: true
                        },
                        {
                            provide: i0.APP_INITIALIZER,
                            useFactory: getTokens,
                            deps: [NeutrinosOAuthClientService, UtilService],
                            multi: true
                        },
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: neutrinos-oauth-client.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.NeutrinosAuthGuardService = NeutrinosAuthGuardService;
    exports.NeutrinosOAuthClientModule = NeutrinosOAuthClientModule;
    exports.NeutrinosOAuthClientService = NeutrinosOAuthClientService;
    exports.getTokens = getTokens;
    exports.ɵa = UtilService;
    exports.ɵb = NeutrinosOauthComponent;
    exports.ɵc = CookieInterceptorService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=neutrinos-oauth-client.umd.js.map
